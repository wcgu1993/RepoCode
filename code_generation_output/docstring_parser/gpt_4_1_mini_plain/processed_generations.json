{"task_id": 165, "project": "test-apps/docstring_parser", "module": "docstring_parser.google", "predictions": ["def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # A basic Docstring class to store sections; replace or adjust as needed\n    class Docstring:\n        def __init__(self):\n            self.short_description = \"\"\n            self.long_description = \"\"\n            self.params = []\n            self.returns = None\n            self.raises = []\n            self.examples = \"\"\n            self.other_sections = defaultdict(list)\n\n        def __repr__(self):\n            return (f\"Docstring(short_description={self.short_description!r}, \"\n                    f\"long_description={self.long_description!r}, params={self.params!r}, \"\n                    f\"returns={self.returns!r}, raises={self.raises!r}, \"\n                    f\"examples={self.examples!r}, other_sections={dict(self.other_sections)!r})\")\n\n    lines = text.expandtabs().splitlines()\n    doc = Docstring()\n\n    def strip_empty_ends(lst):\n        while lst and not lst[0].strip():\n            lst.pop(0)\n        while lst and not lst[-1].strip():\n            lst.pop()\n        return lst\n\n    # Identify sections by their headers, e.g. \"Args:\", \"Returns:\", \"Raises:\", \"Examples:\" etc.\n    section_headers = {'Args:', 'Arguments:', 'Parameters:', 'Returns:', 'Raise:', 'Raises:', 'Examples:', 'Example:'}\n    # Map section header to normalized section name\n    section_aliases = {\n        'Args:': 'params',\n        'Arguments:': 'params',\n        'Parameters:': 'params',\n        'Returns:': 'returns',\n        'Raise:': 'raises',\n        'Raises:': 'raises',\n        'Example:': 'examples',\n        'Examples:': 'examples'\n    }\n\n    # Parse line by line, detect sections\n    current_section = None\n    section_content = []\n    # These will accumulate the content of each section\n    sections = defaultdict(list)\n\n    i = 0\n    n = len(lines)\n\n    # Gather all sections content\n    while i < n:\n        line = lines[i].rstrip()\n        if line in section_headers:\n            # Save previous section content\n            if current_section:\n                sections[current_section].extend(strip_empty_ends(section_content))\n            current_section = section_aliases[line]\n            section_content = []\n            i += 1\n            # Skip empty lines after section header\n            while i < n and not lines[i].strip():\n                i += 1\n            continue\n        elif current_section:\n            section_content.append(lines[i])\n        else:\n            # Outside any section, accumulate as description\n            section_content.append(lines[i])\n        i += 1\n\n    # Save last section content if any\n    if current_section:\n        sections[current_section].extend(strip_empty_ends(section_content))\n    else:\n        # No sections at all, all is description\n        sections['description'] = strip_empty_ends(section_content)\n\n    # Extract short and long description from description section\n    desc_lines = sections.get('description', [])\n    # Short description is first non-blank line\n    # Long description is rest separated by a blank line\n    short_desc_lines = []\n    long_desc_lines = []\n    if desc_lines:\n        # Find first block (contiguous non-blank lines) as short description\n        i = 0\n        while i < len(desc_lines) and not desc_lines[i].strip():\n            i += 1\n        while i < len(desc_lines) and desc_lines[i].strip():\n            short_desc_lines.append(desc_lines[i].strip())\n            i += 1\n        # After a blank line, rest is long description\n        while i < len(desc_lines) and not desc_lines[i].strip():\n            i += 1\n        while i < len(desc_lines):\n            long_desc_lines.append(desc_lines[i])\n            i += 1\n\n    doc.short_description = \" \".join(short_desc_lines)\n    doc.long_description = \"\\n\".join(long_desc_lines).strip()\n\n    # Parse params section\n    params_lines = sections.get('params', [])\n    # Expected format: each param is indented line of form:\n    # name (type): description\n    # which could extend in indented following lines\n    param_regex = re.compile(r'^(\\s*)(\\w+)\\s*(\\(([^)]+)\\))?:\\s*(.*)$')\n    param_list = []\n    current_param = None\n\n    for line in params_lines:\n        m = param_regex.match(line)\n        if m:\n            # save prev param\n            if current_param:\n                param_list.append(current_param)\n            indent, name, _, type_, desc = m.groups()\n            current_param = {\n                'name': name,\n                'type': type_ or None,\n                'description': desc.strip()\n            }\n            current_indent = len(indent)\n        else:\n            # continuation line (indented more)\n            if current_param and line.strip():\n                cont_line = line.strip()\n                # append with a space\n                current_param['description'] += ' ' + cont_line\n\n    if current_param:\n        param_list.append(current_param)\n\n    doc.params = param_list\n\n    # Parse returns section\n    returns_lines = sections.get('returns', [])\n    if returns_lines:\n        # The first line may have type and description separated by colon or parenthesis\n        # Try to parse \"type: description\"\n        returns_text = \"\\n\".join(returns_lines).strip()\n        m = re.match(r'^(\\w+)\\s*:\\s*(.*)$', returns_text)\n        if m:\n            ret_type, ret_desc = m.groups()\n            doc.returns = {'type': ret_type, 'description': ret_desc.strip()}\n        else:\n            # fallback: single string as description, no type\n            doc.returns = {'type': None, 'description': returns_text}\n\n    # Parse raises section\n    raises_lines = sections.get('raises', [])\n    # Expect lines like \"ErrorType: description\"\n    raises_list = []\n    raise_regex = re.compile(r'^(\\s*)(\\w+)\\s*:\\s*(.*)$')\n    current_raise = None\n    for line in raises_lines:\n        m = raise_regex.match(line)\n        if m:\n            if current_raise:\n                raises_list.append(current_raise)\n            _, exc_type, desc = m.groups()\n            current_raise = {'type': exc_type, 'description': desc.strip()}\n        else:\n            if current_raise and line.strip():\n                current_raise['description'] += ' ' + line.strip()\n    if current_raise:\n        raises_list.append(current_raise)\n\n    doc.raises = raises_list\n\n    # Parse examples section\n    examples_lines = sections.get('examples', [])\n    doc.examples = \"\\n\".join(examples_lines).strip()\n\n    # Add any unknown sections\n    for sec, content in sections.items():\n        if sec not in {'description', 'params', 'returns', 'raises', 'examples'}:\n            doc.other_sections[sec].extend(content)\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import namedtuple\n\n    Docstring = namedtuple('Docstring', ['short_description', 'long_description', 'params', 'returns', 'raises'])\n\n    # Normalize line endings and split lines\n    lines = text.replace('\\r\\n', '\\n').replace('\\r', '\\n').split('\\n')\n    lines = [line.rstrip() for line in lines]\n\n    short_description = ''\n    long_description_lines = []\n    params = []\n    returns = None\n    raises = []\n\n    mode = 'short_desc'  # modes: short_desc, long_desc, params, returns, raises, other\n\n    param_pattern = re.compile(r'^(\\w+)(?:\\s*\\(([^)]+)\\))?:\\s*(.*)$')\n    return_pattern = re.compile(r'^(.*)$')\n    raise_pattern = re.compile(r'^(\\w+):\\s*(.*)$')\n\n    i = 0\n    n = len(lines)\n\n    # Parse short description as first non-empty line\n    while i < n and lines[i].strip() == '':\n        i +=1\n    if i < n:\n        short_description = lines[i].strip()\n        i +=1\n\n    # Parse until blank line or section header as long description\n    while i < n:\n        line = lines[i]\n        stripped = line.strip()\n        if stripped == '':\n            i += 1\n            # Only stop if next line is a section header, otherwise continue long description\n            if i < n and re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', lines[i], re.I):\n                break\n            else:\n                long_description_lines.append('')\n            continue\n        if re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', stripped, re.I):\n            break\n        long_description_lines.append(line)\n        i += 1\n\n    long_description = '\\n'.join(long_description_lines).strip()\n\n    # Helper to consume indented block lines\n    def collect_indented_block(start_idx):\n        block_lines = []\n        base_indent = None\n        j = start_idx\n        while j < n:\n            l = lines[j]\n            if l.strip() == '':\n                block_lines.append('')\n                j += 1\n                continue\n            indent = len(l) - len(l.lstrip())\n            if base_indent is None:\n                base_indent = indent\n            if indent < base_indent:\n                break\n            block_lines.append(l[base_indent:])\n            j += 1\n        return block_lines, j\n\n    # Parse sections\n    while i < n:\n        line = lines[i].strip()\n        if line.lower() in ('args:', 'arguments:', 'parameters:'):\n            i +=1\n            # parse params\n            while i < n:\n                l = lines[i]\n                if l.strip() == '':\n                    i += 1\n                    continue\n                # Stop at next section or outdent\n                if re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', l.strip(), re.I):\n                    break\n                indent = len(l) - len(l.lstrip())\n                if indent == 0:  # no indent means new section or end\n                    break\n                # Parse param line\n                param_match = param_pattern.match(l.strip())\n                if param_match:\n                    name, type_, desc = param_match.groups()\n                    # Collect continuation lines indented further\n                    j = i + 1\n                    description_lines = [desc]\n                    while j < n:\n                        next_line = lines[j]\n                        next_indent = len(next_line) - len(next_line.lstrip())\n                        if next_line.strip() == '':\n                            description_lines.append('')\n                            j += 1\n                            continue\n                        if next_indent <= indent:\n                            break\n                        description_lines.append(next_line.strip())\n                        j += 1\n                    full_desc = ' '.join(description_lines).strip()\n                    params.append({'name': name, 'type': type_, 'description': full_desc})\n                    i = j\n                else:\n                    # maybe just description continuation or malformed line, ignore or break\n                    i += 1\n            continue\n\n        elif line.lower() == 'returns:':\n            i +=1\n            # parse returns; single description, possibly multi-line indented\n            desc_lines, new_i = collect_indented_block(i)\n            i = new_i\n            desc = '\\n'.join(desc_lines).strip()\n            returns = desc if desc else None\n            continue\n\n        elif line.lower() == 'raises:':\n            i +=1\n            # parse raises\n            while i < n:\n                l = lines[i]\n                if l.strip() == '':\n                    i += 1\n                    continue\n                if re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', l.strip(), re.I):\n                    break\n                indent = len(l) - len(l.lstrip())\n                if indent == 0:\n                    break\n                raise_match = raise_pattern.match(l.strip())\n                if raise_match:\n                    excname, desc = raise_match.groups()\n                    j = i + 1\n                    description_lines = [desc]\n                    while j < n:\n                        next_line = lines[j]\n                        next_indent = len(next_line) - len(next_line.lstrip())\n                        if next_line.strip() == '':\n                            description_lines.append('')\n                            j += 1\n                            continue\n                        if next_indent <= indent:\n                            break\n                        description_lines.append(next_line.strip())\n                        j += 1\n                    full_desc = ' '.join(description_lines).strip()\n                    raises.append({'type': excname, 'description': full_desc})\n                    i = j\n                else:\n                    i += 1\n            continue\n\n        else:\n            # Unknown or empty section, jump to next line\n            i += 1\n\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        params=params,\n        returns=returns,\n        raises=raises\n    )", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_description = \"\"\n            self.long_description = \"\"\n            self.args = []\n            self.returns = None\n            self.raises = []\n            self.examples = \"\"\n\n        def __repr__(self):\n            return (\n                f\"Docstring(short_description={self.short_description!r}, \"\n                f\"long_description={self.long_description!r}, \"\n                f\"args={self.args!r}, returns={self.returns!r}, \"\n                f\"raises={self.raises!r}, examples={self.examples!r})\"\n            )\n\n    doc = Docstring()\n    lines = text.strip().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    # Split the docstring into sections by headings and blank lines\n    section_headers = {\n        \"Args:\": \"args\",\n        \"Arguments:\": \"args\",\n        \"Parameters:\": \"args\",\n        \"Returns:\": \"returns\",\n        \"Return:\": \"returns\",\n        \"Raises:\": \"raises\",\n        \"Examples:\": \"examples\"\n    }\n    \n    current_section = None\n    buffer = []\n    arg_buffer = []\n    is_in_args = False\n\n    # Helper to flush buffer\n    def flush_buffer(section_name, buf):\n        content = \"\\n\".join(buf).strip()\n        if section_name == 'args':\n            # Parse arguments from buf lines\n            args = []\n            arg_name = None\n            arg_type = None\n            arg_desc_lines = []\n\n            arg_line_re = re.compile(r'^ {4}(\\w+)(\\s*\\(([^)]+)\\))?:\\s*(.*)$')\n            # For example: \"    param_name (int): description\"\n\n            for line in buf:\n                m = arg_line_re.match(line)\n                if m:\n                    # if previous arg data exists, store it\n                    if arg_name:\n                        args.append({\n                            \"name\": arg_name,\n                            \"type\": arg_type,\n                            \"description\": \" \".join(arg_desc_lines).strip()\n                        })\n                    arg_name = m.group(1)\n                    arg_type = m.group(3) if m.group(3) else None\n                    desc = m.group(4)\n                    arg_desc_lines = [desc] if desc else []\n                elif line.startswith(\" \" * 8) or line.strip() == \"\":\n                    # continuation line for description, allow empty lines inside description\n                    arg_desc_lines.append(line.strip())\n                else:\n                    # line that doesn't match pattern and not indented enough? treat as break\n                    if arg_name:\n                        args.append({\n                            \"name\": arg_name,\n                            \"type\": arg_type,\n                            \"description\": \" \".join(arg_desc_lines).strip()\n                        })\n                        arg_name = None\n                        arg_type = None\n                        arg_desc_lines = []\n            if arg_name:\n                args.append({\n                    \"name\": arg_name,\n                    \"type\": arg_type,\n                    \"description\": \" \".join(arg_desc_lines).strip()\n                })\n            return args\n        elif section_name == 'returns':\n            # Return section is usually just one block of text, possibly with type info before colon\n            # e.g. Returns:\n            #    int: description\n            return_content = None\n            ret_type = None\n            desc_lines = []\n            return_line_re = re.compile(r'^ {4}(\\w+(?:, \\w+)*)?:?\\s*(.*)')\n            if buf:\n                # Try parse first line for type and description\n                m = return_line_re.match(buf[0])\n                if m:\n                    first_type = m.group(1)\n                    first_desc = m.group(2)\n                    ret_type = first_type if first_type else None\n                    if first_desc:\n                        desc_lines.append(first_desc)\n                    if len(buf) > 1:\n                        for line in buf[1:]:\n                            desc_lines.append(line.strip())\n                else:\n                    desc_lines.extend(line.strip() for line in buf)\n            return_content = {\n                \"type\": ret_type,\n                \"description\": \"\\n\".join(desc_lines).strip()\n            }\n            return return_content\n        elif section_name == 'raises':\n            # Each line corresponds to an exception raised\n            exceptions = []\n            exc_line_re = re.compile(r'^ {4}([\\w\\.]+):\\s*(.*)$')\n            exc_name = None\n            exc_desc_lines = []\n            for line in buf:\n                m = exc_line_re.match(line)\n                if m:\n                    if exc_name:\n                        exceptions.append({\n                            \"type\": exc_name,\n                            \"description\": \" \".join(exc_desc_lines).strip()\n                        })\n                    exc_name = m.group(1)\n                    desc = m.group(2)\n                    exc_desc_lines = [desc] if desc else []\n                elif line.startswith(\" \" * 8) or line.strip() == \"\":\n                    exc_desc_lines.append(line.strip())\n                else:\n                    if exc_name:\n                        exceptions.append({\n                            \"type\": exc_name,\n                            \"description\": \" \".join(exc_desc_lines).strip()\n                        })\n                        exc_name = None\n                        exc_desc_lines = []\n            if exc_name:\n                exceptions.append({\n                    \"type\": exc_name,\n                    \"description\": \" \".join(exc_desc_lines).strip()\n                })\n            return exceptions\n        elif section_name == 'examples':\n            return \"\\n\".join(buf).strip()\n        else:\n            return \"\\n\".join(buf).strip()\n\n    # states for collecting descriptions before sections\n    pre_section_lines = []\n    long_desc_started = False\n    short_desc_found = False\n\n    for i, line in enumerate(lines):\n        stripped = line.strip()\n        if stripped in section_headers:\n            # flush previous buffered content related to section\n            if current_section is None:\n                if not short_desc_found:\n                    # pre-section lines until now are short description + long description\n                    if pre_section_lines:\n                        # first non-empty line is short desc\n                        for j, pline in enumerate(pre_section_lines):\n                            if pline.strip():\n                                doc.short_description = pline.strip()\n                                if j+1 < len(pre_section_lines):\n                                    doc.long_description = \"\\n\".join(pre_section_lines[j+1:]).strip()\n                                break\n                        else:\n                            # no non-empty lines\n                            doc.short_description = \"\"\n                            doc.long_description = \"\"\n                    else:\n                        doc.short_description = \"\"\n                        doc.long_description = \"\"\n                pre_section_lines = []\n            else:\n                # flush the previous section buffer\n                content_parsed = flush_buffer(current_section, buffer)\n                if current_section == 'args':\n                    doc.args.extend(content_parsed)\n                elif current_section == 'returns':\n                    doc.returns = content_parsed\n                elif current_section == 'raises':\n                    doc.raises.extend(content_parsed)\n                elif current_section == 'examples':\n                    doc.examples = content_parsed\n\n            # start new section\n            current_section = section_headers[stripped]\n            buffer = []\n        else:\n            if current_section is None:\n                pre_section_lines.append(line)\n            else:\n                buffer.append(line)\n\n    # flush any remaining buffered content\n    if current_section is None:\n        if not short_desc_found:\n            if pre_section_lines:\n                for j, pline in enumerate(pre_section_lines):\n                    if pline.strip():\n                        doc.short_description = pline.strip()\n                        if j+1 < len(pre_section_lines):\n                            doc.long_description = \"\\n\".join(pre_section_lines[j+1:]).strip()\n                        break\n                else:\n                    doc.short_description = \"\"\n                    doc.long_description = \"\"\n            else:\n                doc.short_description = \"\"\n                doc.long_description = \"\"\n    else:\n        content_parsed = flush_buffer(current_section, buffer)\n        if current_section == 'args':\n            doc.args.extend(content_parsed)\n        elif current_section == 'returns':\n            doc.returns = content_parsed\n        elif current_section == 'raises':\n            doc.raises.extend(content_parsed)\n        elif current_section == 'examples':\n            doc.examples = content_parsed\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # Simple Docstring container\n    class Docstring:\n        def __init__(self):\n            self.short_summary = \"\"\n            self.long_description = \"\"\n            self.params = []\n            self.returns = None\n            self.raises = []\n            self.examples = \"\"\n            self.other_sections = defaultdict(list)\n\n    doc = Docstring()\n\n    lines = text.strip().split(\"\\n\")\n    lines = [line.rstrip() for line in lines]\n    if not lines:\n        return doc\n\n    # State machine to parse docstring\n    current_section = None\n    buffer = []\n\n    def flush_buffer_to_section():\n        nonlocal buffer, current_section\n        content = \"\\n\".join(buffer).strip()\n        if current_section is None:\n            # Summary and long description come before any section header.\n            if not doc.short_summary:\n                doc.short_summary = content.split(\"\\n\")[0]\n                doc.long_description = \"\\n\".join(content.split(\"\\n\")[1:]).strip()\n            else:\n                if doc.long_description:\n                    doc.long_description += \"\\n\" + content\n                else:\n                    doc.long_description = content\n        elif current_section == \"Args\":\n            # Add params parsed in buffer lines below\n            for param_line in buffer:\n                m = re.match(r\"\\s*(\\w+)\\s*\\(([^)]+)\\):\\s*(.*)\", param_line)\n                if m:\n                    name = m.group(1)\n                    typ = m.group(2)\n                    desc = m.group(3)\n                    doc.params.append({\"name\": name, \"type\": typ, \"description\": desc})\n                else:\n                    # Possibly a continuation line of last param description\n                    if doc.params:\n                        doc.params[-1][\"description\"] += \"\\n\" + param_line.strip()\n        elif current_section == \"Returns\":\n            m = re.match(r\"\\s*([^:]+):\\s*(.*)\", buffer[0])\n            if m:\n                typ = m.group(1).strip()\n                desc = m.group(2).strip()\n                if len(buffer) > 1:\n                    desc += \"\\n\" + \"\\n\".join(line.strip() for line in buffer[1:])\n                doc.returns = {\"type\": typ, \"description\": desc}\n            else:\n                doc.returns = {\"type\": None, \"description\": \"\\n\".join(buffer).strip()}\n        elif current_section == \"Raises\":\n            for raise_line in buffer:\n                m = re.match(r\"\\s*(\\w+):\\s*(.*)\", raise_line)\n                if m:\n                    exc = m.group(1)\n                    desc = m.group(2)\n                    doc.raises.append({\"exception\": exc, \"description\": desc})\n                else:\n                    if doc.raises:\n                        doc.raises[-1][\"description\"] += \"\\n\" + raise_line.strip()\n        elif current_section == \"Examples\":\n            doc.examples += \"\\n\".join(buffer) + \"\\n\"\n        else:\n            doc.other_sections[current_section].extend(buffer)\n        buffer = []\n\n    section_headers = {\"Args\", \"Returns\", \"Raises\", \"Examples\"}\n\n    # Identify sections by header lines like \"Args:\", \"Returns:\", etc.\n    for line in lines:\n        header_match = re.match(r\"^(\\w+):\\s*$\", line)\n        if header_match and header_match.group(1) in section_headers:\n            # Flush previous buffer to the previous section first\n            flush_buffer_to_section()\n            current_section = header_match.group(1)\n        else:\n            buffer.append(line)\n\n    flush_buffer_to_section()\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n\n    class Docstring:\n        def __init__(self, summary=\"\", params=None, returns=None, raises=None, examples=None):\n            self.summary = summary\n            self.params = params if params is not None else []\n            self.returns = returns\n            self.raises = raises if raises is not None else []\n            self.examples = examples if examples is not None else []\n\n    lines = text.strip().splitlines()\n    summary_lines = []\n    params = []\n    returns = None\n    raises = []\n    examples = []\n\n    # States for parsing different sections\n    current_section = \"summary\"\n    param_pattern = re.compile(r'\\s*(\\w+)\\s*\\(([^)]+)\\):\\s*(.*)')\n    return_pattern = re.compile(r'\\s*([^:]+):\\s*(.*)')\n    raises_pattern = re.compile(r'\\s*([^:]+):\\s*(.*)')\n    # For indent detection\n    indent = None\n\n    # Helper to consume indented blocks for examples or multi-line descriptions\n    def gather_indented(start_idx):\n        block = []\n        base_indent = None\n        i = start_idx\n        while i < len(lines):\n            line = lines[i]\n            # Detect empty line or non-indented line: stop block\n            if not line.strip():\n                block.append('')\n                i += 1\n                continue\n            cur_indent = len(line) - len(line.lstrip())\n            if base_indent is None:\n                base_indent = cur_indent\n            if cur_indent < base_indent:\n                break\n            block.append(line[base_indent:])\n            i += 1\n        return block, i\n\n    i = 0\n    while i < len(lines):\n        line = lines[i].rstrip()\n        if not line:\n            # blank line means possible section change\n            if current_section == \"summary\" and summary_lines:\n                current_section = None\n            i += 1\n            continue\n\n        # Detect section headers\n        if line.lower() == \"args:\" or line.lower() == \"arguments:\" or line.lower() == \"parameters:\":\n            current_section = \"params\"\n            i += 1\n            continue\n        elif line.lower() == \"returns:\":\n            current_section = \"returns\"\n            i += 1\n            continue\n        elif line.lower() == \"raises:\" or line.lower() == \"exceptions:\":\n            current_section = \"raises\"\n            i += 1\n            continue\n        elif line.lower() == \"examples:\":\n            current_section = \"examples\"\n            i += 1\n            continue\n\n        # Parsing by section\n        if current_section == \"summary\" or current_section is None:\n            summary_lines.append(line)\n            i += 1\n        elif current_section == \"params\":\n            m = param_pattern.match(line)\n            if m:\n                name, typ, desc = m.groups()\n                # gather multi-line description\n                desc_lines = [desc.strip()]\n                j = i + 1\n                while j < len(lines):\n                    next_line = lines[j]\n                    if next_line.strip() == \"\":\n                        j += 1\n                        continue\n                    # look for indented lines\n                    indent_len = len(next_line) - len(next_line.lstrip())\n                    if indent_len <= 0:\n                        break\n                    desc_lines.append(next_line.strip())\n                    j += 1\n                full_desc = \" \".join(desc_lines)\n                params.append({'name': name, 'type': typ, 'desc': full_desc})\n                i = j\n            else:\n                i += 1\n        elif current_section == \"returns\":\n            # Format: type: description\n            m = return_pattern.match(line)\n            if m:\n                typ, desc = m.groups()\n                # gather multi-line description\n                desc_lines = [desc.strip()]\n                j = i + 1\n                while j < len(lines):\n                    next_line = lines[j]\n                    if next_line.strip() == \"\":\n                        j += 1\n                        continue\n                    indent_len = len(next_line) - len(next_line.lstrip())\n                    if indent_len <= 0:\n                        break\n                    desc_lines.append(next_line.strip())\n                    j += 1\n                full_desc = \" \".join(desc_lines)\n                returns = {'type': typ.strip(), 'desc': full_desc}\n                i = j\n            else:\n                i += 1\n        elif current_section == \"raises\":\n            # Format: ExceptionName: description\n            m = raises_pattern.match(line)\n            if m:\n                exc, desc = m.groups()\n                desc_lines = [desc.strip()]\n                j = i + 1\n                while j < len(lines):\n                    next_line = lines[j]\n                    if next_line.strip() == \"\":\n                        j += 1\n                        continue\n                    indent_len = len(next_line) - len(next_line.lstrip())\n                    if indent_len <= 0:\n                        break\n                    desc_lines.append(next_line.strip())\n                    j += 1\n                full_desc = \" \".join(desc_lines)\n                raises.append({'exception': exc.strip(), 'desc': full_desc})\n                i = j\n            else:\n                i += 1\n        elif current_section == \"examples\":\n            # gather until next section or end\n            block, j = gather_indented(i)\n            examples.append('\\n'.join(block))\n            i = j\n        else:\n            i += 1\n\n    summary = \"\\n\".join(summary_lines).strip()\n\n    return Docstring(summary=summary, params=params, returns=returns, raises=raises, examples=examples)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # A basic Docstring class to store sections; replace or adjust as needed\n    class Docstring:\n        def __init__(self):\n            self.short_description = \"\"\n            self.long_description = \"\"\n            self.params = []\n            self.returns = None\n            self.raises = []\n            self.examples = \"\"\n            self.other_sections = defaultdict(list)\n\n        def __repr__(self):\n            return (f\"Docstring(short_description={self.short_description!r}, \"\n                    f\"long_description={self.long_description!r}, params={self.params!r}, \"\n                    f\"returns={self.returns!r}, raises={self.raises!r}, \"\n                    f\"examples={self.examples!r}, other_sections={dict(self.other_sections)!r})\")\n\n    lines = text.expandtabs().splitlines()\n    doc = Docstring()\n\n    def strip_empty_ends(lst):\n        while lst and not lst[0].strip():\n            lst.pop(0)\n        while lst and not lst[-1].strip():\n            lst.pop()\n        return lst\n\n    # Identify sections by their headers, e.g. \"Args:\", \"Returns:\", \"Raises:\", \"Examples:\" etc.\n    section_headers = {'Args:', 'Arguments:', 'Parameters:', 'Returns:', 'Raise:', 'Raises:', 'Examples:', 'Example:'}\n    # Map section header to normalized section name\n    section_aliases = {\n        'Args:': 'params',\n        'Arguments:': 'params',\n        'Parameters:': 'params',\n        'Returns:': 'returns',\n        'Raise:': 'raises',\n        'Raises:': 'raises',\n        'Example:': 'examples',\n        'Examples:': 'examples'\n    }\n\n    # Parse line by line, detect sections\n    current_section = None\n    section_content = []\n    # These will accumulate the content of each section\n    sections = defaultdict(list)\n\n    i = 0\n    n = len(lines)\n\n    # Gather all sections content\n    while i < n:\n        line = lines[i].rstrip()\n        if line in section_headers:\n            # Save previous section content\n            if current_section:\n                sections[current_section].extend(strip_empty_ends(section_content))\n            current_section = section_aliases[line]\n            section_content = []\n            i += 1\n            # Skip empty lines after section header\n            while i < n and not lines[i].strip():\n                i += 1\n            continue\n        elif current_section:\n            section_content.append(lines[i])\n        else:\n            # Outside any section, accumulate as description\n            section_content.append(lines[i])\n        i += 1\n\n    # Save last section content if any\n    if current_section:\n        sections[current_section].extend(strip_empty_ends(section_content))\n    else:\n        # No sections at all, all is description\n        sections['description'] = strip_empty_ends(section_content)\n\n    # Extract short and long description from description section\n    desc_lines = sections.get('description', [])\n    # Short description is first non-blank line\n    # Long description is rest separated by a blank line\n    short_desc_lines = []\n    long_desc_lines = []\n    if desc_lines:\n        # Find first block (contiguous non-blank lines) as short description\n        i = 0\n        while i < len(desc_lines) and not desc_lines[i].strip():\n            i += 1\n        while i < len(desc_lines) and desc_lines[i].strip():\n            short_desc_lines.append(desc_lines[i].strip())\n            i += 1\n        # After a blank line, rest is long description\n        while i < len(desc_lines) and not desc_lines[i].strip():\n            i += 1\n        while i < len(desc_lines):\n            long_desc_lines.append(desc_lines[i])\n            i += 1\n\n    doc.short_description = \" \".join(short_desc_lines)\n    doc.long_description = \"\\n\".join(long_desc_lines).strip()\n\n    # Parse params section\n    params_lines = sections.get('params', [])\n    # Expected format: each param is indented line of form:\n    # name (type): description\n    # which could extend in indented following lines\n    param_regex = re.compile(r'^(\\s*)(\\w+)\\s*(\\(([^)]+)\\))?:\\s*(.*)$')\n    param_list = []\n    current_param = None\n\n    for line in params_lines:\n        m = param_regex.match(line)\n        if m:\n            # save prev param\n            if current_param:\n                param_list.append(current_param)\n            indent, name, _, type_, desc = m.groups()\n            current_param = {\n                'name': name,\n                'type': type_ or None,\n                'description': desc.strip()\n            }\n            current_indent = len(indent)\n        else:\n            # continuation line (indented more)\n            if current_param and line.strip():\n                cont_line = line.strip()\n                # append with a space\n                current_param['description'] += ' ' + cont_line\n\n    if current_param:\n        param_list.append(current_param)\n\n    doc.params = param_list\n\n    # Parse returns section\n    returns_lines = sections.get('returns', [])\n    if returns_lines:\n        # The first line may have type and description separated by colon or parenthesis\n        # Try to parse \"type: description\"\n        returns_text = \"\\n\".join(returns_lines).strip()\n        m = re.match(r'^(\\w+)\\s*:\\s*(.*)$', returns_text)\n        if m:\n            ret_type, ret_desc = m.groups()\n            doc.returns = {'type': ret_type, 'description': ret_desc.strip()}\n        else:\n            # fallback: single string as description, no type\n            doc.returns = {'type': None, 'description': returns_text}\n\n    # Parse raises section\n    raises_lines = sections.get('raises', [])\n    # Expect lines like \"ErrorType: description\"\n    raises_list = []\n    raise_regex = re.compile(r'^(\\s*)(\\w+)\\s*:\\s*(.*)$')\n    current_raise = None\n    for line in raises_lines:\n        m = raise_regex.match(line)\n        if m:\n            if current_raise:\n                raises_list.append(current_raise)\n            _, exc_type, desc = m.groups()\n            current_raise = {'type': exc_type, 'description': desc.strip()}\n        else:\n            if current_raise and line.strip():\n                current_raise['description'] += ' ' + line.strip()\n    if current_raise:\n        raises_list.append(current_raise)\n\n    doc.raises = raises_list\n\n    # Parse examples section\n    examples_lines = sections.get('examples', [])\n    doc.examples = \"\\n\".join(examples_lines).strip()\n\n    # Add any unknown sections\n    for sec, content in sections.items():\n        if sec not in {'description', 'params', 'returns', 'raises', 'examples'}:\n            doc.other_sections[sec].extend(content)\n\n    return doc\n\n\nimport pickle\ndef test_2():\n    assert isinstance(parse.__qualname__, str)\ntest_2()\n\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)\ntest_3()\n\ndef test_4():\n    assert isinstance(parse, T.Callable)\ntest_4()\n\ndef test_5():\n    assert isinstance(parse.__doc__, str)\ntest_5()\n\ndef test_13():\n    assert isinstance(parse.__name__, str)\ntest_13()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import namedtuple\n\n    Docstring = namedtuple('Docstring', ['short_description', 'long_description', 'params', 'returns', 'raises'])\n\n    # Normalize line endings and split lines\n    lines = text.replace('\\r\\n', '\\n').replace('\\r', '\\n').split('\\n')\n    lines = [line.rstrip() for line in lines]\n\n    short_description = ''\n    long_description_lines = []\n    params = []\n    returns = None\n    raises = []\n\n    mode = 'short_desc'  # modes: short_desc, long_desc, params, returns, raises, other\n\n    param_pattern = re.compile(r'^(\\w+)(?:\\s*\\(([^)]+)\\))?:\\s*(.*)$')\n    return_pattern = re.compile(r'^(.*)$')\n    raise_pattern = re.compile(r'^(\\w+):\\s*(.*)$')\n\n    i = 0\n    n = len(lines)\n\n    # Parse short description as first non-empty line\n    while i < n and lines[i].strip() == '':\n        i +=1\n    if i < n:\n        short_description = lines[i].strip()\n        i +=1\n\n    # Parse until blank line or section header as long description\n    while i < n:\n        line = lines[i]\n        stripped = line.strip()\n        if stripped == '':\n            i += 1\n            # Only stop if next line is a section header, otherwise continue long description\n            if i < n and re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', lines[i], re.I):\n                break\n            else:\n                long_description_lines.append('')\n            continue\n        if re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', stripped, re.I):\n            break\n        long_description_lines.append(line)\n        i += 1\n\n    long_description = '\\n'.join(long_description_lines).strip()\n\n    # Helper to consume indented block lines\n    def collect_indented_block(start_idx):\n        block_lines = []\n        base_indent = None\n        j = start_idx\n        while j < n:\n            l = lines[j]\n            if l.strip() == '':\n                block_lines.append('')\n                j += 1\n                continue\n            indent = len(l) - len(l.lstrip())\n            if base_indent is None:\n                base_indent = indent\n            if indent < base_indent:\n                break\n            block_lines.append(l[base_indent:])\n            j += 1\n        return block_lines, j\n\n    # Parse sections\n    while i < n:\n        line = lines[i].strip()\n        if line.lower() in ('args:', 'arguments:', 'parameters:'):\n            i +=1\n            # parse params\n            while i < n:\n                l = lines[i]\n                if l.strip() == '':\n                    i += 1\n                    continue\n                # Stop at next section or outdent\n                if re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', l.strip(), re.I):\n                    break\n                indent = len(l) - len(l.lstrip())\n                if indent == 0:  # no indent means new section or end\n                    break\n                # Parse param line\n                param_match = param_pattern.match(l.strip())\n                if param_match:\n                    name, type_, desc = param_match.groups()\n                    # Collect continuation lines indented further\n                    j = i + 1\n                    description_lines = [desc]\n                    while j < n:\n                        next_line = lines[j]\n                        next_indent = len(next_line) - len(next_line.lstrip())\n                        if next_line.strip() == '':\n                            description_lines.append('')\n                            j += 1\n                            continue\n                        if next_indent <= indent:\n                            break\n                        description_lines.append(next_line.strip())\n                        j += 1\n                    full_desc = ' '.join(description_lines).strip()\n                    params.append({'name': name, 'type': type_, 'description': full_desc})\n                    i = j\n                else:\n                    # maybe just description continuation or malformed line, ignore or break\n                    i += 1\n            continue\n\n        elif line.lower() == 'returns:':\n            i +=1\n            # parse returns; single description, possibly multi-line indented\n            desc_lines, new_i = collect_indented_block(i)\n            i = new_i\n            desc = '\\n'.join(desc_lines).strip()\n            returns = desc if desc else None\n            continue\n\n        elif line.lower() == 'raises:':\n            i +=1\n            # parse raises\n            while i < n:\n                l = lines[i]\n                if l.strip() == '':\n                    i += 1\n                    continue\n                if re.match(r'^(Args|Arguments|Parameters|Returns|Raises):\\s*$', l.strip(), re.I):\n                    break\n                indent = len(l) - len(l.lstrip())\n                if indent == 0:\n                    break\n                raise_match = raise_pattern.match(l.strip())\n                if raise_match:\n                    excname, desc = raise_match.groups()\n                    j = i + 1\n                    description_lines = [desc]\n                    while j < n:\n                        next_line = lines[j]\n                        next_indent = len(next_line) - len(next_line.lstrip())\n                        if next_line.strip() == '':\n                            description_lines.append('')\n                            j += 1\n                            continue\n                        if next_indent <= indent:\n                            break\n                        description_lines.append(next_line.strip())\n                        j += 1\n                    full_desc = ' '.join(description_lines).strip()\n                    raises.append({'type': excname, 'description': full_desc})\n                    i = j\n                else:\n                    i += 1\n            continue\n\n        else:\n            # Unknown or empty section, jump to next line\n            i += 1\n\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        params=params,\n        returns=returns,\n        raises=raises\n    )\n\n\nimport pickle\ndef test_2():\n    assert isinstance(parse.__qualname__, str)\ntest_2()\n\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)\ntest_3()\n\ndef test_4():\n    assert isinstance(parse, T.Callable)\ntest_4()\n\ndef test_5():\n    assert isinstance(parse.__doc__, str)\ntest_5()\n\ndef test_13():\n    assert isinstance(parse.__name__, str)\ntest_13()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_description = \"\"\n            self.long_description = \"\"\n            self.args = []\n            self.returns = None\n            self.raises = []\n            self.examples = \"\"\n\n        def __repr__(self):\n            return (\n                f\"Docstring(short_description={self.short_description!r}, \"\n                f\"long_description={self.long_description!r}, \"\n                f\"args={self.args!r}, returns={self.returns!r}, \"\n                f\"raises={self.raises!r}, examples={self.examples!r})\"\n            )\n\n    doc = Docstring()\n    lines = text.strip().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    # Split the docstring into sections by headings and blank lines\n    section_headers = {\n        \"Args:\": \"args\",\n        \"Arguments:\": \"args\",\n        \"Parameters:\": \"args\",\n        \"Returns:\": \"returns\",\n        \"Return:\": \"returns\",\n        \"Raises:\": \"raises\",\n        \"Examples:\": \"examples\"\n    }\n    \n    current_section = None\n    buffer = []\n    arg_buffer = []\n    is_in_args = False\n\n    # Helper to flush buffer\n    def flush_buffer(section_name, buf):\n        content = \"\\n\".join(buf).strip()\n        if section_name == 'args':\n            # Parse arguments from buf lines\n            args = []\n            arg_name = None\n            arg_type = None\n            arg_desc_lines = []\n\n            arg_line_re = re.compile(r'^ {4}(\\w+)(\\s*\\(([^)]+)\\))?:\\s*(.*)$')\n            # For example: \"    param_name (int): description\"\n\n            for line in buf:\n                m = arg_line_re.match(line)\n                if m:\n                    # if previous arg data exists, store it\n                    if arg_name:\n                        args.append({\n                            \"name\": arg_name,\n                            \"type\": arg_type,\n                            \"description\": \" \".join(arg_desc_lines).strip()\n                        })\n                    arg_name = m.group(1)\n                    arg_type = m.group(3) if m.group(3) else None\n                    desc = m.group(4)\n                    arg_desc_lines = [desc] if desc else []\n                elif line.startswith(\" \" * 8) or line.strip() == \"\":\n                    # continuation line for description, allow empty lines inside description\n                    arg_desc_lines.append(line.strip())\n                else:\n                    # line that doesn't match pattern and not indented enough? treat as break\n                    if arg_name:\n                        args.append({\n                            \"name\": arg_name,\n                            \"type\": arg_type,\n                            \"description\": \" \".join(arg_desc_lines).strip()\n                        })\n                        arg_name = None\n                        arg_type = None\n                        arg_desc_lines = []\n            if arg_name:\n                args.append({\n                    \"name\": arg_name,\n                    \"type\": arg_type,\n                    \"description\": \" \".join(arg_desc_lines).strip()\n                })\n            return args\n        elif section_name == 'returns':\n            # Return section is usually just one block of text, possibly with type info before colon\n            # e.g. Returns:\n            #    int: description\n            return_content = None\n            ret_type = None\n            desc_lines = []\n            return_line_re = re.compile(r'^ {4}(\\w+(?:, \\w+)*)?:?\\s*(.*)')\n            if buf:\n                # Try parse first line for type and description\n                m = return_line_re.match(buf[0])\n                if m:\n                    first_type = m.group(1)\n                    first_desc = m.group(2)\n                    ret_type = first_type if first_type else None\n                    if first_desc:\n                        desc_lines.append(first_desc)\n                    if len(buf) > 1:\n                        for line in buf[1:]:\n                            desc_lines.append(line.strip())\n                else:\n                    desc_lines.extend(line.strip() for line in buf)\n            return_content = {\n                \"type\": ret_type,\n                \"description\": \"\\n\".join(desc_lines).strip()\n            }\n            return return_content\n        elif section_name == 'raises':\n            # Each line corresponds to an exception raised\n            exceptions = []\n            exc_line_re = re.compile(r'^ {4}([\\w\\.]+):\\s*(.*)$')\n            exc_name = None\n            exc_desc_lines = []\n            for line in buf:\n                m = exc_line_re.match(line)\n                if m:\n                    if exc_name:\n                        exceptions.append({\n                            \"type\": exc_name,\n                            \"description\": \" \".join(exc_desc_lines).strip()\n                        })\n                    exc_name = m.group(1)\n                    desc = m.group(2)\n                    exc_desc_lines = [desc] if desc else []\n                elif line.startswith(\" \" * 8) or line.strip() == \"\":\n                    exc_desc_lines.append(line.strip())\n                else:\n                    if exc_name:\n                        exceptions.append({\n                            \"type\": exc_name,\n                            \"description\": \" \".join(exc_desc_lines).strip()\n                        })\n                        exc_name = None\n                        exc_desc_lines = []\n            if exc_name:\n                exceptions.append({\n                    \"type\": exc_name,\n                    \"description\": \" \".join(exc_desc_lines).strip()\n                })\n            return exceptions\n        elif section_name == 'examples':\n            return \"\\n\".join(buf).strip()\n        else:\n            return \"\\n\".join(buf).strip()\n\n    # states for collecting descriptions before sections\n    pre_section_lines = []\n    long_desc_started = False\n    short_desc_found = False\n\n    for i, line in enumerate(lines):\n        stripped = line.strip()\n        if stripped in section_headers:\n            # flush previous buffered content related to section\n            if current_section is None:\n                if not short_desc_found:\n                    # pre-section lines until now are short description + long description\n                    if pre_section_lines:\n                        # first non-empty line is short desc\n                        for j, pline in enumerate(pre_section_lines):\n                            if pline.strip():\n                                doc.short_description = pline.strip()\n                                if j+1 < len(pre_section_lines):\n                                    doc.long_description = \"\\n\".join(pre_section_lines[j+1:]).strip()\n                                break\n                        else:\n                            # no non-empty lines\n                            doc.short_description = \"\"\n                            doc.long_description = \"\"\n                    else:\n                        doc.short_description = \"\"\n                        doc.long_description = \"\"\n                pre_section_lines = []\n            else:\n                # flush the previous section buffer\n                content_parsed = flush_buffer(current_section, buffer)\n                if current_section == 'args':\n                    doc.args.extend(content_parsed)\n                elif current_section == 'returns':\n                    doc.returns = content_parsed\n                elif current_section == 'raises':\n                    doc.raises.extend(content_parsed)\n                elif current_section == 'examples':\n                    doc.examples = content_parsed\n\n            # start new section\n            current_section = section_headers[stripped]\n            buffer = []\n        else:\n            if current_section is None:\n                pre_section_lines.append(line)\n            else:\n                buffer.append(line)\n\n    # flush any remaining buffered content\n    if current_section is None:\n        if not short_desc_found:\n            if pre_section_lines:\n                for j, pline in enumerate(pre_section_lines):\n                    if pline.strip():\n                        doc.short_description = pline.strip()\n                        if j+1 < len(pre_section_lines):\n                            doc.long_description = \"\\n\".join(pre_section_lines[j+1:]).strip()\n                        break\n                else:\n                    doc.short_description = \"\"\n                    doc.long_description = \"\"\n            else:\n                doc.short_description = \"\"\n                doc.long_description = \"\"\n    else:\n        content_parsed = flush_buffer(current_section, buffer)\n        if current_section == 'args':\n            doc.args.extend(content_parsed)\n        elif current_section == 'returns':\n            doc.returns = content_parsed\n        elif current_section == 'raises':\n            doc.raises.extend(content_parsed)\n        elif current_section == 'examples':\n            doc.examples = content_parsed\n\n    return doc\n\n\nimport pickle\ndef test_2():\n    assert isinstance(parse.__qualname__, str)\ntest_2()\n\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)\ntest_3()\n\ndef test_4():\n    assert isinstance(parse, T.Callable)\ntest_4()\n\ndef test_5():\n    assert isinstance(parse.__doc__, str)\ntest_5()\n\ndef test_13():\n    assert isinstance(parse.__name__, str)\ntest_13()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # Simple Docstring container\n    class Docstring:\n        def __init__(self):\n            self.short_summary = \"\"\n            self.long_description = \"\"\n            self.params = []\n            self.returns = None\n            self.raises = []\n            self.examples = \"\"\n            self.other_sections = defaultdict(list)\n\n    doc = Docstring()\n\n    lines = text.strip().split(\"\\n\")\n    lines = [line.rstrip() for line in lines]\n    if not lines:\n        return doc\n\n    # State machine to parse docstring\n    current_section = None\n    buffer = []\n\n    def flush_buffer_to_section():\n        nonlocal buffer, current_section\n        content = \"\\n\".join(buffer).strip()\n        if current_section is None:\n            # Summary and long description come before any section header.\n            if not doc.short_summary:\n                doc.short_summary = content.split(\"\\n\")[0]\n                doc.long_description = \"\\n\".join(content.split(\"\\n\")[1:]).strip()\n            else:\n                if doc.long_description:\n                    doc.long_description += \"\\n\" + content\n                else:\n                    doc.long_description = content\n        elif current_section == \"Args\":\n            # Add params parsed in buffer lines below\n            for param_line in buffer:\n                m = re.match(r\"\\s*(\\w+)\\s*\\(([^)]+)\\):\\s*(.*)\", param_line)\n                if m:\n                    name = m.group(1)\n                    typ = m.group(2)\n                    desc = m.group(3)\n                    doc.params.append({\"name\": name, \"type\": typ, \"description\": desc})\n                else:\n                    # Possibly a continuation line of last param description\n                    if doc.params:\n                        doc.params[-1][\"description\"] += \"\\n\" + param_line.strip()\n        elif current_section == \"Returns\":\n            m = re.match(r\"\\s*([^:]+):\\s*(.*)\", buffer[0])\n            if m:\n                typ = m.group(1).strip()\n                desc = m.group(2).strip()\n                if len(buffer) > 1:\n                    desc += \"\\n\" + \"\\n\".join(line.strip() for line in buffer[1:])\n                doc.returns = {\"type\": typ, \"description\": desc}\n            else:\n                doc.returns = {\"type\": None, \"description\": \"\\n\".join(buffer).strip()}\n        elif current_section == \"Raises\":\n            for raise_line in buffer:\n                m = re.match(r\"\\s*(\\w+):\\s*(.*)\", raise_line)\n                if m:\n                    exc = m.group(1)\n                    desc = m.group(2)\n                    doc.raises.append({\"exception\": exc, \"description\": desc})\n                else:\n                    if doc.raises:\n                        doc.raises[-1][\"description\"] += \"\\n\" + raise_line.strip()\n        elif current_section == \"Examples\":\n            doc.examples += \"\\n\".join(buffer) + \"\\n\"\n        else:\n            doc.other_sections[current_section].extend(buffer)\n        buffer = []\n\n    section_headers = {\"Args\", \"Returns\", \"Raises\", \"Examples\"}\n\n    # Identify sections by header lines like \"Args:\", \"Returns:\", etc.\n    for line in lines:\n        header_match = re.match(r\"^(\\w+):\\s*$\", line)\n        if header_match and header_match.group(1) in section_headers:\n            # Flush previous buffer to the previous section first\n            flush_buffer_to_section()\n            current_section = header_match.group(1)\n        else:\n            buffer.append(line)\n\n    flush_buffer_to_section()\n    return doc\n\n\nimport pickle\ndef test_2():\n    assert isinstance(parse.__qualname__, str)\ntest_2()\n\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)\ntest_3()\n\ndef test_4():\n    assert isinstance(parse, T.Callable)\ntest_4()\n\ndef test_5():\n    assert isinstance(parse.__doc__, str)\ntest_5()\n\ndef test_13():\n    assert isinstance(parse.__name__, str)\ntest_13()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\nclass SectionType(IntEnum):\n    \"\"\"Types of sections.\"\"\"\n\n    SINGULAR = 0\n    \"\"\"For sections like examples.\"\"\"\n\n    MULTIPLE = 1\n    \"\"\"For sections like params.\"\"\"\n\n    SINGULAR_OR_MULTIPLE = 2\n    \"\"\"For sections like returns or yields.\"\"\"\n\n\nclass Section(namedtuple(\"SectionBase\", \"title key type\")):\n    \"\"\"A docstring section.\"\"\"\n\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n\n    class Docstring:\n        def __init__(self, summary=\"\", params=None, returns=None, raises=None, examples=None):\n            self.summary = summary\n            self.params = params if params is not None else []\n            self.returns = returns\n            self.raises = raises if raises is not None else []\n            self.examples = examples if examples is not None else []\n\n    lines = text.strip().splitlines()\n    summary_lines = []\n    params = []\n    returns = None\n    raises = []\n    examples = []\n\n    # States for parsing different sections\n    current_section = \"summary\"\n    param_pattern = re.compile(r'\\s*(\\w+)\\s*\\(([^)]+)\\):\\s*(.*)')\n    return_pattern = re.compile(r'\\s*([^:]+):\\s*(.*)')\n    raises_pattern = re.compile(r'\\s*([^:]+):\\s*(.*)')\n    # For indent detection\n    indent = None\n\n    # Helper to consume indented blocks for examples or multi-line descriptions\n    def gather_indented(start_idx):\n        block = []\n        base_indent = None\n        i = start_idx\n        while i < len(lines):\n            line = lines[i]\n            # Detect empty line or non-indented line: stop block\n            if not line.strip():\n                block.append('')\n                i += 1\n                continue\n            cur_indent = len(line) - len(line.lstrip())\n            if base_indent is None:\n                base_indent = cur_indent\n            if cur_indent < base_indent:\n                break\n            block.append(line[base_indent:])\n            i += 1\n        return block, i\n\n    i = 0\n    while i < len(lines):\n        line = lines[i].rstrip()\n        if not line:\n            # blank line means possible section change\n            if current_section == \"summary\" and summary_lines:\n                current_section = None\n            i += 1\n            continue\n\n        # Detect section headers\n        if line.lower() == \"args:\" or line.lower() == \"arguments:\" or line.lower() == \"parameters:\":\n            current_section = \"params\"\n            i += 1\n            continue\n        elif line.lower() == \"returns:\":\n            current_section = \"returns\"\n            i += 1\n            continue\n        elif line.lower() == \"raises:\" or line.lower() == \"exceptions:\":\n            current_section = \"raises\"\n            i += 1\n            continue\n        elif line.lower() == \"examples:\":\n            current_section = \"examples\"\n            i += 1\n            continue\n\n        # Parsing by section\n        if current_section == \"summary\" or current_section is None:\n            summary_lines.append(line)\n            i += 1\n        elif current_section == \"params\":\n            m = param_pattern.match(line)\n            if m:\n                name, typ, desc = m.groups()\n                # gather multi-line description\n                desc_lines = [desc.strip()]\n                j = i + 1\n                while j < len(lines):\n                    next_line = lines[j]\n                    if next_line.strip() == \"\":\n                        j += 1\n                        continue\n                    # look for indented lines\n                    indent_len = len(next_line) - len(next_line.lstrip())\n                    if indent_len <= 0:\n                        break\n                    desc_lines.append(next_line.strip())\n                    j += 1\n                full_desc = \" \".join(desc_lines)\n                params.append({'name': name, 'type': typ, 'desc': full_desc})\n                i = j\n            else:\n                i += 1\n        elif current_section == \"returns\":\n            # Format: type: description\n            m = return_pattern.match(line)\n            if m:\n                typ, desc = m.groups()\n                # gather multi-line description\n                desc_lines = [desc.strip()]\n                j = i + 1\n                while j < len(lines):\n                    next_line = lines[j]\n                    if next_line.strip() == \"\":\n                        j += 1\n                        continue\n                    indent_len = len(next_line) - len(next_line.lstrip())\n                    if indent_len <= 0:\n                        break\n                    desc_lines.append(next_line.strip())\n                    j += 1\n                full_desc = \" \".join(desc_lines)\n                returns = {'type': typ.strip(), 'desc': full_desc}\n                i = j\n            else:\n                i += 1\n        elif current_section == \"raises\":\n            # Format: ExceptionName: description\n            m = raises_pattern.match(line)\n            if m:\n                exc, desc = m.groups()\n                desc_lines = [desc.strip()]\n                j = i + 1\n                while j < len(lines):\n                    next_line = lines[j]\n                    if next_line.strip() == \"\":\n                        j += 1\n                        continue\n                    indent_len = len(next_line) - len(next_line.lstrip())\n                    if indent_len <= 0:\n                        break\n                    desc_lines.append(next_line.strip())\n                    j += 1\n                full_desc = \" \".join(desc_lines)\n                raises.append({'exception': exc.strip(), 'desc': full_desc})\n                i = j\n            else:\n                i += 1\n        elif current_section == \"examples\":\n            # gather until next section or end\n            block, j = gather_indented(i)\n            examples.append('\\n'.join(block))\n            i = j\n        else:\n            i += 1\n\n    summary = \"\\n\".join(summary_lines).strip()\n\n    return Docstring(summary=summary, params=params, returns=returns, raises=raises, examples=examples)\n\n\nimport pickle\ndef test_2():\n    assert isinstance(parse.__qualname__, str)\ntest_2()\n\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)\ntest_3()\n\ndef test_4():\n    assert isinstance(parse, T.Callable)\ntest_4()\n\ndef test_5():\n    assert isinstance(parse.__doc__, str)\ntest_5()\n\ndef test_13():\n    assert isinstance(parse.__name__, str)\ntest_13()\n\n\n"]}
{"task_id": 166, "project": "test-apps/docstring_parser", "module": "docstring_parser.rest", "predictions": ["def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_description = ''\n            self.long_description = ''\n            self.params = defaultdict(str)\n            self.returns = ''\n            self.raises = defaultdict(str)\n            self.other_fields = defaultdict(list)\n\n    doc = Docstring()\n\n    lines = text.strip().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    state = 'short_desc'\n    desc_lines = []\n    long_desc_lines = []\n    param_re = re.compile(r':param\\s+(\\w+):\\s*(.*)')\n    type_re = re.compile(r':type\\s+(\\w+):\\s*(.*)')\n    return_re = re.compile(r':returns?:\\s*(.*)')\n    rtype_re = re.compile(r':rtype:\\s*(.*)')\n    raise_re = re.compile(r':raises?\\s+(\\w+):\\s*(.*)')\n    field_re = re.compile(r':(\\w+):\\s*(.*)')\n\n    current_param = None\n    current_raise = None\n    current_field = None\n\n    for line in lines:\n        if not line.strip():\n            if state == 'short_desc':\n                state = 'long_desc'\n            elif state == 'long_desc':\n                # blank line inside long description\n                long_desc_lines.append('')\n            elif current_param:\n                current_param = None\n            elif current_raise:\n                current_raise = None\n            else:\n                current_field = None\n            continue\n\n        if state == 'short_desc':\n            desc_lines.append(line)\n            continue\n\n        if state == 'long_desc':\n            m_param = param_re.match(line)\n            m_type = type_re.match(line)\n            m_ret = return_re.match(line)\n            m_rtype = rtype_re.match(line)\n            m_raise = raise_re.match(line)\n            m_field = field_re.match(line)\n\n            if m_param:\n                current_param = m_param.group(1)\n                doc.params[current_param] += m_param.group(2)\n                current_raise = None\n                current_field = None\n                continue\n            elif m_type:\n                # Since :type: can be after :param: we just store it in other_fields\n                doc.other_fields[f'type_{m_type.group(1)}'].append(m_type.group(2))\n                continue\n            elif m_ret:\n                doc.returns = m_ret.group(1)\n                current_param = None\n                current_raise = None\n                current_field = None\n                continue\n            elif m_rtype:\n                doc.other_fields['rtype'].append(m_rtype.group(1))\n                continue\n            elif m_raise:\n                current_raise = m_raise.group(1)\n                doc.raises[current_raise] += m_raise.group(2)\n                current_param = None\n                current_field = None\n                continue\n            elif m_field:\n                # generic field\n                current_field = m_field.group(1)\n                doc.other_fields[current_field].append(m_field.group(2))\n                current_param = None\n                current_raise = None\n                continue\n\n            # If line is indented (continuation line)\n            if line.startswith(' '):\n                textline = line.lstrip()\n                if current_param:\n                    doc.params[current_param] += ' ' + textline\n                elif current_raise:\n                    doc.raises[current_raise] += ' ' + textline\n                elif current_field:\n                    doc.other_fields[current_field][-1] += ' ' + textline\n                else:\n                    long_desc_lines.append(line)\n            else:\n                long_desc_lines.append(line)\n\n    doc.short_description = ' '.join(desc_lines).strip()\n    doc.long_description = '\\n'.join(long_desc_lines).strip()\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    lines = text.splitlines()\n    description_lines = []\n    params = []\n    returns = None\n    current_param = None\n    param_desc_lines = []\n    return_desc_lines = []\n    state = \"description\"\n\n    param_re = re.compile(r\":param (\\w+):\\s*(.*)\")\n    return_re = re.compile(r\":returns?:\\s*(.*)\")\n\n    for line in lines:\n        line = line.rstrip()\n        if not line.strip():\n            if state == \"description\":\n                description_lines.append('')\n            elif state == \"param_desc\" and current_param:\n                param_desc_lines.append('')\n            elif state == \"return_desc\":\n                return_desc_lines.append('')\n            continue\n\n        param_match = param_re.match(line)\n        return_match = return_re.match(line)\n\n        if param_match:\n            if current_param:\n                params.append((current_param, \"\\n\".join(param_desc_lines).strip()))\n            current_param = param_match.group(1)\n            param_desc_lines = [param_match.group(2).strip()]\n            state = \"param_desc\"\n        elif return_match:\n            if current_param:\n                params.append((current_param, \"\\n\".join(param_desc_lines).strip()))\n                current_param = None\n                param_desc_lines = []\n            return_desc_lines = [return_match.group(1).strip()]\n            state = \"return_desc\"\n        else:\n            if state == \"description\":\n                description_lines.append(line)\n            elif state == \"param_desc\" and current_param:\n                param_desc_lines.append(line.strip())\n            elif state == \"return_desc\":\n                return_desc_lines.append(line.strip())\n            else:\n                description_lines.append(line)\n\n    if current_param:\n        params.append((current_param, \"\\n\".join(param_desc_lines).strip()))\n\n    description = \"\\n\".join(description_lines).strip()\n    return_desc = \"\\n\".join(return_desc_lines).strip() if return_desc_lines else None\n\n    # Assuming Docstring is a class with fields: description (str), params (dict), returns (str or None)\n    doc = Docstring(\n        description=description,\n        params={name: desc for name, desc in params},\n        returns=return_desc\n    )\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_description = ''\n            self.long_description = ''\n            self.params = defaultdict(str)\n            self.returns = ''\n            self.raises = defaultdict(str)\n            self.other_fields = defaultdict(list)\n\n    doc = Docstring()\n\n    lines = text.strip().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    # States: 'short_desc', 'long_desc', 'params', 'returns', 'raises', 'other'\n    state = 'short_desc'\n    long_desc_lines = []\n    current_field = None\n    current_name = None\n\n    param_re = re.compile(r'^:param\\s+(\\w+):\\s*(.*)')\n    type_re = re.compile(r'^:type\\s+(\\w+):\\s*(.*)')\n    return_re = re.compile(r'^:returns?:\\s*(.*)')\n    rtype_re = re.compile(r'^:rtype:\\s*(.*)')\n    raises_re = re.compile(r'^:raises?\\s+([\\w\\.]+):\\s*(.*)')\n    generic_field_re = re.compile(r'^:(\\w+):\\s*(.*)')\n\n    i = 0\n    n = len(lines)\n\n    # Collect the short description: first non-empty line(s) until first empty line\n    short_desc_lines = []\n    while i < n and lines[i].strip() == '':\n        i += 1\n    while i < n and lines[i].strip() != '':\n        short_desc_lines.append(lines[i])\n        i += 1\n    doc.short_description = ' '.join(short_desc_lines)\n\n    # Skip empty lines after short description\n    while i < n and lines[i].strip() == '':\n        i += 1\n\n    # Collect long description until first field started with \":\"\n    long_desc_lines = []\n    while i < n and not lines[i].lstrip().startswith(':'):\n        long_desc_lines.append(lines[i])\n        i += 1\n    doc.long_description = '\\n'.join(long_desc_lines).strip()\n\n    # Parse fields (:param, :returns:, :raises:, etc.)\n    current_field_name = None\n    current_field_content = []\n    current_field_arg = None\n\n    def flush_field():\n        if current_field_name is None:\n            return\n        content_str = ' '.join(s.strip() for s in current_field_content).strip()\n        if current_field_name == 'param' and current_field_arg:\n            doc.params[current_field_arg] = content_str\n        elif current_field_name == 'type' and current_field_arg:\n            # Types can be stored if needed, skipping here\n            pass\n        elif current_field_name == 'return':\n            doc.returns = content_str\n        elif current_field_name == 'raises' and current_field_arg:\n            doc.raises[current_field_arg] = content_str\n        else:\n            # other fields\n            doc.other_fields[current_field_name].append(content_str)\n\n    while i < n:\n        line = lines[i]\n        if line.lstrip().startswith(':'):\n            # flush previous field\n            flush_field()\n            current_field_content = []\n\n            # parse the new field name and possible arg\n            line_stripped = line.lstrip()\n            # Try known fields\n            m_param = param_re.match(line_stripped)\n            m_type = type_re.match(line_stripped)\n            m_return = return_re.match(line_stripped)\n            m_rtype = rtype_re.match(line_stripped)\n            m_raises = raises_re.match(line_stripped)\n            m_generic = generic_field_re.match(line_stripped)\n\n            if m_param:\n                current_field_name = 'param'\n                current_field_arg = m_param.group(1)\n                current_field_content.append(m_param.group(2))\n            elif m_type:\n                # type info ignored or could be saved elsewhere\n                # skip for now\n                current_field_name = 'type'\n                current_field_arg = m_type.group(1)\n                current_field_content.append(m_type.group(2))\n            elif m_return:\n                current_field_name = 'return'\n                current_field_arg = None\n                current_field_content.append(m_return.group(1))\n            elif m_rtype:\n                # rtype ignored currently\n                current_field_name = 'rtype'\n                current_field_arg = None\n                current_field_content.append(m_rtype.group(1))\n            elif m_raises:\n                current_field_name = 'raises'\n                current_field_arg = m_raises.group(1)\n                current_field_content.append(m_raises.group(2))\n            elif m_generic:\n                current_field_name = m_generic.group(1)\n                current_field_arg = None\n                current_field_content.append(m_generic.group(2))\n            else:\n                # Unknown field, just grab the whole line without colon\n                current_field_name = None\n                current_field_arg = None\n        else:\n            # continuation line, indent must be > 0 to consider as continuation?\n            if line.strip() == '':\n                # empty continuation line is just a space\n                current_field_content.append('')\n            else:\n                current_field_content.append(line.strip())\n        i += 1\n    flush_field()\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # A simple container for docstring parts\n    class Docstring:\n        def __init__(self):\n            self.short_description = ''\n            self.long_description = ''\n            self.params = {}\n            self.returns = ''\n            self.raises = {}\n            self.other = defaultdict(list)\n\n        def __repr__(self):\n            return (f\"Docstring(short_description={self.short_description!r}, \"\n                    f\"long_description={self.long_description!r}, params={self.params!r}, \"\n                    f\"returns={self.returns!r}, raises={self.raises!r}, other={dict(self.other)!r})\")\n\n    doc = Docstring()\n\n    # Normalize line endings and split lines\n    lines = text.strip().splitlines()\n\n    # State variables for parsing\n    in_long_description = False\n    cur_param = None\n    cur_raise = None\n    cur_field = None\n    field_buffer = []\n\n    def flush_field():\n        nonlocal cur_param, cur_raise, cur_field, field_buffer\n        content = '\\n'.join(field_buffer).strip()\n        if cur_field == 'param' and cur_param:\n            doc.params[cur_param] = content\n        elif cur_field == 'raises' and cur_raise:\n            doc.raises[cur_raise] = content\n        elif cur_field == 'returns':\n            doc.returns = content\n        elif cur_field:\n            doc.other[cur_field].append(content)\n        field_buffer = []\n        cur_param = None\n        cur_raise = None\n        cur_field = None\n\n    # Regex for matching fields like :param name: desc\n    param_re = re.compile(r'^:param\\s+(\\w+):\\s*(.*)')\n    type_re = re.compile(r'^:type\\s+(\\w+):\\s*(.*)')\n    return_re = re.compile(r'^:returns?:\\s*(.*)')\n    rtype_re = re.compile(r'^:rtype:\\s*(.*)')\n    raises_re = re.compile(r'^:raises?\\s+([\\w\\.]+):\\s*(.*)')\n    generic_field_re = re.compile(r'^:(\\w+)(?:\\s+([\\w\\.]+))?:\\s*(.*)')\n\n    # Separate description and fields\n    desc_lines = []\n    fields_started = False\n\n    for line in lines:\n        if line.strip() == '':\n            if not fields_started:\n                desc_lines.append('')\n            elif field_buffer:\n                field_buffer.append('')\n            continue\n        if line.lstrip().startswith(':'):\n            # We've hit a field line\n            fields_started = True\n            if cur_field is not None:\n                # flush previous field\n                flush_field()\n            # Check what field it is\n            m = param_re.match(line)\n            if m:\n                cur_field = 'param'\n                cur_param = m.group(1)\n                rest = m.group(2)\n                field_buffer.append(rest)\n                continue\n\n            m = raises_re.match(line)\n            if m:\n                cur_field = 'raises'\n                cur_raise = m.group(1)\n                rest = m.group(2)\n                field_buffer.append(rest)\n                continue\n\n            m = return_re.match(line)\n            if m:\n                cur_field = 'returns'\n                rest = m.group(1)\n                field_buffer.append(rest)\n                continue\n\n            # Other generic fields like :note:, :warning:, :example:, :rtype:, etc.\n            m = generic_field_re.match(line)\n            if m:\n                cur_field = m.group(1)\n                if m.group(2):\n                    cur_param = m.group(2)\n                    rest = m.group(3)\n                    val = f\"{cur_param}: {rest}\" if rest else cur_param\n                    field_buffer.append(val)\n                else:\n                    rest = m.group(3)\n                    field_buffer.append(rest)\n                continue\n\n            # Could not recognize field, treat as text\n            if not fields_started:\n                desc_lines.append(line)\n            else:\n                field_buffer.append(line)\n        else:\n            # Not a field line\n            if not fields_started:\n                desc_lines.append(line)\n            else:\n                # continuation of current field\n                field_buffer.append(line.lstrip())\n\n    if cur_field is not None:\n        flush_field()\n\n    # Split desc_lines into short and long description by first blank line\n    if desc_lines:\n        try:\n            blank_index = desc_lines.index('')\n            doc.short_description = '\\n'.join(desc_lines[:blank_index]).strip()\n            doc.long_description = '\\n'.join(desc_lines[blank_index+1:]).strip()\n        except ValueError:\n            doc.short_description = '\\n'.join(desc_lines).strip()\n            doc.long_description = ''\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    lines = text.strip().splitlines()\n    description_lines = []\n    params = []\n    returns = None\n    current_field = None\n    field_content = defaultdict(list)\n\n    param_re = re.compile(r\":param\\s+(\\w+):\\s*(.*)\")\n    type_re = re.compile(r\":type\\s+(\\w+):\\s*(.*)\")\n    returns_re = re.compile(r\":returns?:\\s*(.*)\")\n    rtype_re = re.compile(r\":rtype:\\s*(.*)\")\n\n    i = 0\n    while i < len(lines):\n        line = lines[i].strip()\n        if line.startswith(\":param\"):\n            m = param_re.match(line)\n            if m:\n                param_name, desc = m.groups()\n                field_content[f\"param_{param_name}\"].append(desc)\n                current_field = f\"param_{param_name}\"\n            else:\n                current_field = None\n        elif line.startswith(\":type\"):\n            m = type_re.match(line)\n            if m:\n                param_name, typ = m.groups()\n                field_content[f\"type_{param_name}\"] = typ\n            current_field = None\n        elif line.startswith(\":return\") or line.startswith(\":returns\"):\n            m = returns_re.match(line)\n            if m:\n                field_content[\"returns\"].append(m.group(1))\n                current_field = \"returns\"\n            else:\n                current_field = None\n        elif line.startswith(\":rtype\"):\n            m = rtype_re.match(line)\n            if m:\n                field_content[\"rtype\"] = m.group(1)\n            current_field = None\n        elif line.startswith(\":\"):\n            # Unknown field, skip\n            current_field = None\n        else:\n            if current_field and line:\n                field_content[current_field].append(line)\n            elif not current_field and line:\n                description_lines.append(line)\n        i += 1\n\n    # Build parameters list\n    params = []\n    param_names = set()\n    for key in field_content:\n        if key.startswith(\"param_\"):\n            param_names.add(key[6:])\n    for name in sorted(param_names):\n        desc = \" \".join([s.strip() for s in field_content[f\"param_{name}\"]])\n        typ = field_content.get(f\"type_{name}\")\n        param = Param(name=name, type=typ, description=desc)\n        params.append(param)\n\n    # Compose description\n    description = \"\\n\".join(description_lines)\n\n    # Compose returns field\n    returns_desc = \" \".join(field_content.get(\"returns\", [])) if \"returns\" in field_content else None\n    returns_type = field_content.get(\"rtype\")\n\n    returns = Returns(type=returns_type, description=returns_desc) if returns_desc or returns_type else None\n\n    return Docstring(description=description, params=params, returns=returns)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\ndef _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_description = ''\n            self.long_description = ''\n            self.params = defaultdict(str)\n            self.returns = ''\n            self.raises = defaultdict(str)\n            self.other_fields = defaultdict(list)\n\n    doc = Docstring()\n\n    lines = text.strip().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    state = 'short_desc'\n    desc_lines = []\n    long_desc_lines = []\n    param_re = re.compile(r':param\\s+(\\w+):\\s*(.*)')\n    type_re = re.compile(r':type\\s+(\\w+):\\s*(.*)')\n    return_re = re.compile(r':returns?:\\s*(.*)')\n    rtype_re = re.compile(r':rtype:\\s*(.*)')\n    raise_re = re.compile(r':raises?\\s+(\\w+):\\s*(.*)')\n    field_re = re.compile(r':(\\w+):\\s*(.*)')\n\n    current_param = None\n    current_raise = None\n    current_field = None\n\n    for line in lines:\n        if not line.strip():\n            if state == 'short_desc':\n                state = 'long_desc'\n            elif state == 'long_desc':\n                # blank line inside long description\n                long_desc_lines.append('')\n            elif current_param:\n                current_param = None\n            elif current_raise:\n                current_raise = None\n            else:\n                current_field = None\n            continue\n\n        if state == 'short_desc':\n            desc_lines.append(line)\n            continue\n\n        if state == 'long_desc':\n            m_param = param_re.match(line)\n            m_type = type_re.match(line)\n            m_ret = return_re.match(line)\n            m_rtype = rtype_re.match(line)\n            m_raise = raise_re.match(line)\n            m_field = field_re.match(line)\n\n            if m_param:\n                current_param = m_param.group(1)\n                doc.params[current_param] += m_param.group(2)\n                current_raise = None\n                current_field = None\n                continue\n            elif m_type:\n                # Since :type: can be after :param: we just store it in other_fields\n                doc.other_fields[f'type_{m_type.group(1)}'].append(m_type.group(2))\n                continue\n            elif m_ret:\n                doc.returns = m_ret.group(1)\n                current_param = None\n                current_raise = None\n                current_field = None\n                continue\n            elif m_rtype:\n                doc.other_fields['rtype'].append(m_rtype.group(1))\n                continue\n            elif m_raise:\n                current_raise = m_raise.group(1)\n                doc.raises[current_raise] += m_raise.group(2)\n                current_param = None\n                current_field = None\n                continue\n            elif m_field:\n                # generic field\n                current_field = m_field.group(1)\n                doc.other_fields[current_field].append(m_field.group(2))\n                current_param = None\n                current_raise = None\n                continue\n\n            # If line is indented (continuation line)\n            if line.startswith(' '):\n                textline = line.lstrip()\n                if current_param:\n                    doc.params[current_param] += ' ' + textline\n                elif current_raise:\n                    doc.raises[current_raise] += ' ' + textline\n                elif current_field:\n                    doc.other_fields[current_field][-1] += ' ' + textline\n                else:\n                    long_desc_lines.append(line)\n            else:\n                long_desc_lines.append(line)\n\n    doc.short_description = ' '.join(desc_lines).strip()\n    doc.long_description = '\\n'.join(long_desc_lines).strip()\n\n    return doc\n\n\nimport pickle\ndef test_21():\n    assert None is parse(\":deprecated:\").returns\ntest_21()\n\n\ndef test_extra_7():\n    assert parse(\"\").short_description is None\ntest_extra_7()\n\ndef test_extra_8():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_8()\n\ndef test_extra_9():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").long_description == \"This is a long description.\"\ntest_extra_9()\n\ndef test_extra_10():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_short_description == True\ntest_extra_10()\n\ndef test_extra_11():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_long_description == False\ntest_extra_11()\n\ndef test_extra_12():\n    assert parse(\":param arg: This is a parameter.\\nAdditional information about the parameter.\").meta[0].description == \"This is a parameter.\\nAdditional information about the parameter.\"\ntest_extra_12()\n\ndef test_extra_20():\n    assert isinstance(parse(\"\"), Docstring)\ntest_extra_20()\n\ndef test_extra_21():\n    assert parse(\"\").short_description == None\n    assert parse(\"\").long_description == None\n    assert parse(\"\").meta == []\ntest_extra_21()\n\ndef test_extra_22():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_22()\n\ndef test_extra_23():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).long_description == \"This is a long description.\"\ntest_extra_23()\n\ndef test_extra_24():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).blank_after_short_description == True\ntest_extra_24()\n\ndef test_extra_33():\n    try:\n        parse(\"Short description\\n\\n:invalid\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":invalid\".'\ntest_extra_33()\n\ndef test_extra_39():\n    try:\n        parse(\":param arg1 description\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":param arg1 description\".'\ntest_extra_39()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\ndef _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    lines = text.splitlines()\n    description_lines = []\n    params = []\n    returns = None\n    current_param = None\n    param_desc_lines = []\n    return_desc_lines = []\n    state = \"description\"\n\n    param_re = re.compile(r\":param (\\w+):\\s*(.*)\")\n    return_re = re.compile(r\":returns?:\\s*(.*)\")\n\n    for line in lines:\n        line = line.rstrip()\n        if not line.strip():\n            if state == \"description\":\n                description_lines.append('')\n            elif state == \"param_desc\" and current_param:\n                param_desc_lines.append('')\n            elif state == \"return_desc\":\n                return_desc_lines.append('')\n            continue\n\n        param_match = param_re.match(line)\n        return_match = return_re.match(line)\n\n        if param_match:\n            if current_param:\n                params.append((current_param, \"\\n\".join(param_desc_lines).strip()))\n            current_param = param_match.group(1)\n            param_desc_lines = [param_match.group(2).strip()]\n            state = \"param_desc\"\n        elif return_match:\n            if current_param:\n                params.append((current_param, \"\\n\".join(param_desc_lines).strip()))\n                current_param = None\n                param_desc_lines = []\n            return_desc_lines = [return_match.group(1).strip()]\n            state = \"return_desc\"\n        else:\n            if state == \"description\":\n                description_lines.append(line)\n            elif state == \"param_desc\" and current_param:\n                param_desc_lines.append(line.strip())\n            elif state == \"return_desc\":\n                return_desc_lines.append(line.strip())\n            else:\n                description_lines.append(line)\n\n    if current_param:\n        params.append((current_param, \"\\n\".join(param_desc_lines).strip()))\n\n    description = \"\\n\".join(description_lines).strip()\n    return_desc = \"\\n\".join(return_desc_lines).strip() if return_desc_lines else None\n\n    # Assuming Docstring is a class with fields: description (str), params (dict), returns (str or None)\n    doc = Docstring(\n        description=description,\n        params={name: desc for name, desc in params},\n        returns=return_desc\n    )\n    return doc\n\n\nimport pickle\ndef test_21():\n    assert None is parse(\":deprecated:\").returns\ntest_21()\n\n\ndef test_extra_7():\n    assert parse(\"\").short_description is None\ntest_extra_7()\n\ndef test_extra_8():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_8()\n\ndef test_extra_9():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").long_description == \"This is a long description.\"\ntest_extra_9()\n\ndef test_extra_10():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_short_description == True\ntest_extra_10()\n\ndef test_extra_11():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_long_description == False\ntest_extra_11()\n\ndef test_extra_12():\n    assert parse(\":param arg: This is a parameter.\\nAdditional information about the parameter.\").meta[0].description == \"This is a parameter.\\nAdditional information about the parameter.\"\ntest_extra_12()\n\ndef test_extra_20():\n    assert isinstance(parse(\"\"), Docstring)\ntest_extra_20()\n\ndef test_extra_21():\n    assert parse(\"\").short_description == None\n    assert parse(\"\").long_description == None\n    assert parse(\"\").meta == []\ntest_extra_21()\n\ndef test_extra_22():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_22()\n\ndef test_extra_23():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).long_description == \"This is a long description.\"\ntest_extra_23()\n\ndef test_extra_24():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).blank_after_short_description == True\ntest_extra_24()\n\ndef test_extra_33():\n    try:\n        parse(\"Short description\\n\\n:invalid\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":invalid\".'\ntest_extra_33()\n\ndef test_extra_39():\n    try:\n        parse(\":param arg1 description\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":param arg1 description\".'\ntest_extra_39()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\ndef _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_description = ''\n            self.long_description = ''\n            self.params = defaultdict(str)\n            self.returns = ''\n            self.raises = defaultdict(str)\n            self.other_fields = defaultdict(list)\n\n    doc = Docstring()\n\n    lines = text.strip().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    # States: 'short_desc', 'long_desc', 'params', 'returns', 'raises', 'other'\n    state = 'short_desc'\n    long_desc_lines = []\n    current_field = None\n    current_name = None\n\n    param_re = re.compile(r'^:param\\s+(\\w+):\\s*(.*)')\n    type_re = re.compile(r'^:type\\s+(\\w+):\\s*(.*)')\n    return_re = re.compile(r'^:returns?:\\s*(.*)')\n    rtype_re = re.compile(r'^:rtype:\\s*(.*)')\n    raises_re = re.compile(r'^:raises?\\s+([\\w\\.]+):\\s*(.*)')\n    generic_field_re = re.compile(r'^:(\\w+):\\s*(.*)')\n\n    i = 0\n    n = len(lines)\n\n    # Collect the short description: first non-empty line(s) until first empty line\n    short_desc_lines = []\n    while i < n and lines[i].strip() == '':\n        i += 1\n    while i < n and lines[i].strip() != '':\n        short_desc_lines.append(lines[i])\n        i += 1\n    doc.short_description = ' '.join(short_desc_lines)\n\n    # Skip empty lines after short description\n    while i < n and lines[i].strip() == '':\n        i += 1\n\n    # Collect long description until first field started with \":\"\n    long_desc_lines = []\n    while i < n and not lines[i].lstrip().startswith(':'):\n        long_desc_lines.append(lines[i])\n        i += 1\n    doc.long_description = '\\n'.join(long_desc_lines).strip()\n\n    # Parse fields (:param, :returns:, :raises:, etc.)\n    current_field_name = None\n    current_field_content = []\n    current_field_arg = None\n\n    def flush_field():\n        if current_field_name is None:\n            return\n        content_str = ' '.join(s.strip() for s in current_field_content).strip()\n        if current_field_name == 'param' and current_field_arg:\n            doc.params[current_field_arg] = content_str\n        elif current_field_name == 'type' and current_field_arg:\n            # Types can be stored if needed, skipping here\n            pass\n        elif current_field_name == 'return':\n            doc.returns = content_str\n        elif current_field_name == 'raises' and current_field_arg:\n            doc.raises[current_field_arg] = content_str\n        else:\n            # other fields\n            doc.other_fields[current_field_name].append(content_str)\n\n    while i < n:\n        line = lines[i]\n        if line.lstrip().startswith(':'):\n            # flush previous field\n            flush_field()\n            current_field_content = []\n\n            # parse the new field name and possible arg\n            line_stripped = line.lstrip()\n            # Try known fields\n            m_param = param_re.match(line_stripped)\n            m_type = type_re.match(line_stripped)\n            m_return = return_re.match(line_stripped)\n            m_rtype = rtype_re.match(line_stripped)\n            m_raises = raises_re.match(line_stripped)\n            m_generic = generic_field_re.match(line_stripped)\n\n            if m_param:\n                current_field_name = 'param'\n                current_field_arg = m_param.group(1)\n                current_field_content.append(m_param.group(2))\n            elif m_type:\n                # type info ignored or could be saved elsewhere\n                # skip for now\n                current_field_name = 'type'\n                current_field_arg = m_type.group(1)\n                current_field_content.append(m_type.group(2))\n            elif m_return:\n                current_field_name = 'return'\n                current_field_arg = None\n                current_field_content.append(m_return.group(1))\n            elif m_rtype:\n                # rtype ignored currently\n                current_field_name = 'rtype'\n                current_field_arg = None\n                current_field_content.append(m_rtype.group(1))\n            elif m_raises:\n                current_field_name = 'raises'\n                current_field_arg = m_raises.group(1)\n                current_field_content.append(m_raises.group(2))\n            elif m_generic:\n                current_field_name = m_generic.group(1)\n                current_field_arg = None\n                current_field_content.append(m_generic.group(2))\n            else:\n                # Unknown field, just grab the whole line without colon\n                current_field_name = None\n                current_field_arg = None\n        else:\n            # continuation line, indent must be > 0 to consider as continuation?\n            if line.strip() == '':\n                # empty continuation line is just a space\n                current_field_content.append('')\n            else:\n                current_field_content.append(line.strip())\n        i += 1\n    flush_field()\n\n    return doc\n\n\nimport pickle\ndef test_21():\n    assert None is parse(\":deprecated:\").returns\ntest_21()\n\n\ndef test_extra_7():\n    assert parse(\"\").short_description is None\ntest_extra_7()\n\ndef test_extra_8():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_8()\n\ndef test_extra_9():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").long_description == \"This is a long description.\"\ntest_extra_9()\n\ndef test_extra_10():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_short_description == True\ntest_extra_10()\n\ndef test_extra_11():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_long_description == False\ntest_extra_11()\n\ndef test_extra_12():\n    assert parse(\":param arg: This is a parameter.\\nAdditional information about the parameter.\").meta[0].description == \"This is a parameter.\\nAdditional information about the parameter.\"\ntest_extra_12()\n\ndef test_extra_20():\n    assert isinstance(parse(\"\"), Docstring)\ntest_extra_20()\n\ndef test_extra_21():\n    assert parse(\"\").short_description == None\n    assert parse(\"\").long_description == None\n    assert parse(\"\").meta == []\ntest_extra_21()\n\ndef test_extra_22():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_22()\n\ndef test_extra_23():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).long_description == \"This is a long description.\"\ntest_extra_23()\n\ndef test_extra_24():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).blank_after_short_description == True\ntest_extra_24()\n\ndef test_extra_33():\n    try:\n        parse(\"Short description\\n\\n:invalid\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":invalid\".'\ntest_extra_33()\n\ndef test_extra_39():\n    try:\n        parse(\":param arg1 description\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":param arg1 description\".'\ntest_extra_39()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\ndef _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # A simple container for docstring parts\n    class Docstring:\n        def __init__(self):\n            self.short_description = ''\n            self.long_description = ''\n            self.params = {}\n            self.returns = ''\n            self.raises = {}\n            self.other = defaultdict(list)\n\n        def __repr__(self):\n            return (f\"Docstring(short_description={self.short_description!r}, \"\n                    f\"long_description={self.long_description!r}, params={self.params!r}, \"\n                    f\"returns={self.returns!r}, raises={self.raises!r}, other={dict(self.other)!r})\")\n\n    doc = Docstring()\n\n    # Normalize line endings and split lines\n    lines = text.strip().splitlines()\n\n    # State variables for parsing\n    in_long_description = False\n    cur_param = None\n    cur_raise = None\n    cur_field = None\n    field_buffer = []\n\n    def flush_field():\n        nonlocal cur_param, cur_raise, cur_field, field_buffer\n        content = '\\n'.join(field_buffer).strip()\n        if cur_field == 'param' and cur_param:\n            doc.params[cur_param] = content\n        elif cur_field == 'raises' and cur_raise:\n            doc.raises[cur_raise] = content\n        elif cur_field == 'returns':\n            doc.returns = content\n        elif cur_field:\n            doc.other[cur_field].append(content)\n        field_buffer = []\n        cur_param = None\n        cur_raise = None\n        cur_field = None\n\n    # Regex for matching fields like :param name: desc\n    param_re = re.compile(r'^:param\\s+(\\w+):\\s*(.*)')\n    type_re = re.compile(r'^:type\\s+(\\w+):\\s*(.*)')\n    return_re = re.compile(r'^:returns?:\\s*(.*)')\n    rtype_re = re.compile(r'^:rtype:\\s*(.*)')\n    raises_re = re.compile(r'^:raises?\\s+([\\w\\.]+):\\s*(.*)')\n    generic_field_re = re.compile(r'^:(\\w+)(?:\\s+([\\w\\.]+))?:\\s*(.*)')\n\n    # Separate description and fields\n    desc_lines = []\n    fields_started = False\n\n    for line in lines:\n        if line.strip() == '':\n            if not fields_started:\n                desc_lines.append('')\n            elif field_buffer:\n                field_buffer.append('')\n            continue\n        if line.lstrip().startswith(':'):\n            # We've hit a field line\n            fields_started = True\n            if cur_field is not None:\n                # flush previous field\n                flush_field()\n            # Check what field it is\n            m = param_re.match(line)\n            if m:\n                cur_field = 'param'\n                cur_param = m.group(1)\n                rest = m.group(2)\n                field_buffer.append(rest)\n                continue\n\n            m = raises_re.match(line)\n            if m:\n                cur_field = 'raises'\n                cur_raise = m.group(1)\n                rest = m.group(2)\n                field_buffer.append(rest)\n                continue\n\n            m = return_re.match(line)\n            if m:\n                cur_field = 'returns'\n                rest = m.group(1)\n                field_buffer.append(rest)\n                continue\n\n            # Other generic fields like :note:, :warning:, :example:, :rtype:, etc.\n            m = generic_field_re.match(line)\n            if m:\n                cur_field = m.group(1)\n                if m.group(2):\n                    cur_param = m.group(2)\n                    rest = m.group(3)\n                    val = f\"{cur_param}: {rest}\" if rest else cur_param\n                    field_buffer.append(val)\n                else:\n                    rest = m.group(3)\n                    field_buffer.append(rest)\n                continue\n\n            # Could not recognize field, treat as text\n            if not fields_started:\n                desc_lines.append(line)\n            else:\n                field_buffer.append(line)\n        else:\n            # Not a field line\n            if not fields_started:\n                desc_lines.append(line)\n            else:\n                # continuation of current field\n                field_buffer.append(line.lstrip())\n\n    if cur_field is not None:\n        flush_field()\n\n    # Split desc_lines into short and long description by first blank line\n    if desc_lines:\n        try:\n            blank_index = desc_lines.index('')\n            doc.short_description = '\\n'.join(desc_lines[:blank_index]).strip()\n            doc.long_description = '\\n'.join(desc_lines[blank_index+1:]).strip()\n        except ValueError:\n            doc.short_description = '\\n'.join(desc_lines).strip()\n            doc.long_description = ''\n\n    return doc\n\n\nimport pickle\ndef test_21():\n    assert None is parse(\":deprecated:\").returns\ntest_21()\n\n\ndef test_extra_7():\n    assert parse(\"\").short_description is None\ntest_extra_7()\n\ndef test_extra_8():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_8()\n\ndef test_extra_9():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").long_description == \"This is a long description.\"\ntest_extra_9()\n\ndef test_extra_10():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_short_description == True\ntest_extra_10()\n\ndef test_extra_11():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_long_description == False\ntest_extra_11()\n\ndef test_extra_12():\n    assert parse(\":param arg: This is a parameter.\\nAdditional information about the parameter.\").meta[0].description == \"This is a parameter.\\nAdditional information about the parameter.\"\ntest_extra_12()\n\ndef test_extra_20():\n    assert isinstance(parse(\"\"), Docstring)\ntest_extra_20()\n\ndef test_extra_21():\n    assert parse(\"\").short_description == None\n    assert parse(\"\").long_description == None\n    assert parse(\"\").meta == []\ntest_extra_21()\n\ndef test_extra_22():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_22()\n\ndef test_extra_23():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).long_description == \"This is a long description.\"\ntest_extra_23()\n\ndef test_extra_24():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).blank_after_short_description == True\ntest_extra_24()\n\ndef test_extra_33():\n    try:\n        parse(\"Short description\\n\\n:invalid\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":invalid\".'\ntest_extra_33()\n\ndef test_extra_39():\n    try:\n        parse(\":param arg1 description\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":param arg1 description\".'\ntest_extra_39()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport inspect\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\ndef _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    lines = text.strip().splitlines()\n    description_lines = []\n    params = []\n    returns = None\n    current_field = None\n    field_content = defaultdict(list)\n\n    param_re = re.compile(r\":param\\s+(\\w+):\\s*(.*)\")\n    type_re = re.compile(r\":type\\s+(\\w+):\\s*(.*)\")\n    returns_re = re.compile(r\":returns?:\\s*(.*)\")\n    rtype_re = re.compile(r\":rtype:\\s*(.*)\")\n\n    i = 0\n    while i < len(lines):\n        line = lines[i].strip()\n        if line.startswith(\":param\"):\n            m = param_re.match(line)\n            if m:\n                param_name, desc = m.groups()\n                field_content[f\"param_{param_name}\"].append(desc)\n                current_field = f\"param_{param_name}\"\n            else:\n                current_field = None\n        elif line.startswith(\":type\"):\n            m = type_re.match(line)\n            if m:\n                param_name, typ = m.groups()\n                field_content[f\"type_{param_name}\"] = typ\n            current_field = None\n        elif line.startswith(\":return\") or line.startswith(\":returns\"):\n            m = returns_re.match(line)\n            if m:\n                field_content[\"returns\"].append(m.group(1))\n                current_field = \"returns\"\n            else:\n                current_field = None\n        elif line.startswith(\":rtype\"):\n            m = rtype_re.match(line)\n            if m:\n                field_content[\"rtype\"] = m.group(1)\n            current_field = None\n        elif line.startswith(\":\"):\n            # Unknown field, skip\n            current_field = None\n        else:\n            if current_field and line:\n                field_content[current_field].append(line)\n            elif not current_field and line:\n                description_lines.append(line)\n        i += 1\n\n    # Build parameters list\n    params = []\n    param_names = set()\n    for key in field_content:\n        if key.startswith(\"param_\"):\n            param_names.add(key[6:])\n    for name in sorted(param_names):\n        desc = \" \".join([s.strip() for s in field_content[f\"param_{name}\"]])\n        typ = field_content.get(f\"type_{name}\")\n        param = Param(name=name, type=typ, description=desc)\n        params.append(param)\n\n    # Compose description\n    description = \"\\n\".join(description_lines)\n\n    # Compose returns field\n    returns_desc = \" \".join(field_content.get(\"returns\", [])) if \"returns\" in field_content else None\n    returns_type = field_content.get(\"rtype\")\n\n    returns = Returns(type=returns_type, description=returns_desc) if returns_desc or returns_type else None\n\n    return Docstring(description=description, params=params, returns=returns)\n\n\nimport pickle\ndef test_21():\n    assert None is parse(\":deprecated:\").returns\ntest_21()\n\n\ndef test_extra_7():\n    assert parse(\"\").short_description is None\ntest_extra_7()\n\ndef test_extra_8():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_8()\n\ndef test_extra_9():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").long_description == \"This is a long description.\"\ntest_extra_9()\n\ndef test_extra_10():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_short_description == True\ntest_extra_10()\n\ndef test_extra_11():\n    assert parse(\"Short description.\\n\\nThis is a long description.\").blank_after_long_description == False\ntest_extra_11()\n\ndef test_extra_12():\n    assert parse(\":param arg: This is a parameter.\\nAdditional information about the parameter.\").meta[0].description == \"This is a parameter.\\nAdditional information about the parameter.\"\ntest_extra_12()\n\ndef test_extra_20():\n    assert isinstance(parse(\"\"), Docstring)\ntest_extra_20()\n\ndef test_extra_21():\n    assert parse(\"\").short_description == None\n    assert parse(\"\").long_description == None\n    assert parse(\"\").meta == []\ntest_extra_21()\n\ndef test_extra_22():\n    assert parse(\"This is a short description.\").short_description == \"This is a short description.\"\ntest_extra_22()\n\ndef test_extra_23():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).long_description == \"This is a long description.\"\ntest_extra_23()\n\ndef test_extra_24():\n    text = \"This is a short description.\\n\\nThis is a long description.\"\n    assert parse(text).blank_after_short_description == True\ntest_extra_24()\n\ndef test_extra_33():\n    try:\n        parse(\"Short description\\n\\n:invalid\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":invalid\".'\ntest_extra_33()\n\ndef test_extra_39():\n    try:\n        parse(\":param arg1 description\")\n    except ParseError as e:\n        assert str(e) == 'Error parsing meta information near \":param arg1 description\".'\ntest_extra_39()"]}
{"task_id": 167, "project": "test-apps/docstring_parser", "module": "docstring_parser.numpydoc", "predictions": ["def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import namedtuple\n\n    Docstring = namedtuple('Docstring', ['short_summary', 'long_description', 'parameters', 'returns', 'raises', 'examples'])\n\n    # Helper functions\n    def clean_lines(lines):\n        return [line.rstrip() for line in lines]\n\n    def parse_parameters(lines):\n        params = []\n        param_name = None\n        param_type = None\n        description_lines = []\n        param_pattern = re.compile(r'^\\s*([\\w,*\\[\\]]+)\\s*:\\s*([\\w ,\\[\\].]+)?$')\n\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if not line.strip():\n                i += 1\n                continue\n\n            match = param_pattern.match(line)\n            if match:\n                if param_name:\n                    # previous parameter\n                    params.append({'name': param_name, 'type': param_type, 'desc': ' '.join(description_lines).strip()})\n                param_name = match.group(1).strip()\n                param_type = match.group(2).strip() if match.group(2) else None\n                description_lines = []\n                i += 1\n                # following indented lines belong to description\n                while i < len(lines) and (lines[i].startswith('    ') or lines[i].strip() == ''):\n                    description_lines.append(lines[i].strip())\n                    i += 1\n            else:\n                # continuation line but no recognized param header -> skip or attach to desc?\n                if param_name:\n                    description_lines.append(line.strip())\n                i += 1\n\n        if param_name:\n            params.append({'name': param_name, 'type': param_type, 'desc': ' '.join(description_lines).strip()})\n\n        return params\n\n    def parse_section(lines):\n        # For a section like Returns or Raises, parse similarly, where lines after header are description.\n        description_lines = []\n        i = 0\n        while i < len(lines):\n            description_lines.append(lines[i].strip())\n            i += 1\n        return ' '.join(description_lines).strip()\n\n    # Split docstring into lines\n    lines = text.splitlines()\n\n    # Strip leading/trailing empty lines\n    while lines and not lines[0].strip():\n        lines.pop(0)\n    while lines and not lines[-1].strip():\n        lines.pop()\n\n    # Identify short summary - first non-empty line\n    short_summary = ''\n    long_description_lines = []\n    parameters_lines = []\n    returns_lines = []\n    raises_lines = []\n    examples_lines = []\n\n    # We iterate to separate sections\n    current_section = 'short_summary_or_desc'\n\n    # The numpy style defines section headers like:\n    # Parameters\n    # ----------\n    # Returns\n    # -------\n    # Raises\n    # ------\n    # Examples\n    # --------\n    section_headers = {\n        'parameters': re.compile(r'^\\s*Parameters\\s*$'),\n        'returns': re.compile(r'^\\s*Returns\\s*$'),\n        'raises': re.compile(r'^\\s*Raises\\s*$'),\n        'examples': re.compile(r'^\\s*Examples\\s*$'),\n        'short_divider': re.compile(r'^\\s*-{3,}\\s*$')\n    }\n\n    i = 0\n    # First line short summary\n    while i < len(lines) and not lines[i].strip():\n        i += 1\n    if i < len(lines):\n        short_summary = lines[i].strip()\n        i += 1\n    else:\n        return Docstring(short_summary='', long_description='', parameters=[], returns=None, raises=None, examples=None)\n\n    # Next we check if next line is empty (common) or divider, then long description until next section\n    # We'll parse until we see a section header or end\n    # We expect a blank line after short summary generally\n\n    # First skip blank lines\n    while i < len(lines) and not lines[i].strip():\n        i += 1\n\n    # If next line is a section header, there is no long description\n    # Otherwise read until section header or end\n    def is_section_header(line):\n        for k, pattern in section_headers.items():\n            if pattern.match(line):\n                return True\n        return False\n\n    # Long description\n    long_description_lines = []\n    while i < len(lines) and not is_section_header(lines[i]):\n        long_description_lines.append(lines[i])\n        i += 1\n\n    # The above might have trailing blank lines, strip them\n    while long_description_lines and not long_description_lines[-1].strip():\n        long_description_lines.pop()\n\n    # Now parse sections\n    sections = {'parameters': None, 'returns': None, 'raises': None, 'examples': None}\n\n    while i < len(lines):\n        # Expect section header first\n        header_found = None\n        for key, pattern in section_headers.items():\n            if pattern.match(lines[i]):\n                header_found = key\n                break\n        if header_found is None:\n            i += 1\n            continue\n\n        i += 1\n        # After header line, expect a line with dashes\n        if i < len(lines) and section_headers['short_divider'].match(lines[i]):\n            i += 1\n        else:\n            # Malformed numpy docstring, just continue parsing\n            pass\n\n        # Collect section body lines until next section header or end\n        section_body_lines = []\n        while i < len(lines) and not is_section_header(lines[i]):\n            section_body_lines.append(lines[i])\n            i += 1\n\n        if header_found == 'parameters':\n            sections['parameters'] = clean_lines(section_body_lines)\n        elif header_found == 'returns':\n            sections['returns'] = clean_lines(section_body_lines)\n        elif header_found == 'raises':\n            sections['raises'] = clean_lines(section_body_lines)\n        elif header_found == 'examples':\n            sections['examples'] = clean_lines(section_body_lines)\n\n    params = parse_parameters(sections['parameters']) if sections['parameters'] else []\n    returns = parse_section(sections['returns']) if sections['returns'] else None\n    raises = parse_section(sections['raises']) if sections['raises'] else None\n    examples = '\\n'.join(sections['examples']).strip() if sections['examples'] else None\n\n    long_description = '\\n'.join(long_description_lines).strip()\n\n    return Docstring(\n        short_summary=short_summary,\n        long_description=long_description,\n        parameters=params,\n        returns=returns,\n        raises=raises,\n        examples=examples\n    )", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_summary = \"\"\n            self.long_description = \"\"\n            self.parameters = []\n            self.returns = []\n            self.raises = []\n            self.examples = \"\"\n            self.other_sections = defaultdict(list)\n\n        def __repr__(self):\n            return (f\"Docstring(short_summary={self.short_summary!r}, \"\n                    f\"long_description={self.long_description!r}, \"\n                    f\"parameters={self.parameters}, returns={self.returns}, \"\n                    f\"raises={self.raises}, examples={self.examples!r}, \"\n                    f\"other_sections={dict(self.other_sections)})\")\n\n    lines = text.expandtabs().splitlines()\n    doc = Docstring()\n\n    # Remove any leading/trailing empty lines\n    while lines and not lines[0].strip():\n        lines.pop(0)\n    while lines and not lines[-1].strip():\n        lines.pop()\n\n    if not lines:\n        return doc\n\n    # Extract short summary (first non-empty line)\n    i = 0\n    while i < len(lines) and not lines[i].strip():\n        i += 1\n    if i < len(lines):\n        doc.short_summary = lines[i].strip()\n        i += 1\n\n    # Extract long description until first section or empty line after summary\n    long_desc_lines = []\n    while i < len(lines):\n        line = lines[i]\n        if not line.strip():\n            # blank line, maybe end of long description\n            # but check if next lines are section header or blank as well\n            j = i + 1\n            while j < len(lines) and not lines[j].strip():\n                j += 1\n            if j < len(lines) and re.match(r'^[A-Za-z ]+\\n?$', lines[j]):\n                break\n            long_desc_lines.append(line)\n            i += 1\n            continue\n        # Check for section header line: must be followed by dashes of at least same length.\n        if (i + 1) < len(lines):\n            next_line = lines[i + 1]\n            if re.match(r'^-+\\s*$', next_line) and len(next_line.strip()) >= len(line.strip()):\n                break\n        long_desc_lines.append(line)\n        i += 1\n\n    doc.long_description = \"\\n\".join(long_desc_lines).strip()\n\n    # Function for parsing fields like Parameters, Returns etc.\n    def parse_fields(start_idx):\n        fields = []\n        idx = start_idx\n        while idx < len(lines):\n            if not lines[idx].strip():\n                idx += 1\n                continue\n            # Check if new section header found\n            if (idx + 1) < len(lines):\n                if re.match(r'^-+\\s*$', lines[idx + 1]) and len(lines[idx + 1].strip()) >= len(lines[idx].strip()):\n                    break\n            # Parse parameter or return block\n            # Format: name : type\n            #          description lines indented\n            header_match = re.match(r'^(\\S[^:]*)\\s*:\\s*(.*)$', lines[idx])\n            if not header_match:\n                # malformed or end of section\n                break\n            name, type_ = header_match.groups()\n            desc_lines = []\n            idx += 1\n            while idx < len(lines):\n                if not lines[idx].strip():\n                    desc_lines.append('')\n                    idx += 1\n                    continue\n                if re.match(r'^\\S', lines[idx]):\n                    # Start of new param or section or something else\n                    break\n                # Description line is indented (at least one space or tab)\n                desc_lines.append(lines[idx].strip())\n                idx += 1\n            desc = \"\\n\".join(desc_lines).strip()\n            fields.append({\"name\": name.strip(), \"type\": type_.strip(), \"description\": desc})\n        return fields, idx\n\n    # Map section name to attribute and parse method\n    section_map = {\n        \"Parameters\": \"parameters\",\n        \"Returns\": \"returns\",\n        \"Yields\": \"returns\",\n        \"Raises\": \"raises\",\n        \"Examples\": \"examples\"\n    }\n\n    while i < len(lines):\n        line = lines[i].strip()\n        if not line:\n            i += 1\n            continue\n        # Check if it's a section header\n        if (i+1) < len(lines) and re.match(r'^-+\\s*$', lines[i+1]) and len(lines[i+1].strip()) >= len(line):\n            section = line\n            i += 2\n            if section in (\"Examples\"):\n                # collect everything until next section or end\n                example_lines = []\n                while i < len(lines):\n                    # check if next lines form a section header\n                    if (i + 1) < len(lines):\n                        if re.match(r'^-+\\s*$', lines[i+1]) and len(lines[i+1].strip()) >= len(lines[i].strip()):\n                            break\n                    example_lines.append(lines[i])\n                    i += 1\n                doc.examples = \"\\n\".join(example_lines).rstrip()\n            elif section in (\"Parameters\", \"Returns\", \"Yields\", \"Raises\"):\n                fields, i = parse_fields(i)\n                if section in (\"Returns\", \"Yields\"):\n                    doc.returns.extend(fields)\n                elif section == \"Parameters\":\n                    doc.parameters.extend(fields)\n                elif section == \"Raises\":\n                    doc.raises.extend(fields)\n            else:\n                # Other sections, collect text lines until next section\n                other_lines = []\n                while i < len(lines):\n                    if (i + 1) < len(lines):\n                        if re.match(r'^-+\\s*$', lines[i+1]) and len(lines[i+1].strip()) >= len(lines[i].strip()):\n                            break\n                    other_lines.append(lines[i])\n                    i += 1\n                doc.other_sections[section] = \"\\n\".join(other_lines).rstrip()\n        else:\n            i += 1\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import namedtuple\n\n    Docstring = namedtuple('Docstring', ['short_summary', 'long_description', 'parameters', 'returns', 'raises', 'examples'])\n\n    def _split_sections(text):\n        sections = re.split(r'\\n(?=(Parameters|Returns|Raises|Examples)\\n-+\\n)', text)\n        preamble = sections[0]\n        content = sections[1:]\n        parsed = {}\n        for i in range(0, len(content), 2):\n            section_name = content[i].strip()\n            section_body = content[i + 1]\n            parsed[section_name] = section_body\n        return preamble, parsed\n\n    def _parse_parameters(text):\n        params = []\n        param_re = re.compile(r'^(\\w+)\\s*:\\s*([\\w,\\s\\[\\]]+)\\n\\s*(.+(?:\\n\\s{4,}.+)*)', re.MULTILINE)\n        for match in param_re.finditer(text):\n            name = match.group(1)\n            ptype = match.group(2).strip()\n            desc = re.sub(r'\\n\\s{4,}', ' ', match.group(3).strip())\n            params.append({'name': name, 'type': ptype, 'description': desc})\n        return params\n\n    def _parse_returns(text):\n        returns = []\n        ret_re = re.compile(r'^(\\w+)?\\s*:\\s*([\\w,\\s\\[\\]]+)\\n\\s*(.+(?:\\n\\s{4,}.+)*)', re.MULTILINE)\n        for match in ret_re.finditer(text):\n            name = match.group(1)\n            ptype = match.group(2).strip()\n            desc = re.sub(r'\\n\\s{4,}', ' ', match.group(3).strip())\n            returns.append({'name': name, 'type': ptype, 'description': desc})\n        if not returns and text.strip():\n            # fallback: untyped returns description\n            returns.append({'name': None, 'type': None, 'description': ' '.join(line.strip() for line in text.splitlines())})\n        return returns\n\n    def _parse_raises(text):\n        raises = []\n        raise_re = re.compile(r'^(\\w+)\\n\\s*(.+(?:\\n\\s{4,}.+)*)', re.MULTILINE)\n        for match in raise_re.finditer(text):\n            exc = match.group(1)\n            desc = re.sub(r'\\n\\s{4,}', ' ', match.group(2).strip())\n            raises.append({'exception': exc, 'description': desc})\n        return raises\n\n    def _parse_examples(text):\n        return text.strip()\n\n    # Normalize line endings\n    text = text.replace('\\r\\n', '\\n').strip()\n\n    # Split into short summary, long description, and sections\n    # Short summary is first line\n    lines = text.split('\\n')\n    short_summary = lines[0].strip()\n    rest = '\\n'.join(lines[1:]).strip()\n\n    # Try to find section titles with underlines of '-'\n    split_result = re.split(r'\\n(?=\\w+\\n-+\\n)', rest)\n    # If no sections\n    if len(split_result) == 1:\n        long_description = rest\n        parameters = []\n        returns = []\n        raises = []\n        examples = ''\n    else:\n        # first part before sections is long description\n        long_description = split_result[0].strip()\n        sections_text = '\\n'.join(split_result[1:])\n\n        preamble, sections = _split_sections(sections_text)\n\n        parameters = _parse_parameters(sections.get('Parameters', '')) if 'Parameters' in sections else []\n        returns = _parse_returns(sections.get('Returns', '')) if 'Returns' in sections else []\n        raises = _parse_raises(sections.get('Raises', '')) if 'Raises' in sections else []\n        examples = _parse_examples(sections.get('Examples', '')) if 'Examples' in sections else ''\n\n    return Docstring(short_summary, long_description, parameters, returns, raises, examples)", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_summary = ''\n            self.long_description = ''\n            self.params = []\n            self.returns = ''\n            self.raises = []\n            self.other_sections = defaultdict(str)\n\n        def __repr__(self):\n            return (f\"Docstring(short_summary={self.short_summary!r}, \"\n                    f\"long_description={self.long_description!r}, \"\n                    f\"params={self.params!r}, returns={self.returns!r}, \"\n                    f\"raises={self.raises!r}, other_sections={dict(self.other_sections)!r})\")\n\n    doc = Docstring()\n\n    # Normalize line endings and split into lines\n    lines = text.expandtabs().splitlines()\n\n    # Strip trailing and leading empty lines\n    while lines and lines[0].strip() == '':\n        lines.pop(0)\n    while lines and lines[-1].strip() == '':\n        lines.pop()\n\n    # States for parsing\n    section = None\n    param_indent = None\n    current_param = None\n    params = []\n    other_sections = defaultdict(list)\n    ret_lines = []\n    raise_lines = []\n    long_desc_lines = []\n    short_summary_done = False\n\n    i = 0\n    n = len(lines)\n\n    # Identify short summary which is first non-empty line\n    while i < n and lines[i].strip() == '':\n        i += 1\n    if i < n:\n        doc.short_summary = lines[i].strip()\n        i += 1\n        short_summary_done = True\n\n    # Skip blank lines after short summary\n    while i < n and lines[i].strip() == '':\n        i += 1\n\n    # Collect long description lines up to a section header\n    def is_section_header(idx):\n        # A section header is lines[idx] non-empty and next line is === or ---\n        if idx + 1 >= n:\n            return False\n        line = lines[idx].rstrip()\n        underline = lines[idx + 1].rstrip()\n        if len(underline) < len(line):\n            return False\n        if set(underline) <= {'-', '='} and len(set(underline)) == 1:\n            return True\n        return False\n\n    while i < n:\n        if is_section_header(i):\n            break\n        long_desc_lines.append(lines[i])\n        i += 1\n\n    doc.long_description = \"\\n\".join([l.rstrip() for l in long_desc_lines]).rstrip()\n\n    # Parse sections\n    while i < n:\n        header = lines[i].rstrip()\n        underline = lines[i+1].rstrip() if i+1 < n else ''\n        section_name = header.strip().lower()\n\n        i += 2  # advance past header and underline\n\n        # Parse content lines up to next section or end\n        content_lines = []\n        while i < n:\n            if is_section_header(i):\n                break\n            content_lines.append(lines[i])\n            i += 1\n\n        # Process this section by name\n        content_lines = [l.rstrip() for l in content_lines]\n\n        if section_name in {\"parameters\", \"parameter\", \"args\", \"arguments\"}:\n            # Parse parameter lines\n            # Parameters are typically:\n            # name : type\n            #     description lines indented\n            param_list = []\n            idx = 0\n            plen = len(content_lines)\n            while idx < plen:\n                line = content_lines[idx]\n                if line.strip() == '':\n                    idx += 1\n                    continue\n\n                # Find param definition line with colon\n                m = re.match(r'^([a-zA-Z0-9_*, ]+?)\\s*:\\s*(.*)$', line)\n                if m:\n                    # Start new param\n                    name = m.group(1).strip()\n                    type_ = m.group(2).strip()\n                    desc_lines = []\n\n                    # Find description lines indented more than param line\n                    # We use indentation of param line to find description indentation\n                    indent = len(line) - len(line.lstrip())\n\n                    idx += 1\n                    while idx < plen:\n                        nextline = content_lines[idx]\n                        if nextline.strip() == '':\n                            desc_lines.append('')\n                            idx += 1\n                        else:\n                            next_indent = len(nextline) - len(nextline.lstrip())\n                            if next_indent > indent:\n                                desc_lines.append(nextline.strip())\n                                idx += 1\n                            else:\n                                break\n                    description = \"\\n\".join(desc_lines).rstrip()\n                    param_list.append({\n                        \"name\": name,\n                        \"type\": type_,\n                        \"description\": description\n                    })\n                else:\n                    # not a param line, skip or break\n                    idx += 1\n            doc.params = param_list\n\n        elif section_name in {\"returns\", \"return\"}:\n            # Returns section: typically one or more lines, first line might be \"type\"\n            # We join the lines as one string for now.\n            ret_text = []\n            for l in content_lines:\n                if l.strip() == '':\n                    ret_text.append('')\n                else:\n                    ret_text.append(l.strip())\n            doc.returns = \"\\n\".join(ret_text).rstrip()\n\n        elif section_name in {\"raises\", \"exceptions\"}:\n            # Parse raised exceptions, typically in format:\n            # ExceptionType\n            #     Description indented lines\n            exceptions = []\n            idx = 0\n            plen = len(content_lines)\n            while idx < plen:\n                line = content_lines[idx].strip()\n                if not line:\n                    idx += 1\n                    continue\n                # If next line is indented, that's description\n                desc_lines = []\n                idx_ = idx + 1\n                while idx_ < plen:\n                    nextline = content_lines[idx_]\n                    if nextline.strip() == '':\n                        desc_lines.append('')\n                        idx_ += 1\n                    else:\n                        indent_level = len(nextline) - len(nextline.lstrip())\n                        if indent_level > 0:\n                            desc_lines.append(nextline.strip())\n                            idx_ += 1\n                        else:\n                            break\n                description = \"\\n\".join(desc_lines).rstrip()\n                exceptions.append({\"type\": line, \"description\": description})\n                idx = idx_\n            doc.raises = exceptions\n\n        else:\n            # Treat other sections as generic text\n            doc.other_sections[section_name] = \"\\n\".join(content_lines).rstrip()\n\n    return doc", "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n    from dataclasses import dataclass, field\n\n    @dataclass\n    class Section:\n        title: str\n        content: list = field(default_factory=list)\n        \n    @dataclass\n    class Docstring:\n        short_summary: str = \"\"\n        extended_summary: str = \"\"\n        parameters: list = field(default_factory=list)\n        returns: list = field(default_factory=list)\n        raises: list = field(default_factory=list)\n        examples: str = \"\"\n        other_sections: dict = field(default_factory=dict)\n\n    def clean_lines(lines):\n        # Remove trailing and leading blank lines\n        while lines and lines[0].strip() == \"\":\n            lines.pop(0)\n        while lines and lines[-1].strip() == \"\":\n            lines.pop()\n        return lines\n\n    lines = text.expandtabs().splitlines()\n    lines = clean_lines(lines)\n\n    doc = Docstring()\n\n    # If docstring is empty\n    if not lines:\n        return doc\n\n    # Split docstring into sections by headers (headers are lines like 'Parameters', 'Returns', followed by dashes)\n    # Create a list of (section_title, section_lines)\n    section_titles = set([\n        \"Parameters\", \"Returns\", \"Yields\", \"Raises\", \"Examples\",\n        \"Attributes\", \"References\", \"Notes\", \"Warnings\"\n    ])\n\n    # Identify indices of section headers\n    headers = []\n    for i in range(len(lines) - 1):\n        # Header line followed by a line of dashes or equals\n        if lines[i].strip() in section_titles and re.match(r'^[-=]{3,}\\s*$', lines[i+1]):\n            headers.append(i)\n\n    # If no headers, treat entire docstring as short + extended summary\n    if not headers:\n        # Separate short and extended summary by first blank line\n        try:\n            blank_index = lines.index(\"\")\n            doc.short_summary = ' '.join([line.strip() for line in lines[:blank_index]])\n            doc.extended_summary = '\\n'.join(lines[blank_index+1:]).strip()\n        except ValueError:\n            doc.short_summary = '\\n'.join(lines).strip()\n        return doc\n\n    # Manage sections\n    # We'll use a dict of section_title -> lines\n    sections = defaultdict(list)\n    # short summary is everything before first header\n    doc.short_summary = ' '.join(line.strip() for line in lines[:headers[0]]).strip()\n\n    # extended summary is lines between short summary and first header if separated by extra blank lines\n    # Let's assume extended summary is blank line separated after short summary and before first header\n    # For that, we look between the last line of short summary and header start\n    # But short summary is condensed already, so just skip\n\n    # For each header, get its content until next header or end of lines\n    for i, start_index in enumerate(headers):\n        title = lines[start_index].strip()\n        # content lines start after the underline (start_index+2)\n        start_content = start_index + 2\n        if i + 1 < len(headers):\n            end_content = headers[i+1]\n        else:\n            end_content = len(lines)\n        content_lines = lines[start_content:end_content]\n        sections[title].extend(content_lines)\n\n    # Parse Parameters section\n    def parse_params(param_lines):\n        params = []\n        param_name_re = re.compile(r'^(\\w+)(\\s*:\\s*[\\w,\\s\\[\\]?\\.]+)?\\s*(.*)$')\n        current_param = None\n        for line in param_lines:\n            if not line.strip():\n                continue\n            # Detect parameter line: starts with name\n            match = param_name_re.match(line)\n            if match and not line.startswith(' '):\n                if current_param:\n                    params.append(current_param)\n                name = match.group(1)\n                type_ = match.group(2)[1:].strip() if match.group(2) else \"\"\n                desc = match.group(3).strip()\n                current_param = {\"name\": name, \"type\": type_, \"desc\": desc}\n            else:\n                # continuation line of description\n                if current_param:\n                    current_param['desc'] += ' ' + line.strip()\n        if current_param:\n            params.append(current_param)\n        return params\n\n    # Parse Returns or Yields section (similar structure)\n    def parse_returns(ret_lines):\n        returns = []\n        ret_name_re = re.compile(r'^(\\w+)?(\\s*:\\s*[\\w,\\s\\[\\]?\\.]+)?\\s*(.*)$')\n        current_ret = None\n        for line in ret_lines:\n            if not line.strip():\n                continue\n            # first non-indented line likely a return line\n            if not line.startswith(' '):\n                match = ret_name_re.match(line)\n                if current_ret:\n                    returns.append(current_ret)\n                name = match.group(1) if match else None\n                type_ = match.group(2)[1:].strip() if (match and match.group(2)) else \"\"\n                desc = match.group(3).strip() if match else line.strip()\n                current_ret = {\"name\": name, \"type\": type_, \"desc\": desc}\n            else:\n                if current_ret:\n                    current_ret['desc'] += ' ' + line.strip()\n        if current_ret:\n            returns.append(current_ret)\n        return returns\n\n    # Parse Raises section\n    def parse_raises(raise_lines):\n        raises = []\n        # Format: ErrorName: description\n        err_re = re.compile(r'^(\\w+)\\s*:\\s*(.*)$')\n        current_err = None\n        for line in raise_lines:\n            if not line.strip():\n                continue\n            if not line.startswith(' '):\n                m = err_re.match(line)\n                if current_err:\n                    raises.append(current_err)\n                if m:\n                    current_err = {\"error\": m.group(1), \"desc\": m.group(2).strip()}\n                else:\n                    current_err = {\"error\": line.strip(), \"desc\": \"\"}\n            else:\n                if current_err:\n                    current_err['desc'] += ' ' + line.strip()\n        if current_err:\n            raises.append(current_err)\n        return raises\n\n    # Now populate doc components from sections dict\n    if \"Parameters\" in sections:\n        doc.parameters = parse_params(sections[\"Parameters\"])\n\n    if \"Returns\" in sections:\n        doc.returns = parse_returns(sections[\"Returns\"])\n\n    if \"Yields\" in sections:\n        # treat yields same as returns\n        doc.returns = parse_returns(sections[\"Yields\"])\n\n    if \"Raises\" in sections:\n        doc.raises = parse_raises(sections[\"Raises\"])\n\n    if \"Examples\" in sections:\n        doc.examples = '\\n'.join(sections[\"Examples\"]).strip()\n\n    # Other sections captured as text blobs\n    other_keys = set(sections.keys()) - set([\"Parameters\", \"Returns\", \"Yields\", \"Raises\", \"Examples\"])\n    for key in other_keys:\n        doc.other_sections[key] = '\\n'.join(sections[key]).strip()\n\n    # Try to infer extended summary (anything between short summary and first header)\n    first_header_line = headers[0]\n    summary_lines = lines[:first_header_line]\n    # There might be blank lines separating short summary from extended summary\n    # Re-assemble extended summary after skipping short summary line(s)\n    # Short summary joined short lines, so find where blank line after short summary occurs\n    # We'll attempt to find blank line separating short summary and extended summary\n    blank_line_index = None\n    for idx, line in enumerate(summary_lines):\n        if line.strip() == \"\":\n            blank_line_index = idx\n            break\n\n    if blank_line_index is not None and blank_line_index+1 < len(summary_lines):\n        extended_summary_lines = summary_lines[blank_line_index+1:]\n        doc.extended_summary = '\\n'.join(extended_summary_lines).strip()\n\n    return doc"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport inspect\nimport itertools\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\n\n\ndef _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)\n\n\ndef _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string\n\n\nKV_REGEX = re.compile(r\"^[^\\s].*$\", flags=re.M)\n\nPARAM_KEY_REGEX = re.compile(r\"^(?P<name>.*?)(?:\\s*:\\s*(?P<type>.*?))?$\")\n\nPARAM_OPTIONAL_REGEX = re.compile(r\"(?P<type>.*?)(?:, optional|\\(optional\\))$\")\n\nPARAM_DEFAULT_REGEX = re.compile(\n    r\"[Dd]efault(?: is | = |: |s to |)\\s*(?P<value>[\\w\\-\\.]+)\"\n)\n\nRETURN_KEY_REGEX = re.compile(r\"^(?:(?P<name>.*?)\\s*:\\s*)?(?P<type>.*?)$\")\n\n\nclass Section:\n    \"\"\"Numpydoc section parser.\n\n    :param title: section title. For most sections, this is a heading like\n                  \"Parameters\" which appears on its own line, underlined by\n                  en-dashes ('-') on the following line.\n    :param key: meta key string. In the parsed ``DocstringMeta`` instance this\n                will be the first element of the ``args`` attribute list.\n    \"\"\"\n\n    def __init__(self, title: str, key: str) -> None:\n        self.title = title\n        self.key = key\n\n    @property\n    def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))\n\n\nclass _KVSection(Section):\n    \"\"\"Base parser for numpydoc sections with key-value syntax.\n\n    E.g. sections that look like this:\n        key\n            value\n        key2 : type\n            values can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringMeta:\n        pass\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )\n\n\nclass _SphinxSection(Section):\n    \"\"\"Base parser for numpydoc sections with sphinx-style syntax.\n\n    E.g. sections that look like this:\n        .. title:: something\n            possibly over multiple lines\n    \"\"\"\n\n    @property\n    def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)\n\n\nclass ParamSection(_KVSection):\n    \"\"\"Parser for numpydoc parameter sections.\n\n    E.g. any section that looks like this:\n        arg_name\n            arg_description\n        arg_2 : type, optional\n            descriptions can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n\nclass RaisesSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        ValueError\n            A description of what might raise ValueError\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )\n\n\nclass ReturnsSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        return_name : type\n            A description of this returned value\n        another_type\n            Return names are optional, types are required\n    \"\"\"\n\n    is_generator = False\n\n    def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )\n\n\nclass YieldsSection(ReturnsSection):\n    \"\"\"Parser for numpydoc generator \"yields\" sections.\"\"\"\n\n    is_generator = True\n\n\nclass DeprecationSection(_SphinxSection):\n    \"\"\"Parser for numpydoc \"deprecation warning\" sections.\"\"\"\n\n    def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )\n\n\nDEFAULT_SECTIONS = [\n    ParamSection(\"Parameters\", \"param\"),\n    ParamSection(\"Params\", \"param\"),\n    ParamSection(\"Arguments\", \"param\"),\n    ParamSection(\"Args\", \"param\"),\n    ParamSection(\"Other Parameters\", \"other_param\"),\n    ParamSection(\"Other Params\", \"other_param\"),\n    ParamSection(\"Other Arguments\", \"other_param\"),\n    ParamSection(\"Other Args\", \"other_param\"),\n    ParamSection(\"Receives\", \"receives\"),\n    ParamSection(\"Receive\", \"receives\"),\n    RaisesSection(\"Raises\", \"raises\"),\n    RaisesSection(\"Raise\", \"raises\"),\n    RaisesSection(\"Warns\", \"warns\"),\n    RaisesSection(\"Warn\", \"warns\"),\n    ParamSection(\"Attributes\", \"attribute\"),\n    ParamSection(\"Attribute\", \"attribute\"),\n    ReturnsSection(\"Returns\", \"returns\"),\n    ReturnsSection(\"Return\", \"returns\"),\n    YieldsSection(\"Yields\", \"yields\"),\n    YieldsSection(\"Yield\", \"yields\"),\n    Section(\"Examples\", \"examples\"),\n    Section(\"Example\", \"examples\"),\n    Section(\"Warnings\", \"warnings\"),\n    Section(\"Warning\", \"warnings\"),\n    Section(\"See Also\", \"see_also\"),\n    Section(\"Related\", \"see_also\"),\n    Section(\"Notes\", \"notes\"),\n    Section(\"Note\", \"notes\"),\n    Section(\"References\", \"references\"),\n    Section(\"Reference\", \"references\"),\n    DeprecationSection(\"deprecated\", \"deprecation\"),\n]\n\n\nclass NumpydocParser:\n    def __init__(self, sections: T.Optional[T.Dict[str, Section]] = None):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        \"\"\"\n        sections = sections or DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self._setup()\n\n    def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import namedtuple\n\n    Docstring = namedtuple('Docstring', ['short_summary', 'long_description', 'parameters', 'returns', 'raises', 'examples'])\n\n    # Helper functions\n    def clean_lines(lines):\n        return [line.rstrip() for line in lines]\n\n    def parse_parameters(lines):\n        params = []\n        param_name = None\n        param_type = None\n        description_lines = []\n        param_pattern = re.compile(r'^\\s*([\\w,*\\[\\]]+)\\s*:\\s*([\\w ,\\[\\].]+)?$')\n\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if not line.strip():\n                i += 1\n                continue\n\n            match = param_pattern.match(line)\n            if match:\n                if param_name:\n                    # previous parameter\n                    params.append({'name': param_name, 'type': param_type, 'desc': ' '.join(description_lines).strip()})\n                param_name = match.group(1).strip()\n                param_type = match.group(2).strip() if match.group(2) else None\n                description_lines = []\n                i += 1\n                # following indented lines belong to description\n                while i < len(lines) and (lines[i].startswith('    ') or lines[i].strip() == ''):\n                    description_lines.append(lines[i].strip())\n                    i += 1\n            else:\n                # continuation line but no recognized param header -> skip or attach to desc?\n                if param_name:\n                    description_lines.append(line.strip())\n                i += 1\n\n        if param_name:\n            params.append({'name': param_name, 'type': param_type, 'desc': ' '.join(description_lines).strip()})\n\n        return params\n\n    def parse_section(lines):\n        # For a section like Returns or Raises, parse similarly, where lines after header are description.\n        description_lines = []\n        i = 0\n        while i < len(lines):\n            description_lines.append(lines[i].strip())\n            i += 1\n        return ' '.join(description_lines).strip()\n\n    # Split docstring into lines\n    lines = text.splitlines()\n\n    # Strip leading/trailing empty lines\n    while lines and not lines[0].strip():\n        lines.pop(0)\n    while lines and not lines[-1].strip():\n        lines.pop()\n\n    # Identify short summary - first non-empty line\n    short_summary = ''\n    long_description_lines = []\n    parameters_lines = []\n    returns_lines = []\n    raises_lines = []\n    examples_lines = []\n\n    # We iterate to separate sections\n    current_section = 'short_summary_or_desc'\n\n    # The numpy style defines section headers like:\n    # Parameters\n    # ----------\n    # Returns\n    # -------\n    # Raises\n    # ------\n    # Examples\n    # --------\n    section_headers = {\n        'parameters': re.compile(r'^\\s*Parameters\\s*$'),\n        'returns': re.compile(r'^\\s*Returns\\s*$'),\n        'raises': re.compile(r'^\\s*Raises\\s*$'),\n        'examples': re.compile(r'^\\s*Examples\\s*$'),\n        'short_divider': re.compile(r'^\\s*-{3,}\\s*$')\n    }\n\n    i = 0\n    # First line short summary\n    while i < len(lines) and not lines[i].strip():\n        i += 1\n    if i < len(lines):\n        short_summary = lines[i].strip()\n        i += 1\n    else:\n        return Docstring(short_summary='', long_description='', parameters=[], returns=None, raises=None, examples=None)\n\n    # Next we check if next line is empty (common) or divider, then long description until next section\n    # We'll parse until we see a section header or end\n    # We expect a blank line after short summary generally\n\n    # First skip blank lines\n    while i < len(lines) and not lines[i].strip():\n        i += 1\n\n    # If next line is a section header, there is no long description\n    # Otherwise read until section header or end\n    def is_section_header(line):\n        for k, pattern in section_headers.items():\n            if pattern.match(line):\n                return True\n        return False\n\n    # Long description\n    long_description_lines = []\n    while i < len(lines) and not is_section_header(lines[i]):\n        long_description_lines.append(lines[i])\n        i += 1\n\n    # The above might have trailing blank lines, strip them\n    while long_description_lines and not long_description_lines[-1].strip():\n        long_description_lines.pop()\n\n    # Now parse sections\n    sections = {'parameters': None, 'returns': None, 'raises': None, 'examples': None}\n\n    while i < len(lines):\n        # Expect section header first\n        header_found = None\n        for key, pattern in section_headers.items():\n            if pattern.match(lines[i]):\n                header_found = key\n                break\n        if header_found is None:\n            i += 1\n            continue\n\n        i += 1\n        # After header line, expect a line with dashes\n        if i < len(lines) and section_headers['short_divider'].match(lines[i]):\n            i += 1\n        else:\n            # Malformed numpy docstring, just continue parsing\n            pass\n\n        # Collect section body lines until next section header or end\n        section_body_lines = []\n        while i < len(lines) and not is_section_header(lines[i]):\n            section_body_lines.append(lines[i])\n            i += 1\n\n        if header_found == 'parameters':\n            sections['parameters'] = clean_lines(section_body_lines)\n        elif header_found == 'returns':\n            sections['returns'] = clean_lines(section_body_lines)\n        elif header_found == 'raises':\n            sections['raises'] = clean_lines(section_body_lines)\n        elif header_found == 'examples':\n            sections['examples'] = clean_lines(section_body_lines)\n\n    params = parse_parameters(sections['parameters']) if sections['parameters'] else []\n    returns = parse_section(sections['returns']) if sections['returns'] else None\n    raises = parse_section(sections['raises']) if sections['raises'] else None\n    examples = '\\n'.join(sections['examples']).strip() if sections['examples'] else None\n\n    long_description = '\\n'.join(long_description_lines).strip()\n\n    return Docstring(\n        short_summary=short_summary,\n        long_description=long_description,\n        parameters=params,\n        returns=returns,\n        raises=raises,\n        examples=examples\n    )\n\n\nimport pickle\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport inspect\nimport itertools\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\n\n\ndef _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)\n\n\ndef _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string\n\n\nKV_REGEX = re.compile(r\"^[^\\s].*$\", flags=re.M)\n\nPARAM_KEY_REGEX = re.compile(r\"^(?P<name>.*?)(?:\\s*:\\s*(?P<type>.*?))?$\")\n\nPARAM_OPTIONAL_REGEX = re.compile(r\"(?P<type>.*?)(?:, optional|\\(optional\\))$\")\n\nPARAM_DEFAULT_REGEX = re.compile(\n    r\"[Dd]efault(?: is | = |: |s to |)\\s*(?P<value>[\\w\\-\\.]+)\"\n)\n\nRETURN_KEY_REGEX = re.compile(r\"^(?:(?P<name>.*?)\\s*:\\s*)?(?P<type>.*?)$\")\n\n\nclass Section:\n    \"\"\"Numpydoc section parser.\n\n    :param title: section title. For most sections, this is a heading like\n                  \"Parameters\" which appears on its own line, underlined by\n                  en-dashes ('-') on the following line.\n    :param key: meta key string. In the parsed ``DocstringMeta`` instance this\n                will be the first element of the ``args`` attribute list.\n    \"\"\"\n\n    def __init__(self, title: str, key: str) -> None:\n        self.title = title\n        self.key = key\n\n    @property\n    def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))\n\n\nclass _KVSection(Section):\n    \"\"\"Base parser for numpydoc sections with key-value syntax.\n\n    E.g. sections that look like this:\n        key\n            value\n        key2 : type\n            values can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringMeta:\n        pass\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )\n\n\nclass _SphinxSection(Section):\n    \"\"\"Base parser for numpydoc sections with sphinx-style syntax.\n\n    E.g. sections that look like this:\n        .. title:: something\n            possibly over multiple lines\n    \"\"\"\n\n    @property\n    def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)\n\n\nclass ParamSection(_KVSection):\n    \"\"\"Parser for numpydoc parameter sections.\n\n    E.g. any section that looks like this:\n        arg_name\n            arg_description\n        arg_2 : type, optional\n            descriptions can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n\nclass RaisesSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        ValueError\n            A description of what might raise ValueError\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )\n\n\nclass ReturnsSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        return_name : type\n            A description of this returned value\n        another_type\n            Return names are optional, types are required\n    \"\"\"\n\n    is_generator = False\n\n    def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )\n\n\nclass YieldsSection(ReturnsSection):\n    \"\"\"Parser for numpydoc generator \"yields\" sections.\"\"\"\n\n    is_generator = True\n\n\nclass DeprecationSection(_SphinxSection):\n    \"\"\"Parser for numpydoc \"deprecation warning\" sections.\"\"\"\n\n    def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )\n\n\nDEFAULT_SECTIONS = [\n    ParamSection(\"Parameters\", \"param\"),\n    ParamSection(\"Params\", \"param\"),\n    ParamSection(\"Arguments\", \"param\"),\n    ParamSection(\"Args\", \"param\"),\n    ParamSection(\"Other Parameters\", \"other_param\"),\n    ParamSection(\"Other Params\", \"other_param\"),\n    ParamSection(\"Other Arguments\", \"other_param\"),\n    ParamSection(\"Other Args\", \"other_param\"),\n    ParamSection(\"Receives\", \"receives\"),\n    ParamSection(\"Receive\", \"receives\"),\n    RaisesSection(\"Raises\", \"raises\"),\n    RaisesSection(\"Raise\", \"raises\"),\n    RaisesSection(\"Warns\", \"warns\"),\n    RaisesSection(\"Warn\", \"warns\"),\n    ParamSection(\"Attributes\", \"attribute\"),\n    ParamSection(\"Attribute\", \"attribute\"),\n    ReturnsSection(\"Returns\", \"returns\"),\n    ReturnsSection(\"Return\", \"returns\"),\n    YieldsSection(\"Yields\", \"yields\"),\n    YieldsSection(\"Yield\", \"yields\"),\n    Section(\"Examples\", \"examples\"),\n    Section(\"Example\", \"examples\"),\n    Section(\"Warnings\", \"warnings\"),\n    Section(\"Warning\", \"warnings\"),\n    Section(\"See Also\", \"see_also\"),\n    Section(\"Related\", \"see_also\"),\n    Section(\"Notes\", \"notes\"),\n    Section(\"Note\", \"notes\"),\n    Section(\"References\", \"references\"),\n    Section(\"Reference\", \"references\"),\n    DeprecationSection(\"deprecated\", \"deprecation\"),\n]\n\n\nclass NumpydocParser:\n    def __init__(self, sections: T.Optional[T.Dict[str, Section]] = None):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        \"\"\"\n        sections = sections or DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self._setup()\n\n    def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_summary = \"\"\n            self.long_description = \"\"\n            self.parameters = []\n            self.returns = []\n            self.raises = []\n            self.examples = \"\"\n            self.other_sections = defaultdict(list)\n\n        def __repr__(self):\n            return (f\"Docstring(short_summary={self.short_summary!r}, \"\n                    f\"long_description={self.long_description!r}, \"\n                    f\"parameters={self.parameters}, returns={self.returns}, \"\n                    f\"raises={self.raises}, examples={self.examples!r}, \"\n                    f\"other_sections={dict(self.other_sections)})\")\n\n    lines = text.expandtabs().splitlines()\n    doc = Docstring()\n\n    # Remove any leading/trailing empty lines\n    while lines and not lines[0].strip():\n        lines.pop(0)\n    while lines and not lines[-1].strip():\n        lines.pop()\n\n    if not lines:\n        return doc\n\n    # Extract short summary (first non-empty line)\n    i = 0\n    while i < len(lines) and not lines[i].strip():\n        i += 1\n    if i < len(lines):\n        doc.short_summary = lines[i].strip()\n        i += 1\n\n    # Extract long description until first section or empty line after summary\n    long_desc_lines = []\n    while i < len(lines):\n        line = lines[i]\n        if not line.strip():\n            # blank line, maybe end of long description\n            # but check if next lines are section header or blank as well\n            j = i + 1\n            while j < len(lines) and not lines[j].strip():\n                j += 1\n            if j < len(lines) and re.match(r'^[A-Za-z ]+\\n?$', lines[j]):\n                break\n            long_desc_lines.append(line)\n            i += 1\n            continue\n        # Check for section header line: must be followed by dashes of at least same length.\n        if (i + 1) < len(lines):\n            next_line = lines[i + 1]\n            if re.match(r'^-+\\s*$', next_line) and len(next_line.strip()) >= len(line.strip()):\n                break\n        long_desc_lines.append(line)\n        i += 1\n\n    doc.long_description = \"\\n\".join(long_desc_lines).strip()\n\n    # Function for parsing fields like Parameters, Returns etc.\n    def parse_fields(start_idx):\n        fields = []\n        idx = start_idx\n        while idx < len(lines):\n            if not lines[idx].strip():\n                idx += 1\n                continue\n            # Check if new section header found\n            if (idx + 1) < len(lines):\n                if re.match(r'^-+\\s*$', lines[idx + 1]) and len(lines[idx + 1].strip()) >= len(lines[idx].strip()):\n                    break\n            # Parse parameter or return block\n            # Format: name : type\n            #          description lines indented\n            header_match = re.match(r'^(\\S[^:]*)\\s*:\\s*(.*)$', lines[idx])\n            if not header_match:\n                # malformed or end of section\n                break\n            name, type_ = header_match.groups()\n            desc_lines = []\n            idx += 1\n            while idx < len(lines):\n                if not lines[idx].strip():\n                    desc_lines.append('')\n                    idx += 1\n                    continue\n                if re.match(r'^\\S', lines[idx]):\n                    # Start of new param or section or something else\n                    break\n                # Description line is indented (at least one space or tab)\n                desc_lines.append(lines[idx].strip())\n                idx += 1\n            desc = \"\\n\".join(desc_lines).strip()\n            fields.append({\"name\": name.strip(), \"type\": type_.strip(), \"description\": desc})\n        return fields, idx\n\n    # Map section name to attribute and parse method\n    section_map = {\n        \"Parameters\": \"parameters\",\n        \"Returns\": \"returns\",\n        \"Yields\": \"returns\",\n        \"Raises\": \"raises\",\n        \"Examples\": \"examples\"\n    }\n\n    while i < len(lines):\n        line = lines[i].strip()\n        if not line:\n            i += 1\n            continue\n        # Check if it's a section header\n        if (i+1) < len(lines) and re.match(r'^-+\\s*$', lines[i+1]) and len(lines[i+1].strip()) >= len(line):\n            section = line\n            i += 2\n            if section in (\"Examples\"):\n                # collect everything until next section or end\n                example_lines = []\n                while i < len(lines):\n                    # check if next lines form a section header\n                    if (i + 1) < len(lines):\n                        if re.match(r'^-+\\s*$', lines[i+1]) and len(lines[i+1].strip()) >= len(lines[i].strip()):\n                            break\n                    example_lines.append(lines[i])\n                    i += 1\n                doc.examples = \"\\n\".join(example_lines).rstrip()\n            elif section in (\"Parameters\", \"Returns\", \"Yields\", \"Raises\"):\n                fields, i = parse_fields(i)\n                if section in (\"Returns\", \"Yields\"):\n                    doc.returns.extend(fields)\n                elif section == \"Parameters\":\n                    doc.parameters.extend(fields)\n                elif section == \"Raises\":\n                    doc.raises.extend(fields)\n            else:\n                # Other sections, collect text lines until next section\n                other_lines = []\n                while i < len(lines):\n                    if (i + 1) < len(lines):\n                        if re.match(r'^-+\\s*$', lines[i+1]) and len(lines[i+1].strip()) >= len(lines[i].strip()):\n                            break\n                    other_lines.append(lines[i])\n                    i += 1\n                doc.other_sections[section] = \"\\n\".join(other_lines).rstrip()\n        else:\n            i += 1\n\n    return doc\n\n\nimport pickle\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport inspect\nimport itertools\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\n\n\ndef _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)\n\n\ndef _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string\n\n\nKV_REGEX = re.compile(r\"^[^\\s].*$\", flags=re.M)\n\nPARAM_KEY_REGEX = re.compile(r\"^(?P<name>.*?)(?:\\s*:\\s*(?P<type>.*?))?$\")\n\nPARAM_OPTIONAL_REGEX = re.compile(r\"(?P<type>.*?)(?:, optional|\\(optional\\))$\")\n\nPARAM_DEFAULT_REGEX = re.compile(\n    r\"[Dd]efault(?: is | = |: |s to |)\\s*(?P<value>[\\w\\-\\.]+)\"\n)\n\nRETURN_KEY_REGEX = re.compile(r\"^(?:(?P<name>.*?)\\s*:\\s*)?(?P<type>.*?)$\")\n\n\nclass Section:\n    \"\"\"Numpydoc section parser.\n\n    :param title: section title. For most sections, this is a heading like\n                  \"Parameters\" which appears on its own line, underlined by\n                  en-dashes ('-') on the following line.\n    :param key: meta key string. In the parsed ``DocstringMeta`` instance this\n                will be the first element of the ``args`` attribute list.\n    \"\"\"\n\n    def __init__(self, title: str, key: str) -> None:\n        self.title = title\n        self.key = key\n\n    @property\n    def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))\n\n\nclass _KVSection(Section):\n    \"\"\"Base parser for numpydoc sections with key-value syntax.\n\n    E.g. sections that look like this:\n        key\n            value\n        key2 : type\n            values can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringMeta:\n        pass\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )\n\n\nclass _SphinxSection(Section):\n    \"\"\"Base parser for numpydoc sections with sphinx-style syntax.\n\n    E.g. sections that look like this:\n        .. title:: something\n            possibly over multiple lines\n    \"\"\"\n\n    @property\n    def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)\n\n\nclass ParamSection(_KVSection):\n    \"\"\"Parser for numpydoc parameter sections.\n\n    E.g. any section that looks like this:\n        arg_name\n            arg_description\n        arg_2 : type, optional\n            descriptions can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n\nclass RaisesSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        ValueError\n            A description of what might raise ValueError\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )\n\n\nclass ReturnsSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        return_name : type\n            A description of this returned value\n        another_type\n            Return names are optional, types are required\n    \"\"\"\n\n    is_generator = False\n\n    def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )\n\n\nclass YieldsSection(ReturnsSection):\n    \"\"\"Parser for numpydoc generator \"yields\" sections.\"\"\"\n\n    is_generator = True\n\n\nclass DeprecationSection(_SphinxSection):\n    \"\"\"Parser for numpydoc \"deprecation warning\" sections.\"\"\"\n\n    def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )\n\n\nDEFAULT_SECTIONS = [\n    ParamSection(\"Parameters\", \"param\"),\n    ParamSection(\"Params\", \"param\"),\n    ParamSection(\"Arguments\", \"param\"),\n    ParamSection(\"Args\", \"param\"),\n    ParamSection(\"Other Parameters\", \"other_param\"),\n    ParamSection(\"Other Params\", \"other_param\"),\n    ParamSection(\"Other Arguments\", \"other_param\"),\n    ParamSection(\"Other Args\", \"other_param\"),\n    ParamSection(\"Receives\", \"receives\"),\n    ParamSection(\"Receive\", \"receives\"),\n    RaisesSection(\"Raises\", \"raises\"),\n    RaisesSection(\"Raise\", \"raises\"),\n    RaisesSection(\"Warns\", \"warns\"),\n    RaisesSection(\"Warn\", \"warns\"),\n    ParamSection(\"Attributes\", \"attribute\"),\n    ParamSection(\"Attribute\", \"attribute\"),\n    ReturnsSection(\"Returns\", \"returns\"),\n    ReturnsSection(\"Return\", \"returns\"),\n    YieldsSection(\"Yields\", \"yields\"),\n    YieldsSection(\"Yield\", \"yields\"),\n    Section(\"Examples\", \"examples\"),\n    Section(\"Example\", \"examples\"),\n    Section(\"Warnings\", \"warnings\"),\n    Section(\"Warning\", \"warnings\"),\n    Section(\"See Also\", \"see_also\"),\n    Section(\"Related\", \"see_also\"),\n    Section(\"Notes\", \"notes\"),\n    Section(\"Note\", \"notes\"),\n    Section(\"References\", \"references\"),\n    Section(\"Reference\", \"references\"),\n    DeprecationSection(\"deprecated\", \"deprecation\"),\n]\n\n\nclass NumpydocParser:\n    def __init__(self, sections: T.Optional[T.Dict[str, Section]] = None):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        \"\"\"\n        sections = sections or DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self._setup()\n\n    def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import namedtuple\n\n    Docstring = namedtuple('Docstring', ['short_summary', 'long_description', 'parameters', 'returns', 'raises', 'examples'])\n\n    def _split_sections(text):\n        sections = re.split(r'\\n(?=(Parameters|Returns|Raises|Examples)\\n-+\\n)', text)\n        preamble = sections[0]\n        content = sections[1:]\n        parsed = {}\n        for i in range(0, len(content), 2):\n            section_name = content[i].strip()\n            section_body = content[i + 1]\n            parsed[section_name] = section_body\n        return preamble, parsed\n\n    def _parse_parameters(text):\n        params = []\n        param_re = re.compile(r'^(\\w+)\\s*:\\s*([\\w,\\s\\[\\]]+)\\n\\s*(.+(?:\\n\\s{4,}.+)*)', re.MULTILINE)\n        for match in param_re.finditer(text):\n            name = match.group(1)\n            ptype = match.group(2).strip()\n            desc = re.sub(r'\\n\\s{4,}', ' ', match.group(3).strip())\n            params.append({'name': name, 'type': ptype, 'description': desc})\n        return params\n\n    def _parse_returns(text):\n        returns = []\n        ret_re = re.compile(r'^(\\w+)?\\s*:\\s*([\\w,\\s\\[\\]]+)\\n\\s*(.+(?:\\n\\s{4,}.+)*)', re.MULTILINE)\n        for match in ret_re.finditer(text):\n            name = match.group(1)\n            ptype = match.group(2).strip()\n            desc = re.sub(r'\\n\\s{4,}', ' ', match.group(3).strip())\n            returns.append({'name': name, 'type': ptype, 'description': desc})\n        if not returns and text.strip():\n            # fallback: untyped returns description\n            returns.append({'name': None, 'type': None, 'description': ' '.join(line.strip() for line in text.splitlines())})\n        return returns\n\n    def _parse_raises(text):\n        raises = []\n        raise_re = re.compile(r'^(\\w+)\\n\\s*(.+(?:\\n\\s{4,}.+)*)', re.MULTILINE)\n        for match in raise_re.finditer(text):\n            exc = match.group(1)\n            desc = re.sub(r'\\n\\s{4,}', ' ', match.group(2).strip())\n            raises.append({'exception': exc, 'description': desc})\n        return raises\n\n    def _parse_examples(text):\n        return text.strip()\n\n    # Normalize line endings\n    text = text.replace('\\r\\n', '\\n').strip()\n\n    # Split into short summary, long description, and sections\n    # Short summary is first line\n    lines = text.split('\\n')\n    short_summary = lines[0].strip()\n    rest = '\\n'.join(lines[1:]).strip()\n\n    # Try to find section titles with underlines of '-'\n    split_result = re.split(r'\\n(?=\\w+\\n-+\\n)', rest)\n    # If no sections\n    if len(split_result) == 1:\n        long_description = rest\n        parameters = []\n        returns = []\n        raises = []\n        examples = ''\n    else:\n        # first part before sections is long description\n        long_description = split_result[0].strip()\n        sections_text = '\\n'.join(split_result[1:])\n\n        preamble, sections = _split_sections(sections_text)\n\n        parameters = _parse_parameters(sections.get('Parameters', '')) if 'Parameters' in sections else []\n        returns = _parse_returns(sections.get('Returns', '')) if 'Returns' in sections else []\n        raises = _parse_raises(sections.get('Raises', '')) if 'Raises' in sections else []\n        examples = _parse_examples(sections.get('Examples', '')) if 'Examples' in sections else ''\n\n    return Docstring(short_summary, long_description, parameters, returns, raises, examples)\n\n\nimport pickle\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport inspect\nimport itertools\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\n\n\ndef _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)\n\n\ndef _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string\n\n\nKV_REGEX = re.compile(r\"^[^\\s].*$\", flags=re.M)\n\nPARAM_KEY_REGEX = re.compile(r\"^(?P<name>.*?)(?:\\s*:\\s*(?P<type>.*?))?$\")\n\nPARAM_OPTIONAL_REGEX = re.compile(r\"(?P<type>.*?)(?:, optional|\\(optional\\))$\")\n\nPARAM_DEFAULT_REGEX = re.compile(\n    r\"[Dd]efault(?: is | = |: |s to |)\\s*(?P<value>[\\w\\-\\.]+)\"\n)\n\nRETURN_KEY_REGEX = re.compile(r\"^(?:(?P<name>.*?)\\s*:\\s*)?(?P<type>.*?)$\")\n\n\nclass Section:\n    \"\"\"Numpydoc section parser.\n\n    :param title: section title. For most sections, this is a heading like\n                  \"Parameters\" which appears on its own line, underlined by\n                  en-dashes ('-') on the following line.\n    :param key: meta key string. In the parsed ``DocstringMeta`` instance this\n                will be the first element of the ``args`` attribute list.\n    \"\"\"\n\n    def __init__(self, title: str, key: str) -> None:\n        self.title = title\n        self.key = key\n\n    @property\n    def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))\n\n\nclass _KVSection(Section):\n    \"\"\"Base parser for numpydoc sections with key-value syntax.\n\n    E.g. sections that look like this:\n        key\n            value\n        key2 : type\n            values can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringMeta:\n        pass\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )\n\n\nclass _SphinxSection(Section):\n    \"\"\"Base parser for numpydoc sections with sphinx-style syntax.\n\n    E.g. sections that look like this:\n        .. title:: something\n            possibly over multiple lines\n    \"\"\"\n\n    @property\n    def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)\n\n\nclass ParamSection(_KVSection):\n    \"\"\"Parser for numpydoc parameter sections.\n\n    E.g. any section that looks like this:\n        arg_name\n            arg_description\n        arg_2 : type, optional\n            descriptions can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n\nclass RaisesSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        ValueError\n            A description of what might raise ValueError\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )\n\n\nclass ReturnsSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        return_name : type\n            A description of this returned value\n        another_type\n            Return names are optional, types are required\n    \"\"\"\n\n    is_generator = False\n\n    def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )\n\n\nclass YieldsSection(ReturnsSection):\n    \"\"\"Parser for numpydoc generator \"yields\" sections.\"\"\"\n\n    is_generator = True\n\n\nclass DeprecationSection(_SphinxSection):\n    \"\"\"Parser for numpydoc \"deprecation warning\" sections.\"\"\"\n\n    def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )\n\n\nDEFAULT_SECTIONS = [\n    ParamSection(\"Parameters\", \"param\"),\n    ParamSection(\"Params\", \"param\"),\n    ParamSection(\"Arguments\", \"param\"),\n    ParamSection(\"Args\", \"param\"),\n    ParamSection(\"Other Parameters\", \"other_param\"),\n    ParamSection(\"Other Params\", \"other_param\"),\n    ParamSection(\"Other Arguments\", \"other_param\"),\n    ParamSection(\"Other Args\", \"other_param\"),\n    ParamSection(\"Receives\", \"receives\"),\n    ParamSection(\"Receive\", \"receives\"),\n    RaisesSection(\"Raises\", \"raises\"),\n    RaisesSection(\"Raise\", \"raises\"),\n    RaisesSection(\"Warns\", \"warns\"),\n    RaisesSection(\"Warn\", \"warns\"),\n    ParamSection(\"Attributes\", \"attribute\"),\n    ParamSection(\"Attribute\", \"attribute\"),\n    ReturnsSection(\"Returns\", \"returns\"),\n    ReturnsSection(\"Return\", \"returns\"),\n    YieldsSection(\"Yields\", \"yields\"),\n    YieldsSection(\"Yield\", \"yields\"),\n    Section(\"Examples\", \"examples\"),\n    Section(\"Example\", \"examples\"),\n    Section(\"Warnings\", \"warnings\"),\n    Section(\"Warning\", \"warnings\"),\n    Section(\"See Also\", \"see_also\"),\n    Section(\"Related\", \"see_also\"),\n    Section(\"Notes\", \"notes\"),\n    Section(\"Note\", \"notes\"),\n    Section(\"References\", \"references\"),\n    Section(\"Reference\", \"references\"),\n    DeprecationSection(\"deprecated\", \"deprecation\"),\n]\n\n\nclass NumpydocParser:\n    def __init__(self, sections: T.Optional[T.Dict[str, Section]] = None):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        \"\"\"\n        sections = sections or DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self._setup()\n\n    def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    class Docstring:\n        def __init__(self):\n            self.short_summary = ''\n            self.long_description = ''\n            self.params = []\n            self.returns = ''\n            self.raises = []\n            self.other_sections = defaultdict(str)\n\n        def __repr__(self):\n            return (f\"Docstring(short_summary={self.short_summary!r}, \"\n                    f\"long_description={self.long_description!r}, \"\n                    f\"params={self.params!r}, returns={self.returns!r}, \"\n                    f\"raises={self.raises!r}, other_sections={dict(self.other_sections)!r})\")\n\n    doc = Docstring()\n\n    # Normalize line endings and split into lines\n    lines = text.expandtabs().splitlines()\n\n    # Strip trailing and leading empty lines\n    while lines and lines[0].strip() == '':\n        lines.pop(0)\n    while lines and lines[-1].strip() == '':\n        lines.pop()\n\n    # States for parsing\n    section = None\n    param_indent = None\n    current_param = None\n    params = []\n    other_sections = defaultdict(list)\n    ret_lines = []\n    raise_lines = []\n    long_desc_lines = []\n    short_summary_done = False\n\n    i = 0\n    n = len(lines)\n\n    # Identify short summary which is first non-empty line\n    while i < n and lines[i].strip() == '':\n        i += 1\n    if i < n:\n        doc.short_summary = lines[i].strip()\n        i += 1\n        short_summary_done = True\n\n    # Skip blank lines after short summary\n    while i < n and lines[i].strip() == '':\n        i += 1\n\n    # Collect long description lines up to a section header\n    def is_section_header(idx):\n        # A section header is lines[idx] non-empty and next line is === or ---\n        if idx + 1 >= n:\n            return False\n        line = lines[idx].rstrip()\n        underline = lines[idx + 1].rstrip()\n        if len(underline) < len(line):\n            return False\n        if set(underline) <= {'-', '='} and len(set(underline)) == 1:\n            return True\n        return False\n\n    while i < n:\n        if is_section_header(i):\n            break\n        long_desc_lines.append(lines[i])\n        i += 1\n\n    doc.long_description = \"\\n\".join([l.rstrip() for l in long_desc_lines]).rstrip()\n\n    # Parse sections\n    while i < n:\n        header = lines[i].rstrip()\n        underline = lines[i+1].rstrip() if i+1 < n else ''\n        section_name = header.strip().lower()\n\n        i += 2  # advance past header and underline\n\n        # Parse content lines up to next section or end\n        content_lines = []\n        while i < n:\n            if is_section_header(i):\n                break\n            content_lines.append(lines[i])\n            i += 1\n\n        # Process this section by name\n        content_lines = [l.rstrip() for l in content_lines]\n\n        if section_name in {\"parameters\", \"parameter\", \"args\", \"arguments\"}:\n            # Parse parameter lines\n            # Parameters are typically:\n            # name : type\n            #     description lines indented\n            param_list = []\n            idx = 0\n            plen = len(content_lines)\n            while idx < plen:\n                line = content_lines[idx]\n                if line.strip() == '':\n                    idx += 1\n                    continue\n\n                # Find param definition line with colon\n                m = re.match(r'^([a-zA-Z0-9_*, ]+?)\\s*:\\s*(.*)$', line)\n                if m:\n                    # Start new param\n                    name = m.group(1).strip()\n                    type_ = m.group(2).strip()\n                    desc_lines = []\n\n                    # Find description lines indented more than param line\n                    # We use indentation of param line to find description indentation\n                    indent = len(line) - len(line.lstrip())\n\n                    idx += 1\n                    while idx < plen:\n                        nextline = content_lines[idx]\n                        if nextline.strip() == '':\n                            desc_lines.append('')\n                            idx += 1\n                        else:\n                            next_indent = len(nextline) - len(nextline.lstrip())\n                            if next_indent > indent:\n                                desc_lines.append(nextline.strip())\n                                idx += 1\n                            else:\n                                break\n                    description = \"\\n\".join(desc_lines).rstrip()\n                    param_list.append({\n                        \"name\": name,\n                        \"type\": type_,\n                        \"description\": description\n                    })\n                else:\n                    # not a param line, skip or break\n                    idx += 1\n            doc.params = param_list\n\n        elif section_name in {\"returns\", \"return\"}:\n            # Returns section: typically one or more lines, first line might be \"type\"\n            # We join the lines as one string for now.\n            ret_text = []\n            for l in content_lines:\n                if l.strip() == '':\n                    ret_text.append('')\n                else:\n                    ret_text.append(l.strip())\n            doc.returns = \"\\n\".join(ret_text).rstrip()\n\n        elif section_name in {\"raises\", \"exceptions\"}:\n            # Parse raised exceptions, typically in format:\n            # ExceptionType\n            #     Description indented lines\n            exceptions = []\n            idx = 0\n            plen = len(content_lines)\n            while idx < plen:\n                line = content_lines[idx].strip()\n                if not line:\n                    idx += 1\n                    continue\n                # If next line is indented, that's description\n                desc_lines = []\n                idx_ = idx + 1\n                while idx_ < plen:\n                    nextline = content_lines[idx_]\n                    if nextline.strip() == '':\n                        desc_lines.append('')\n                        idx_ += 1\n                    else:\n                        indent_level = len(nextline) - len(nextline.lstrip())\n                        if indent_level > 0:\n                            desc_lines.append(nextline.strip())\n                            idx_ += 1\n                        else:\n                            break\n                description = \"\\n\".join(desc_lines).rstrip()\n                exceptions.append({\"type\": line, \"description\": description})\n                idx = idx_\n            doc.raises = exceptions\n\n        else:\n            # Treat other sections as generic text\n            doc.other_sections[section_name] = \"\\n\".join(content_lines).rstrip()\n\n    return doc\n\n\nimport pickle\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\n\nimport inspect\nimport itertools\nimport re\nimport typing as T\n\nfrom docstring_parser.common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\n\n\ndef _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)\n\n\ndef _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string\n\n\nKV_REGEX = re.compile(r\"^[^\\s].*$\", flags=re.M)\n\nPARAM_KEY_REGEX = re.compile(r\"^(?P<name>.*?)(?:\\s*:\\s*(?P<type>.*?))?$\")\n\nPARAM_OPTIONAL_REGEX = re.compile(r\"(?P<type>.*?)(?:, optional|\\(optional\\))$\")\n\nPARAM_DEFAULT_REGEX = re.compile(\n    r\"[Dd]efault(?: is | = |: |s to |)\\s*(?P<value>[\\w\\-\\.]+)\"\n)\n\nRETURN_KEY_REGEX = re.compile(r\"^(?:(?P<name>.*?)\\s*:\\s*)?(?P<type>.*?)$\")\n\n\nclass Section:\n    \"\"\"Numpydoc section parser.\n\n    :param title: section title. For most sections, this is a heading like\n                  \"Parameters\" which appears on its own line, underlined by\n                  en-dashes ('-') on the following line.\n    :param key: meta key string. In the parsed ``DocstringMeta`` instance this\n                will be the first element of the ``args`` attribute list.\n    \"\"\"\n\n    def __init__(self, title: str, key: str) -> None:\n        self.title = title\n        self.key = key\n\n    @property\n    def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))\n\n\nclass _KVSection(Section):\n    \"\"\"Base parser for numpydoc sections with key-value syntax.\n\n    E.g. sections that look like this:\n        key\n            value\n        key2 : type\n            values can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringMeta:\n        pass\n\n    def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )\n\n\nclass _SphinxSection(Section):\n    \"\"\"Base parser for numpydoc sections with sphinx-style syntax.\n\n    E.g. sections that look like this:\n        .. title:: something\n            possibly over multiple lines\n    \"\"\"\n\n    @property\n    def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)\n\n\nclass ParamSection(_KVSection):\n    \"\"\"Parser for numpydoc parameter sections.\n\n    E.g. any section that looks like this:\n        arg_name\n            arg_description\n        arg_2 : type, optional\n            descriptions can also span...\n            ... multiple lines\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n\nclass RaisesSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        ValueError\n            A description of what might raise ValueError\n    \"\"\"\n\n    def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )\n\n\nclass ReturnsSection(_KVSection):\n    \"\"\"Parser for numpydoc raises sections.\n\n    E.g. any section that looks like this:\n        return_name : type\n            A description of this returned value\n        another_type\n            Return names are optional, types are required\n    \"\"\"\n\n    is_generator = False\n\n    def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )\n\n\nclass YieldsSection(ReturnsSection):\n    \"\"\"Parser for numpydoc generator \"yields\" sections.\"\"\"\n\n    is_generator = True\n\n\nclass DeprecationSection(_SphinxSection):\n    \"\"\"Parser for numpydoc \"deprecation warning\" sections.\"\"\"\n\n    def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )\n\n\nDEFAULT_SECTIONS = [\n    ParamSection(\"Parameters\", \"param\"),\n    ParamSection(\"Params\", \"param\"),\n    ParamSection(\"Arguments\", \"param\"),\n    ParamSection(\"Args\", \"param\"),\n    ParamSection(\"Other Parameters\", \"other_param\"),\n    ParamSection(\"Other Params\", \"other_param\"),\n    ParamSection(\"Other Arguments\", \"other_param\"),\n    ParamSection(\"Other Args\", \"other_param\"),\n    ParamSection(\"Receives\", \"receives\"),\n    ParamSection(\"Receive\", \"receives\"),\n    RaisesSection(\"Raises\", \"raises\"),\n    RaisesSection(\"Raise\", \"raises\"),\n    RaisesSection(\"Warns\", \"warns\"),\n    RaisesSection(\"Warn\", \"warns\"),\n    ParamSection(\"Attributes\", \"attribute\"),\n    ParamSection(\"Attribute\", \"attribute\"),\n    ReturnsSection(\"Returns\", \"returns\"),\n    ReturnsSection(\"Return\", \"returns\"),\n    YieldsSection(\"Yields\", \"yields\"),\n    YieldsSection(\"Yield\", \"yields\"),\n    Section(\"Examples\", \"examples\"),\n    Section(\"Example\", \"examples\"),\n    Section(\"Warnings\", \"warnings\"),\n    Section(\"Warning\", \"warnings\"),\n    Section(\"See Also\", \"see_also\"),\n    Section(\"Related\", \"see_also\"),\n    Section(\"Notes\", \"notes\"),\n    Section(\"Note\", \"notes\"),\n    Section(\"References\", \"references\"),\n    Section(\"Reference\", \"references\"),\n    DeprecationSection(\"deprecated\", \"deprecation\"),\n]\n\n\nclass NumpydocParser:\n    def __init__(self, sections: T.Optional[T.Dict[str, Section]] = None):\n        \"\"\"Setup sections.\n\n        :param sections: Recognized sections or None to defaults.\n        \"\"\"\n        sections = sections or DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self._setup()\n\n    def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    import re\n    from collections import defaultdict\n    from dataclasses import dataclass, field\n\n    @dataclass\n    class Section:\n        title: str\n        content: list = field(default_factory=list)\n        \n    @dataclass\n    class Docstring:\n        short_summary: str = \"\"\n        extended_summary: str = \"\"\n        parameters: list = field(default_factory=list)\n        returns: list = field(default_factory=list)\n        raises: list = field(default_factory=list)\n        examples: str = \"\"\n        other_sections: dict = field(default_factory=dict)\n\n    def clean_lines(lines):\n        # Remove trailing and leading blank lines\n        while lines and lines[0].strip() == \"\":\n            lines.pop(0)\n        while lines and lines[-1].strip() == \"\":\n            lines.pop()\n        return lines\n\n    lines = text.expandtabs().splitlines()\n    lines = clean_lines(lines)\n\n    doc = Docstring()\n\n    # If docstring is empty\n    if not lines:\n        return doc\n\n    # Split docstring into sections by headers (headers are lines like 'Parameters', 'Returns', followed by dashes)\n    # Create a list of (section_title, section_lines)\n    section_titles = set([\n        \"Parameters\", \"Returns\", \"Yields\", \"Raises\", \"Examples\",\n        \"Attributes\", \"References\", \"Notes\", \"Warnings\"\n    ])\n\n    # Identify indices of section headers\n    headers = []\n    for i in range(len(lines) - 1):\n        # Header line followed by a line of dashes or equals\n        if lines[i].strip() in section_titles and re.match(r'^[-=]{3,}\\s*$', lines[i+1]):\n            headers.append(i)\n\n    # If no headers, treat entire docstring as short + extended summary\n    if not headers:\n        # Separate short and extended summary by first blank line\n        try:\n            blank_index = lines.index(\"\")\n            doc.short_summary = ' '.join([line.strip() for line in lines[:blank_index]])\n            doc.extended_summary = '\\n'.join(lines[blank_index+1:]).strip()\n        except ValueError:\n            doc.short_summary = '\\n'.join(lines).strip()\n        return doc\n\n    # Manage sections\n    # We'll use a dict of section_title -> lines\n    sections = defaultdict(list)\n    # short summary is everything before first header\n    doc.short_summary = ' '.join(line.strip() for line in lines[:headers[0]]).strip()\n\n    # extended summary is lines between short summary and first header if separated by extra blank lines\n    # Let's assume extended summary is blank line separated after short summary and before first header\n    # For that, we look between the last line of short summary and header start\n    # But short summary is condensed already, so just skip\n\n    # For each header, get its content until next header or end of lines\n    for i, start_index in enumerate(headers):\n        title = lines[start_index].strip()\n        # content lines start after the underline (start_index+2)\n        start_content = start_index + 2\n        if i + 1 < len(headers):\n            end_content = headers[i+1]\n        else:\n            end_content = len(lines)\n        content_lines = lines[start_content:end_content]\n        sections[title].extend(content_lines)\n\n    # Parse Parameters section\n    def parse_params(param_lines):\n        params = []\n        param_name_re = re.compile(r'^(\\w+)(\\s*:\\s*[\\w,\\s\\[\\]?\\.]+)?\\s*(.*)$')\n        current_param = None\n        for line in param_lines:\n            if not line.strip():\n                continue\n            # Detect parameter line: starts with name\n            match = param_name_re.match(line)\n            if match and not line.startswith(' '):\n                if current_param:\n                    params.append(current_param)\n                name = match.group(1)\n                type_ = match.group(2)[1:].strip() if match.group(2) else \"\"\n                desc = match.group(3).strip()\n                current_param = {\"name\": name, \"type\": type_, \"desc\": desc}\n            else:\n                # continuation line of description\n                if current_param:\n                    current_param['desc'] += ' ' + line.strip()\n        if current_param:\n            params.append(current_param)\n        return params\n\n    # Parse Returns or Yields section (similar structure)\n    def parse_returns(ret_lines):\n        returns = []\n        ret_name_re = re.compile(r'^(\\w+)?(\\s*:\\s*[\\w,\\s\\[\\]?\\.]+)?\\s*(.*)$')\n        current_ret = None\n        for line in ret_lines:\n            if not line.strip():\n                continue\n            # first non-indented line likely a return line\n            if not line.startswith(' '):\n                match = ret_name_re.match(line)\n                if current_ret:\n                    returns.append(current_ret)\n                name = match.group(1) if match else None\n                type_ = match.group(2)[1:].strip() if (match and match.group(2)) else \"\"\n                desc = match.group(3).strip() if match else line.strip()\n                current_ret = {\"name\": name, \"type\": type_, \"desc\": desc}\n            else:\n                if current_ret:\n                    current_ret['desc'] += ' ' + line.strip()\n        if current_ret:\n            returns.append(current_ret)\n        return returns\n\n    # Parse Raises section\n    def parse_raises(raise_lines):\n        raises = []\n        # Format: ErrorName: description\n        err_re = re.compile(r'^(\\w+)\\s*:\\s*(.*)$')\n        current_err = None\n        for line in raise_lines:\n            if not line.strip():\n                continue\n            if not line.startswith(' '):\n                m = err_re.match(line)\n                if current_err:\n                    raises.append(current_err)\n                if m:\n                    current_err = {\"error\": m.group(1), \"desc\": m.group(2).strip()}\n                else:\n                    current_err = {\"error\": line.strip(), \"desc\": \"\"}\n            else:\n                if current_err:\n                    current_err['desc'] += ' ' + line.strip()\n        if current_err:\n            raises.append(current_err)\n        return raises\n\n    # Now populate doc components from sections dict\n    if \"Parameters\" in sections:\n        doc.parameters = parse_params(sections[\"Parameters\"])\n\n    if \"Returns\" in sections:\n        doc.returns = parse_returns(sections[\"Returns\"])\n\n    if \"Yields\" in sections:\n        # treat yields same as returns\n        doc.returns = parse_returns(sections[\"Yields\"])\n\n    if \"Raises\" in sections:\n        doc.raises = parse_raises(sections[\"Raises\"])\n\n    if \"Examples\" in sections:\n        doc.examples = '\\n'.join(sections[\"Examples\"]).strip()\n\n    # Other sections captured as text blobs\n    other_keys = set(sections.keys()) - set([\"Parameters\", \"Returns\", \"Yields\", \"Raises\", \"Examples\"])\n    for key in other_keys:\n        doc.other_sections[key] = '\\n'.join(sections[key]).strip()\n\n    # Try to infer extended summary (anything between short summary and first header)\n    first_header_line = headers[0]\n    summary_lines = lines[:first_header_line]\n    # There might be blank lines separating short summary from extended summary\n    # Re-assemble extended summary after skipping short summary line(s)\n    # Short summary joined short lines, so find where blank line after short summary occurs\n    # We'll attempt to find blank line separating short summary and extended summary\n    blank_line_index = None\n    for idx, line in enumerate(summary_lines):\n        if line.strip() == \"\":\n            blank_line_index = idx\n            break\n\n    if blank_line_index is not None and blank_line_index+1 < len(summary_lines):\n        extended_summary_lines = summary_lines[blank_line_index+1:]\n        doc.extended_summary = '\\n'.join(extended_summary_lines).strip()\n\n    return doc\n\n\nimport pickle\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)\ntest_22()\n\n\n"]}
