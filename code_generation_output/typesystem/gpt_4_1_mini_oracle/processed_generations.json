{"task_id": 330, "project": "test-apps/typesystem", "module": "typesystem.tokenize.tokenize_yaml", "predictions": ["import typing\n\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.base import ValidationError\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[\"Field\", typing.Type[\"Schema\"]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except Exception as parse_error:\n        # ParseError inherits Exception, output with error messages\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()", "import typing\n\nfrom typesystem.base import ValidationError, ParseError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token, DictToken, ListToken, ScalarToken\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[typing.Any, typing.Type[typing.Any]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except ParseError as exc:\n        # Return None for value and a list with the parse error message\n        return None, [exc]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as exc:\n        return None, exc.messages()", "import typing\n\nfrom typesystem.base import ValidationError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Token, typing.Type[typing.Any]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except Exception as parse_error:\n        # parse_error should be a ParseError with position info\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()", "import typing\n\nfrom typesystem.base import ValidationError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[typing.Any, typing.Type[typing.Any]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except Exception as parse_error:\n        # On parse failure, return None value and a list of one Message describing the parse error.\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        # Return None value and positional error messages on validation errors.\n        return None, validation_error.messages()", "import typing\n\nfrom typesystem.base import ValidationError, ParseError, Message\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.tokens import Token\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except ParseError as parse_error:\n        return None, [Message(text=parse_error.text, code=parse_error.code, start_position=parse_error.position, end_position=None)]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\nimport typing\n\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.base import ValidationError\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[\"Field\", typing.Type[\"Schema\"]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except Exception as parse_error:\n        # ParseError inherits Exception, output with error messages\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\nimport typing\n\nfrom typesystem.base import ValidationError, ParseError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token, DictToken, ListToken, ScalarToken\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[typing.Any, typing.Type[typing.Any]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except ParseError as exc:\n        # Return None for value and a list with the parse error message\n        return None, [exc]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as exc:\n        return None, exc.messages()\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\nimport typing\n\nfrom typesystem.base import ValidationError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Token, typing.Type[typing.Any]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except Exception as parse_error:\n        # parse_error should be a ParseError with position info\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\nimport typing\n\nfrom typesystem.base import ValidationError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[typing.Any, typing.Type[typing.Any]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except Exception as parse_error:\n        # On parse failure, return None value and a list of one Message describing the parse error.\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        # Return None value and positional error messages on validation errors.\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\nimport typing\n\nfrom typesystem.base import ValidationError, ParseError, Message\nfrom typesystem.tokenize.tokenize_yaml import tokenize_yaml\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.tokens import Token\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_yaml(content)\n    except ParseError as parse_error:\n        return None, [Message(text=parse_error.text, code=parse_error.code, start_position=parse_error.position, end_position=None)]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n"]}
{"task_id": 331, "project": "test-apps/typesystem", "module": "typesystem.json_schema", "predictions": ["from typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if not type_strings:\n        # No explicit types other than maybe null, return Any or a nullable Any equivalent\n        return from_json_schema_type(data, \"string\", allow_null, definitions)\n\n    fields = [from_json_schema_type(data, type_string, allow_null, definitions) for type_string in sorted(type_strings)]\n\n    if len(fields) == 1:\n        return fields[0]\n\n    return Union(fields, allow_null=allow_null)", "from typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\nfrom typesystem.schemas import SchemaDefinitions\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if not type_strings:\n        # If no types, allow any type including possibly null.\n        return from_json_schema_type(data, \"string\", allow_null=True, definitions=definitions)\n\n    fields = []\n    for type_str in sorted(type_strings):\n        field = from_json_schema_type(data, type_str, allow_null=False, definitions=definitions)\n        fields.append(field)\n\n    if allow_null:\n        # Wrap in Union with None (null) allowed.\n        fields.append(from_json_schema_type({}, \"null\", allow_null=False, definitions=definitions))\n\n    if len(fields) == 1:\n        return fields[0]\n\n    return Union(fields)", "from typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\nfrom typesystem.schemas import SchemaDefinitions\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if not type_strings:\n        # No types specified (other than maybe null),\n        # treat as Any with allow_null as indicated\n        from typesystem.fields import Any\n        return Any(allow_null=allow_null)\n\n    fields = [\n        from_json_schema_type(data, type_string, allow_null=False, definitions=definitions)\n        for type_string in sorted(type_strings)\n    ]\n\n    if len(fields) == 1:\n        field = fields[0]\n        if allow_null:\n            # Wrap field to allow null if not already allowed\n            return Union([field, fields[0].__class__(allow_null=True)])\n        else:\n            return field\n\n    # Multiple types: build a Union field\n    if allow_null:\n        # Add a NoneType-compatible field to represent null allowance\n        from typesystem.fields import Const\n        fields.append(Const(None))\n\n    return Union(fields)", "from typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    # If no type_strings, treat as Any\n    if not type_strings:\n        # No specific type; the JSON Schema type could be anything\n        # (this shouldn't normally happen as get_valid_types sets a default set)\n        return Field()\n\n    # Build a list of Field instances for each type string.\n    fields = [from_json_schema_type(data, type_string, allow_null=False, definitions=definitions)\n              for type_string in type_strings]\n\n    # If we allow null as well, add a Const(None) field OR handle allow_null param per type.\n    # The from_json_schema_type already takes allow_null param, and we've passed allow_null=False,\n    # so we need to handle nullability in the union.\n\n    if allow_null:\n        # Add None type to the union\n        from typesystem.fields import Const\n        fields.append(Const(None))\n\n    if len(fields) == 1:\n        return fields[0]\n    else:\n        return Union(fields, allow_null=False)", "from typing import Set\nfrom typesystem.fields import Field\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    fields = []\n    for type_string in sorted(type_strings):\n        field = from_json_schema_type(data, type_string, allow_null, definitions)\n        fields.append(field)\n\n    if not fields:\n        # No explicit types, fallback to Any (like in from_json_schema)\n        from typesystem.fields import Any\n        return Any()\n\n    if len(fields) == 1:\n        return fields[0]\n\n    from typesystem.fields import Union\n    return Union(fields, allow_null=allow_null)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\nfrom typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if not type_strings:\n        # No explicit types other than maybe null, return Any or a nullable Any equivalent\n        return from_json_schema_type(data, \"string\", allow_null, definitions)\n\n    fields = [from_json_schema_type(data, type_string, allow_null, definitions) for type_string in sorted(type_strings)]\n\n    if len(fields) == 1:\n        return fields[0]\n\n    return Union(fields, allow_null=allow_null)\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\nfrom typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\nfrom typesystem.schemas import SchemaDefinitions\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if not type_strings:\n        # If no types, allow any type including possibly null.\n        return from_json_schema_type(data, \"string\", allow_null=True, definitions=definitions)\n\n    fields = []\n    for type_str in sorted(type_strings):\n        field = from_json_schema_type(data, type_str, allow_null=False, definitions=definitions)\n        fields.append(field)\n\n    if allow_null:\n        # Wrap in Union with None (null) allowed.\n        fields.append(from_json_schema_type({}, \"null\", allow_null=False, definitions=definitions))\n\n    if len(fields) == 1:\n        return fields[0]\n\n    return Union(fields)\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\nfrom typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\nfrom typesystem.schemas import SchemaDefinitions\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if not type_strings:\n        # No types specified (other than maybe null),\n        # treat as Any with allow_null as indicated\n        from typesystem.fields import Any\n        return Any(allow_null=allow_null)\n\n    fields = [\n        from_json_schema_type(data, type_string, allow_null=False, definitions=definitions)\n        for type_string in sorted(type_strings)\n    ]\n\n    if len(fields) == 1:\n        field = fields[0]\n        if allow_null:\n            # Wrap field to allow null if not already allowed\n            return Union([field, fields[0].__class__(allow_null=True)])\n        else:\n            return field\n\n    # Multiple types: build a Union field\n    if allow_null:\n        # Add a NoneType-compatible field to represent null allowance\n        from typesystem.fields import Const\n        fields.append(Const(None))\n\n    return Union(fields)\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\nfrom typing import Set\nfrom typesystem.fields import Field, Union\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    # If no type_strings, treat as Any\n    if not type_strings:\n        # No specific type; the JSON Schema type could be anything\n        # (this shouldn't normally happen as get_valid_types sets a default set)\n        return Field()\n\n    # Build a list of Field instances for each type string.\n    fields = [from_json_schema_type(data, type_string, allow_null=False, definitions=definitions)\n              for type_string in type_strings]\n\n    # If we allow null as well, add a Const(None) field OR handle allow_null param per type.\n    # The from_json_schema_type already takes allow_null param, and we've passed allow_null=False,\n    # so we need to handle nullability in the union.\n\n    if allow_null:\n        # Add None type to the union\n        from typesystem.fields import Const\n        fields.append(Const(None))\n\n    if len(fields) == 1:\n        return fields[0]\n    else:\n        return Union(fields, allow_null=False)\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\nfrom typing import Set\nfrom typesystem.fields import Field\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    fields = []\n    for type_string in sorted(type_strings):\n        field = from_json_schema_type(data, type_string, allow_null, definitions)\n        fields.append(field)\n\n    if not fields:\n        # No explicit types, fallback to Any (like in from_json_schema)\n        from typesystem.fields import Any\n        return Any()\n\n    if len(fields) == 1:\n        return fields[0]\n\n    from typesystem.fields import Union\n    return Union(fields, allow_null=allow_null)\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n"]}
{"task_id": 332, "project": "test-apps/typesystem", "module": "typesystem.json_schema", "predictions": ["import typing\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    This function examines the \"type\" property of a JSON Schema dict and determines\n    which types are allowed and whether null is allowed (via explicit \"null\" type or absent).\n    \n    Returns:\n        - type_strings: A set of type strings excluding \"null\"\n        - allow_null: A boolean indicating if null is allowed\n    \"\"\"\n    type_field = data.get(\"type\")\n\n    # If no type is specified, JSON Schema allows anything - treat as empty set and allow null True\n    if type_field is None:\n        return set(), True\n\n    # Normalize input: type may be a string or a list of strings\n    if isinstance(type_field, str):\n        types = {type_field}\n    elif isinstance(type_field, list):\n        types = set(type_field)\n    else:\n        # Unexpected type, assume no types allowed, null allowed False (safe fallback)\n        return set(), False\n\n    allow_null = \"null\" in types\n    type_strings = types - {\"null\"}\n\n    return type_strings, allow_null", "from typing import Set, Tuple\n\ndef get_valid_types(data: dict) -> Tuple[Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    This function interprets the \"type\" keyword in a JSON Schema data dictionary.\n    The \"type\" can be a string or an array of strings indicating allowed types.\n    If \"null\" is included in the types, then allow_null is True and \"null\" is removed\n    from the returned type_strings set.\n\n    If \"type\" is not present, the function returns an empty set and allow_null=False.\n\n    Examples:\n      - {\"type\": \"string\"} => ({\"string\"}, False)\n      - {\"type\": [\"string\", \"null\"]} => ({\"string\"}, True)\n      - {\"type\": [\"null\"]} => (set(), True)\n      - {} => (set(), False)\n    \"\"\"\n    type_value = data.get(\"type\")\n\n    if type_value is None:\n        return set(), False\n\n    if isinstance(type_value, str):\n        if type_value == \"null\":\n            return set(), True\n        else:\n            return {type_value}, False\n\n    # type_value is expected to be a list of strings\n    if isinstance(type_value, list):\n        type_strings = set(t for t in type_value if t != \"null\")\n        allow_null = \"null\" in type_value\n        return type_strings, allow_null\n\n    # If type_value is neither str nor list, fallback safe\n    # (though JSON Schema doesn't define that case)\n    return set(), False", "import typing\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    type_value = data.get(\"type\")\n    allow_null = False\n    type_strings: typing.Set[str] = set()\n\n    if isinstance(type_value, str):\n        # Single type string\n        if type_value == \"null\":\n            allow_null = True\n        else:\n            type_strings.add(type_value)\n    elif isinstance(type_value, list):\n        # List of types, could include \"null\"\n        for t in type_value:\n            if t == \"null\":\n                allow_null = True\n            else:\n                # Only add if string type (defensive)\n                if isinstance(t, str):\n                    type_strings.add(t)\n    # If no \"type\" key or it's neither str nor list, type_strings is empty and allow_null is False\n\n    return type_strings, allow_null", "import typing\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    The first element is a set of valid JSON Schema type strings extracted from the\n    \"type\" property of the data. The \"type\" value may be a string or a list of strings.\n\n    The second element is a boolean `allow_null` which is True if \"null\" is included\n    in the type(s), False otherwise.\n    \"\"\"\n    type_value = data.get(\"type\")\n    if type_value is None:\n        # No \"type\" means all types allowed, so no explicit types and no null restriction.\n        return set(), False\n\n    if isinstance(type_value, str):\n        # Single type string\n        if type_value == \"null\":\n            return set(), True\n        else:\n            return {type_value}, False\n\n    if isinstance(type_value, list):\n        # Multiple types\n        types_set = set()\n        allow_null = False\n        for t in type_value:\n            if t == \"null\":\n                allow_null = True\n            else:\n                types_set.add(t)\n        return types_set, allow_null\n\n    # If \"type\" is not str or list (invalid), treat as no types allowed.\n    return set(), False", "import typing\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    - `type_strings`: a set of type strings derived from the \"type\" property in the JSON Schema data.\n      For example, if `data[\"type\"]` is \"string\", it returns {\"string\"}.\n      If `data[\"type\"]` is [\"string\", \"null\"], it returns {\"string\", \"null\"}.\n      If no \"type\" key present, returns empty set.\n    - `allow_null`: a boolean set to True if \"null\" is included in the type(s), False otherwise.\n    \"\"\"\n    type_value = data.get(\"type\")\n\n    # No \"type\" field means no type constraints, so return empty set and False\n    if type_value is None:\n        return set(), False\n\n    if isinstance(type_value, str):\n        types = {type_value}\n    elif isinstance(type_value, list):\n        types = set(type_value)\n    else:\n        # Unexpected type of \"type\" property, return empty set\n        return set(), False\n\n    allow_null = \"null\" in types\n    # Exclude 'null' from the returned set since allow_null is returned separately\n    types.discard(\"null\")\n\n    return types, allow_null"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\nimport typing\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    This function examines the \"type\" property of a JSON Schema dict and determines\n    which types are allowed and whether null is allowed (via explicit \"null\" type or absent).\n    \n    Returns:\n        - type_strings: A set of type strings excluding \"null\"\n        - allow_null: A boolean indicating if null is allowed\n    \"\"\"\n    type_field = data.get(\"type\")\n\n    # If no type is specified, JSON Schema allows anything - treat as empty set and allow null True\n    if type_field is None:\n        return set(), True\n\n    # Normalize input: type may be a string or a list of strings\n    if isinstance(type_field, str):\n        types = {type_field}\n    elif isinstance(type_field, list):\n        types = set(type_field)\n    else:\n        # Unexpected type, assume no types allowed, null allowed False (safe fallback)\n        return set(), False\n\n    allow_null = \"null\" in types\n    type_strings = types - {\"null\"}\n\n    return type_strings, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\nfrom typing import Set, Tuple\n\ndef get_valid_types(data: dict) -> Tuple[Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    This function interprets the \"type\" keyword in a JSON Schema data dictionary.\n    The \"type\" can be a string or an array of strings indicating allowed types.\n    If \"null\" is included in the types, then allow_null is True and \"null\" is removed\n    from the returned type_strings set.\n\n    If \"type\" is not present, the function returns an empty set and allow_null=False.\n\n    Examples:\n      - {\"type\": \"string\"} => ({\"string\"}, False)\n      - {\"type\": [\"string\", \"null\"]} => ({\"string\"}, True)\n      - {\"type\": [\"null\"]} => (set(), True)\n      - {} => (set(), False)\n    \"\"\"\n    type_value = data.get(\"type\")\n\n    if type_value is None:\n        return set(), False\n\n    if isinstance(type_value, str):\n        if type_value == \"null\":\n            return set(), True\n        else:\n            return {type_value}, False\n\n    # type_value is expected to be a list of strings\n    if isinstance(type_value, list):\n        type_strings = set(t for t in type_value if t != \"null\")\n        allow_null = \"null\" in type_value\n        return type_strings, allow_null\n\n    # If type_value is neither str nor list, fallback safe\n    # (though JSON Schema doesn't define that case)\n    return set(), False\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\nimport typing\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    type_value = data.get(\"type\")\n    allow_null = False\n    type_strings: typing.Set[str] = set()\n\n    if isinstance(type_value, str):\n        # Single type string\n        if type_value == \"null\":\n            allow_null = True\n        else:\n            type_strings.add(type_value)\n    elif isinstance(type_value, list):\n        # List of types, could include \"null\"\n        for t in type_value:\n            if t == \"null\":\n                allow_null = True\n            else:\n                # Only add if string type (defensive)\n                if isinstance(t, str):\n                    type_strings.add(t)\n    # If no \"type\" key or it's neither str nor list, type_strings is empty and allow_null is False\n\n    return type_strings, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\nimport typing\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    The first element is a set of valid JSON Schema type strings extracted from the\n    \"type\" property of the data. The \"type\" value may be a string or a list of strings.\n\n    The second element is a boolean `allow_null` which is True if \"null\" is included\n    in the type(s), False otherwise.\n    \"\"\"\n    type_value = data.get(\"type\")\n    if type_value is None:\n        # No \"type\" means all types allowed, so no explicit types and no null restriction.\n        return set(), False\n\n    if isinstance(type_value, str):\n        # Single type string\n        if type_value == \"null\":\n            return set(), True\n        else:\n            return {type_value}, False\n\n    if isinstance(type_value, list):\n        # Multiple types\n        types_set = set()\n        allow_null = False\n        for t in type_value:\n            if t == \"null\":\n                allow_null = True\n            else:\n                types_set.add(t)\n        return types_set, allow_null\n\n    # If \"type\" is not str or list (invalid), treat as no types allowed.\n    return set(), False\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\nimport typing\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n\n    - `type_strings`: a set of type strings derived from the \"type\" property in the JSON Schema data.\n      For example, if `data[\"type\"]` is \"string\", it returns {\"string\"}.\n      If `data[\"type\"]` is [\"string\", \"null\"], it returns {\"string\", \"null\"}.\n      If no \"type\" key present, returns empty set.\n    - `allow_null`: a boolean set to True if \"null\" is included in the type(s), False otherwise.\n    \"\"\"\n    type_value = data.get(\"type\")\n\n    # No \"type\" field means no type constraints, so return empty set and False\n    if type_value is None:\n        return set(), False\n\n    if isinstance(type_value, str):\n        types = {type_value}\n    elif isinstance(type_value, list):\n        types = set(type_value)\n    else:\n        # Unexpected type of \"type\" property, return empty set\n        return set(), False\n\n    allow_null = \"null\" in types\n    # Exclude 'null' from the returned set since allow_null is returned separately\n    types.discard(\"null\")\n\n    return types, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n"]}
{"task_id": 333, "project": "test-apps/typesystem", "module": "typesystem.tokenize.tokenize_json", "predictions": ["import typing\nfrom typesystem.base import ValidationError, ParseError, Message\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token: Token = tokenize_json(content)\n    except ParseError as parse_error:\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        # Return the list of positional error messages\n        return None, validation_error.messages()", "import typing\n\nfrom typesystem.base import ValidationError, ParseError, Message\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\nfrom typesystem.tokenize.positional_validation import validate_with_positions\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_json(content)\n    except ParseError as exc:\n        return None, [Message(text=exc.text, code=exc.code, start_position=exc.position, end_position=exc.position)]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as exc:\n        return None, exc.messages", "import typing\nfrom typesystem.base import ValidationError, ParseError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_json(content)\n    except ParseError as parse_error:\n        # On parsing failure, return (None, [parse_error])\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()", "import typing\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\nfrom typesystem.base import ValidationError, ParseError\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_json(content)\n    except ParseError as parse_error:\n        # Return None for value and the parse error message(s) in a list\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        # Return None for value and the validation error messages in a list\n        return None, validation_error.messages()", "import typing\nfrom typesystem.base import ValidationError, ParseError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokenize_json import tokenize_json\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        # Tokenize the content into a positional Token representation\n        token = tokenize_json(content)\n\n        # Validate the token's value using the provided validator\n        value = validate_with_positions(token=token, validator=validator)\n        # If no error, return value and None for errors\n        return value, None\n\n    except (ParseError, ValidationError) as exc:\n        # If there is a parse or validation error, return None for value and the error messages\n        return None, exc.messages()"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\nimport typing\nfrom typesystem.base import ValidationError, ParseError, Message\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token: Token = tokenize_json(content)\n    except ParseError as parse_error:\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        # Return the list of positional error messages\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\nimport typing\n\nfrom typesystem.base import ValidationError, ParseError, Message\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\nfrom typesystem.tokenize.positional_validation import validate_with_positions\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_json(content)\n    except ParseError as exc:\n        return None, [Message(text=exc.text, code=exc.code, start_position=exc.position, end_position=exc.position)]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as exc:\n        return None, exc.messages\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\nimport typing\nfrom typesystem.base import ValidationError, ParseError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_json(content)\n    except ParseError as parse_error:\n        # On parsing failure, return (None, [parse_error])\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\nimport typing\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import Token\nfrom typesystem.tokenize.tokenize_json import tokenize_json\nfrom typesystem.base import ValidationError, ParseError\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        token = tokenize_json(content)\n    except ParseError as parse_error:\n        # Return None for value and the parse error message(s) in a list\n        return None, [parse_error]\n\n    try:\n        value = validate_with_positions(token=token, validator=validator)\n        return value, []\n    except ValidationError as validation_error:\n        # Return None for value and the validation error messages in a list\n        return None, validation_error.messages()\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\nimport typing\nfrom typesystem.base import ValidationError, ParseError\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokenize_json import tokenize_json\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    try:\n        # Tokenize the content into a positional Token representation\n        token = tokenize_json(content)\n\n        # Validate the token's value using the provided validator\n        value = validate_with_positions(token=token, validator=validator)\n        # If no error, return value and None for errors\n        return value, None\n\n    except (ParseError, ValidationError) as exc:\n        # If there is a parse or validation error, return None for value and the error messages\n        return None, exc.messages()\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n"]}
