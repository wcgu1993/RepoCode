{"task_id": 330, "project": "test-apps/typesystem", "module": "typesystem.tokenize.tokenize_yaml", "predictions": ["def validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import ruamel.yaml\n    from ruamel.yaml.parser import ParserError\n    from ruamel.yaml.scanner import ScannerError\n\n    yaml = ruamel.yaml.YAML(typ='safe')\n    try:\n        data = yaml.load(content)\n    except (ScannerError, ParserError) as e:\n        # Return no data and an error message with position\n        mark = getattr(e, 'problem_mark', None)\n        if mark is not None:\n            err_msg = f\"YAML parse error at line {mark.line + 1} column {mark.column + 1}: {e.problem}\"\n        else:\n            err_msg = f\"YAML parse error: {str(e)}\"\n        return None, [err_msg]\n\n    # Validate data using validator\n    # validator can be a Field instance or Schema class from marshmallow\n    from marshmallow import ValidationError\n    try:\n        if isinstance(validator, Field):\n            result = validator.deserialize(data)\n        else:\n            # Schema class or instance\n            if isinstance(validator, type):\n                # Schema class, instantiate\n                schema = validator()\n            else:\n                schema = validator\n            result = schema.load(data)\n        return result, None\n    except ValidationError as err:\n        # err.messages is a dict of validation errors with locations\n        # Flatten errors to position-marked strings if possible, else just messages\n        errors = []\n\n        def _format_errors(d, prefix=''):\n            if isinstance(d, dict):\n                for key, val in d.items():\n                    new_prefix = f\"{prefix}.{key}\" if prefix else str(key)\n                    _format_errors(val, new_prefix)\n            elif isinstance(d, list):\n                for i, item in enumerate(d):\n                    new_prefix = f\"{prefix}[{i}]\"\n                    _format_errors(item, new_prefix)\n            else:\n                # d is str or another error message\n                errors.append(f\"{prefix}: {d}\" if prefix else f\"{d}\")\n\n        _format_errors(err.messages)\n        return None, errors", "def validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import ruamel.yaml\n    from marshmallow import ValidationError\n    \n    yaml = ruamel.yaml.YAML()\n    try:\n        data = yaml.load(content)\n    except ruamel.yaml.YAMLError as e:\n        # Return None value and parse errors as strings\n        return None, [f\"YAML parse error: {str(e)}\"]\n\n    try:\n        if isinstance(validator, Field):\n            # Use the Field's deserialize method\n            value = validator.deserialize(data)\n        else:\n            # Assume validator is a Schema class, instantiate and load\n            schema = validator()\n            value = schema.load(data)\n    except ValidationError as err:\n        # err.messages contains detailed validation errors\n        return None, err.messages\n\n    return value, []", "def validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import typing\n    import ruamel.yaml\n    from marshmallow import Schema, ValidationError, fields as mfields\n\n    yaml = ruamel.yaml.YAML(typ=\"safe\")\n    error_messages = []\n\n    # Load YAML content\n    try:\n        data = yaml.load(content)\n    except ruamel.yaml.YAMLError as ye:\n        mark = getattr(ye, 'problem_mark', None)\n        if mark:\n            msg = f\"YAML parse error at line {mark.line+1}, column {mark.column+1}: {ye.problem}\"\n        else:\n            msg = f\"YAML parse error: {str(ye)}\"\n        return None, [msg]\n\n    # Determine schema to use\n    if isinstance(validator, mfields.Field):\n        # Wrap field in a Schema for validation\n        class _WrapperSchema(Schema):\n            root = validator\n        schema = _WrapperSchema()\n        to_validate = {'root': data}\n    elif isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n        to_validate = data\n    else:\n        raise TypeError(\"validator must be a marshmallow Field instance or a Schema subclass\")\n\n    # Validate loaded data\n    try:\n        value = schema.load(to_validate)\n        if isinstance(validator, mfields.Field):\n            value = value['root']\n        return value, []\n    except ValidationError as ve:\n        # Build positional error messages if possible\n        messages = []\n\n        def _walk_errors(errors, loc=()):\n            for key, val in errors.items():\n                current_loc = loc + (key,)\n                if isinstance(val, dict):\n                    _walk_errors(val, current_loc)\n                elif isinstance(val, list):\n                    for msg in val:\n                        messages.append({'location': current_loc, 'message': msg})\n\n        _walk_errors(ve.normalized_messages())\n\n        # Compose error messages as strings with positional info\n        for em in messages:\n            loc_str = ' -> '.join(str(k) for k in em['location'])\n            error_messages.append(f\"Validation error at {loc_str}: {em['message']}\")\n\n        return None, error_messages", "def validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import typing\n    import yaml\n    from marshmallow import ValidationError\n    from marshmallow.fields import Field\n    from marshmallow.schema import Schema\n\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\")\n\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as exc:\n        # Return None as value and YAML parse error as a string in a list\n        return None, [str(exc)]\n\n    try:\n        if isinstance(validator, Field):\n            value = validator.deserialize(data)\n        elif isinstance(validator, type) and issubclass(validator, Schema):\n            schema = validator()\n            value = schema.load(data)\n        else:\n            raise TypeError(\n                \"validator must be a marshmallow Field instance or a Schema class\"\n            )\n        return value, None\n    except ValidationError as err:\n        # Return None value and list of error messages formatted with location\n        errors = []\n\n        def _format_errors(error_dict, path=None):\n            if path is None:\n                path = []\n            if isinstance(error_dict, dict):\n                for key, val in error_dict.items():\n                    _format_errors(val, path + [str(key)])\n            elif isinstance(error_dict, list):\n                for item in error_dict:\n                    if isinstance(item, dict):\n                        _format_errors(item, path)\n                    else:\n                        pos = \" -> \".join(path) if path else \"<root>\"\n                        errors.append(f\"{pos}: {item}\")\n\n        _format_errors(err.normalized_messages())\n\n        return None, errors", "def validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import yaml\n    import typing\n    from marshmallow import ValidationError, Schema, fields\n    from marshmallow.fields import Field\n\n    # Normalize content to string if bytes\n    if isinstance(content, bytes):\n        content = content.decode('utf-8')\n\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as e:\n        # Return None for value with a list of YAML parsing errors\n        return None, [str(e)]\n\n    # Determine if validator is a Field or Schema class\n    if isinstance(validator, Field):\n        field = validator\n        schema_cls = type('SingleFieldSchema', (Schema,), {'field': field})\n        schema = schema_cls()\n        try:\n            value = schema.load({'field': data})\n            return value['field'], []\n        except ValidationError as err:\n            return None, err.messages.get('field', err.messages)\n    elif isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n        try:\n            value = schema.load(data)\n            return value, []\n        except ValidationError as err:\n            return None, err.messages\n    else:\n        raise TypeError(\"Validator must be a marshmallow Field instance or a Schema class.\")"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import ruamel.yaml\n    from ruamel.yaml.parser import ParserError\n    from ruamel.yaml.scanner import ScannerError\n\n    yaml = ruamel.yaml.YAML(typ='safe')\n    try:\n        data = yaml.load(content)\n    except (ScannerError, ParserError) as e:\n        # Return no data and an error message with position\n        mark = getattr(e, 'problem_mark', None)\n        if mark is not None:\n            err_msg = f\"YAML parse error at line {mark.line + 1} column {mark.column + 1}: {e.problem}\"\n        else:\n            err_msg = f\"YAML parse error: {str(e)}\"\n        return None, [err_msg]\n\n    # Validate data using validator\n    # validator can be a Field instance or Schema class from marshmallow\n    from marshmallow import ValidationError\n    try:\n        if isinstance(validator, Field):\n            result = validator.deserialize(data)\n        else:\n            # Schema class or instance\n            if isinstance(validator, type):\n                # Schema class, instantiate\n                schema = validator()\n            else:\n                schema = validator\n            result = schema.load(data)\n        return result, None\n    except ValidationError as err:\n        # err.messages is a dict of validation errors with locations\n        # Flatten errors to position-marked strings if possible, else just messages\n        errors = []\n\n        def _format_errors(d, prefix=''):\n            if isinstance(d, dict):\n                for key, val in d.items():\n                    new_prefix = f\"{prefix}.{key}\" if prefix else str(key)\n                    _format_errors(val, new_prefix)\n            elif isinstance(d, list):\n                for i, item in enumerate(d):\n                    new_prefix = f\"{prefix}[{i}]\"\n                    _format_errors(item, new_prefix)\n            else:\n                # d is str or another error message\n                errors.append(f\"{prefix}: {d}\" if prefix else f\"{d}\")\n\n        _format_errors(err.messages)\n        return None, errors\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import ruamel.yaml\n    from marshmallow import ValidationError\n    \n    yaml = ruamel.yaml.YAML()\n    try:\n        data = yaml.load(content)\n    except ruamel.yaml.YAMLError as e:\n        # Return None value and parse errors as strings\n        return None, [f\"YAML parse error: {str(e)}\"]\n\n    try:\n        if isinstance(validator, Field):\n            # Use the Field's deserialize method\n            value = validator.deserialize(data)\n        else:\n            # Assume validator is a Schema class, instantiate and load\n            schema = validator()\n            value = schema.load(data)\n    except ValidationError as err:\n        # err.messages contains detailed validation errors\n        return None, err.messages\n\n    return value, []\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import typing\n    import ruamel.yaml\n    from marshmallow import Schema, ValidationError, fields as mfields\n\n    yaml = ruamel.yaml.YAML(typ=\"safe\")\n    error_messages = []\n\n    # Load YAML content\n    try:\n        data = yaml.load(content)\n    except ruamel.yaml.YAMLError as ye:\n        mark = getattr(ye, 'problem_mark', None)\n        if mark:\n            msg = f\"YAML parse error at line {mark.line+1}, column {mark.column+1}: {ye.problem}\"\n        else:\n            msg = f\"YAML parse error: {str(ye)}\"\n        return None, [msg]\n\n    # Determine schema to use\n    if isinstance(validator, mfields.Field):\n        # Wrap field in a Schema for validation\n        class _WrapperSchema(Schema):\n            root = validator\n        schema = _WrapperSchema()\n        to_validate = {'root': data}\n    elif isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n        to_validate = data\n    else:\n        raise TypeError(\"validator must be a marshmallow Field instance or a Schema subclass\")\n\n    # Validate loaded data\n    try:\n        value = schema.load(to_validate)\n        if isinstance(validator, mfields.Field):\n            value = value['root']\n        return value, []\n    except ValidationError as ve:\n        # Build positional error messages if possible\n        messages = []\n\n        def _walk_errors(errors, loc=()):\n            for key, val in errors.items():\n                current_loc = loc + (key,)\n                if isinstance(val, dict):\n                    _walk_errors(val, current_loc)\n                elif isinstance(val, list):\n                    for msg in val:\n                        messages.append({'location': current_loc, 'message': msg})\n\n        _walk_errors(ve.normalized_messages())\n\n        # Compose error messages as strings with positional info\n        for em in messages:\n            loc_str = ' -> '.join(str(k) for k in em['location'])\n            error_messages.append(f\"Validation error at {loc_str}: {em['message']}\")\n\n        return None, error_messages\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import typing\n    import yaml\n    from marshmallow import ValidationError\n    from marshmallow.fields import Field\n    from marshmallow.schema import Schema\n\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\")\n\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as exc:\n        # Return None as value and YAML parse error as a string in a list\n        return None, [str(exc)]\n\n    try:\n        if isinstance(validator, Field):\n            value = validator.deserialize(data)\n        elif isinstance(validator, type) and issubclass(validator, Schema):\n            schema = validator()\n            value = schema.load(data)\n        else:\n            raise TypeError(\n                \"validator must be a marshmallow Field instance or a Schema class\"\n            )\n        return value, None\n    except ValidationError as err:\n        # Return None value and list of error messages formatted with location\n        errors = []\n\n        def _format_errors(error_dict, path=None):\n            if path is None:\n                path = []\n            if isinstance(error_dict, dict):\n                for key, val in error_dict.items():\n                    _format_errors(val, path + [str(key)])\n            elif isinstance(error_dict, list):\n                for item in error_dict:\n                    if isinstance(item, dict):\n                        _format_errors(item, path)\n                    else:\n                        pos = \" -> \".join(path) if path else \"<root>\"\n                        errors.append(f\"{pos}: {item}\")\n\n        _format_errors(err.normalized_messages())\n\n        return None, errors\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\ntry:\n    import yaml\n    from yaml.loader import SafeLoader\nexcept ImportError:  # pragma: no cover\n    yaml = None  # type: ignore\n    SafeLoader = None  # type: ignore\n\nimport typing\n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\n\ndef _get_position(content: str, index: int) -> Position:\n    return Position(\n        line_no=content.count(\"\\n\", 0, index) + 1,\n        column_no=index - content.rfind(\"\\n\", 0, index),\n        char_index=index,\n    )\n\n\ndef tokenize_yaml(content: typing.Union[str, bytes]) -> Token:\n    assert yaml is not None, \"'pyyaml' must be installed.\"\n\n    if isinstance(content, bytes):\n        str_content = content.decode(\"utf-8\", \"ignore\")\n    else:\n        str_content = content\n\n    if not str_content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    class CustomSafeLoader(SafeLoader):\n        pass\n\n    def construct_mapping(loader: \"yaml.Loader\", node: \"yaml.Node\") -> DictToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        mapping = loader.construct_mapping(node)\n        return DictToken(mapping, start, end - 1, content=str_content)\n\n    def construct_sequence(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ListToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_sequence(node)\n        return ListToken(value, start, end - 1, content=str_content)\n\n    def construct_scalar(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_scalar(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_int(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_int(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_float(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_float(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_bool(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_bool(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    def construct_null(loader: \"yaml.Loader\", node: \"yaml.Node\") -> ScalarToken:\n        start = node.start_mark.index\n        end = node.end_mark.index\n        value = loader.construct_yaml_null(node)\n        return ScalarToken(value, start, end - 1, content=str_content)\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SEQUENCE_TAG, construct_sequence\n    )\n\n    CustomSafeLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_SCALAR_TAG, construct_scalar\n    )\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:int\", construct_int)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:float\", construct_float)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:bool\", construct_bool)\n\n    CustomSafeLoader.add_constructor(\"tag:yaml.org,2002:null\", construct_null)\n\n    try:\n        return yaml.load(str_content, CustomSafeLoader)\n    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as exc:  # type: ignore\n        # Handle cases that result in a YAML parse error.\n        text = exc.problem + \".\"\n        position = _get_position(str_content, index=exc.problem_mark.index)\n        raise ParseError(text=text, code=\"parse_error\", position=position)\n\n\ndef validate_yaml(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a YAML string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A YAML string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import yaml\n    import typing\n    from marshmallow import ValidationError, Schema, fields\n    from marshmallow.fields import Field\n\n    # Normalize content to string if bytes\n    if isinstance(content, bytes):\n        content = content.decode('utf-8')\n\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as e:\n        # Return None for value with a list of YAML parsing errors\n        return None, [str(e)]\n\n    # Determine if validator is a Field or Schema class\n    if isinstance(validator, Field):\n        field = validator\n        schema_cls = type('SingleFieldSchema', (Schema,), {'field': field})\n        schema = schema_cls()\n        try:\n            value = schema.load({'field': data})\n            return value['field'], []\n        except ValidationError as err:\n            return None, err.messages.get('field', err.messages)\n    elif isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n        try:\n            value = schema.load(data)\n            return value, []\n        except ValidationError as err:\n            return None, err.messages\n    else:\n        raise TypeError(\"Validator must be a marshmallow Field instance or a Schema class.\")\n\n\nimport pickle\ndef test_31():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_yaml(\"\"\"\n        a: 1\n        b: 2\n        c: 3\n    \"\"\", Schema()) == output\ntest_31()\n\ndef test_39():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_yaml/validate_yaml/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(validate_yaml('hello: \"world\"', Schema)) == output\ntest_39()\n\n\n"]}
{"task_id": 331, "project": "test-apps/typesystem", "module": "typesystem.json_schema", "predictions": ["def type_from_json_schema(data: dict, definitions: 'SchemaDefinitions') -> 'Field':\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    if \"$ref\" in data:\n        ref_name = data[\"$ref\"].split(\"/\")[-1]\n        return definitions.get(ref_name)\n\n    if \"oneOf\" in data:\n        return UnionField([type_from_json_schema(subschema, definitions) for subschema in data[\"oneOf\"]])\n\n    if \"anyOf\" in data:\n        return UnionField([type_from_json_schema(subschema, definitions) for subschema in data[\"anyOf\"]])\n\n    if \"allOf\" in data:\n        # allOf can be interpreted as intersection or composition;\n        # here we assume composition merging all field types\n        fields = [type_from_json_schema(subschema, definitions) for subschema in data[\"allOf\"]]\n        return IntersectionField(fields)\n\n    schema_type = data.get(\"type\")\n    if schema_type == \"object\":\n        properties = data.get(\"properties\", {})\n        required = data.get(\"required\", [])\n        fields = {}\n        for prop_name, prop_schema in properties.items():\n            field_type = type_from_json_schema(prop_schema, definitions)\n            fields[prop_name] = field_type if prop_name in required else OptionalField(field_type)\n        return ObjectField(fields)\n\n    if schema_type == \"array\":\n        items_schema = data.get(\"items\", {})\n        item_type = type_from_json_schema(items_schema, definitions)\n        return ArrayField(item_type)\n\n    if schema_type == \"string\":\n        return StringField()\n\n    if schema_type == \"integer\":\n        return IntegerField()\n\n    if schema_type == \"number\":\n        return NumberField()\n\n    if schema_type == \"boolean\":\n        return BooleanField()\n\n    if schema_type == \"null\":\n        return NullField()\n\n    # If type is not specified or unknown\n    return AnyField()", "def type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    if '$ref' in data:\n        ref = data['$ref']\n        return definitions.get(ref)\n    \n    if 'oneOf' in data:\n        options = [type_from_json_schema(schema, definitions) for schema in data['oneOf']]\n        return UnionField(options)\n    \n    if 'anyOf' in data:\n        options = [type_from_json_schema(schema, definitions) for schema in data['anyOf']]\n        return UnionField(options)\n    \n    if 'type' not in data:\n        return AnyField()\n    \n    t = data['type']\n    \n    if t == 'string':\n        return StringField()\n    elif t == 'number':\n        return NumberField()\n    elif t == 'integer':\n        return IntegerField()\n    elif t == 'boolean':\n        return BooleanField()\n    elif t == 'null':\n        return NullField()\n    elif t == 'object':\n        properties = data.get('properties', {})\n        required = set(data.get('required', []))\n        fields = {}\n        for prop, schema in properties.items():\n            field = type_from_json_schema(schema, definitions)\n            if prop not in required:\n                field = OptionalField(field)\n            fields[prop] = field\n        return ObjectField(fields)\n    elif t == 'array':\n        items_schema = data.get('items', {})\n        item_type = type_from_json_schema(items_schema, definitions)\n        return ArrayField(item_type)\n    \n    return AnyField()", "def type_from_json_schema(data: dict, definitions: 'SchemaDefinitions') -> 'Field':\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Handle $ref to definitions\n    if '$ref' in data:\n        ref = data['$ref']\n        if ref.startswith('#/definitions/'):\n            def_name = ref[len('#/definitions/'):]\n            if def_name in definitions:\n                return definitions[def_name]\n            else:\n                raise ValueError(f\"Referenced definition '{def_name}' not found.\")\n        else:\n            raise ValueError(f\"Unsupported $ref format: {ref}\")\n\n    # Handle \"oneOf\", \"anyOf\", \"allOf\" unions/intersections\n    if 'oneOf' in data:\n        fields = [type_from_json_schema(item, definitions) for item in data['oneOf']]\n        return Field.union(fields)\n    if 'anyOf' in data:\n        fields = [type_from_json_schema(item, definitions) for item in data['anyOf']]\n        return Field.union(fields)\n    if 'allOf' in data:\n        # Intersection logic might vary depending on Field; assume flatten intersection by combining fields\n        fields = [type_from_json_schema(item, definitions) for item in data['allOf']]\n        return Field.intersect(fields)\n\n    # Handle type\n    schema_type = data.get('type')\n    if isinstance(schema_type, list):\n        # Multiple types: treat as union\n        fields = [type_from_json_schema({'type': t}, definitions) for t in schema_type]\n        return Field.union(fields)\n\n    if schema_type == 'null':\n        return Field.none()\n    if schema_type == 'boolean':\n        return Field.bool()\n    if schema_type == 'integer':\n        return Field.int()\n    if schema_type == 'number':\n        return Field.float()\n    if schema_type == 'string':\n        # Possible \"format\" field handling (e.g. date-time), simplified here\n        return Field.str()\n    if schema_type == 'array':\n        items = data.get('items', {})\n        item_field = type_from_json_schema(items, definitions) if items else Field.any()\n        return Field.list(item_field)\n    if schema_type == 'object':\n        # Handle properties and required\n        props = data.get('properties', {})\n        required = set(data.get('required', []))\n        fields = {}\n        for prop_name, prop_schema in props.items():\n            field = type_from_json_schema(prop_schema, definitions)\n            if prop_name not in required:\n                field = Field.optional(field)\n            fields[prop_name] = field\n        return Field.object(fields)\n\n    # If no type is specified, treat as any\n    return Field.any()", "def type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    from typing import Union\n\n    if \"$ref\" in data:\n        ref = data[\"$ref\"]\n        if ref.startswith(\"#/definitions/\"):\n            type_name = ref.split(\"/\")[-1]\n            return definitions[type_name]\n        else:\n            raise ValueError(f\"Unsupported $ref format: {ref}\")\n\n    if \"oneOf\" in data:\n        fields = [type_from_json_schema(schema, definitions) for schema in data[\"oneOf\"]]\n        return Union[tuple(fields)]\n\n    if \"anyOf\" in data:\n        fields = [type_from_json_schema(schema, definitions) for schema in data[\"anyOf\"]]\n        return Union[tuple(fields)]\n\n    if \"type\" not in data:\n        return Field()\n\n    typ = data[\"type\"]\n\n    if typ == \"string\":\n        return Field(str)\n    elif typ == \"integer\":\n        return Field(int)\n    elif typ == \"number\":\n        return Field(float)\n    elif typ == \"boolean\":\n        return Field(bool)\n    elif typ == \"null\":\n        return Field(type(None))\n    elif typ == \"array\":\n        items_schema = data.get(\"items\", {})\n        item_field = type_from_json_schema(items_schema, definitions)\n        return Field(list[item_field])  # type: ignore\n    elif typ == \"object\":\n        # For simplicity, return dict type with string keys and any values.\n        return Field(dict)\n    else:\n        raise ValueError(f\"Unsupported JSON schema type: {typ}\")", "def type_from_json_schema(data: dict, definitions: 'SchemaDefinitions') -> 'Field':\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Import here to avoid circular imports\n    from typing import Union\n\n    # Helper function to resolve $ref\n    def resolve_ref(ref: str) -> dict:\n        if not ref.startswith(\"#/definitions/\"):\n            raise ValueError(f\"Unsupported $ref: {ref}\")\n        ref_key = ref[len(\"#/definitions/\"):]\n        if ref_key not in definitions:\n            raise ValueError(f\"Reference {ref} not found in definitions\")\n        return definitions[ref_key]\n\n    # Main logic\n    if \"$ref\" in data:\n        resolved = resolve_ref(data[\"$ref\"])\n        return type_from_json_schema(resolved, definitions)\n\n    if \"anyOf\" in data:\n        types = [type_from_json_schema(subschema, definitions) for subschema in data[\"anyOf\"]]\n        # If all types are the same, return one of them\n        if all(t == types[0] for t in types[1:]):\n            return types[0]\n        # return a Union or a special Union Field\n        return Field(union=types)\n\n    if \"oneOf\" in data:\n        types = [type_from_json_schema(subschema, definitions) for subschema in data[\"oneOf\"]]\n        if all(t == types[0] for t in types[1:]):\n            return types[0]\n        return Field(union=types)\n\n    if \"type\" in data:\n        typ = data[\"type\"]\n        if typ == \"string\":\n            return Field(type=str)\n        elif typ == \"integer\":\n            return Field(type=int)\n        elif typ == \"number\":\n            return Field(type=float)\n        elif typ == \"boolean\":\n            return Field(type=bool)\n        elif typ == \"null\":\n            return Field(type=type(None))\n        elif typ == \"array\":\n            items = data.get(\"items\", {})\n            item_type = type_from_json_schema(items, definitions)\n            return Field(type=list, items=item_type)\n        elif typ == \"object\":\n            props = data.get(\"properties\", {})\n            required = set(data.get(\"required\", []))\n            fields = {}\n            for prop_name, prop_schema in props.items():\n                field = type_from_json_schema(prop_schema, definitions)\n                fields[prop_name] = (field, prop_name in required)\n            return Field(type=dict, fields=fields)\n        else:\n            raise ValueError(f\"Unsupported JSON schema type: {typ}\")\n\n    # If no type or $ref, return Any Field\n    return Field(type=object)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: 'SchemaDefinitions') -> 'Field':\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    if \"$ref\" in data:\n        ref_name = data[\"$ref\"].split(\"/\")[-1]\n        return definitions.get(ref_name)\n\n    if \"oneOf\" in data:\n        return UnionField([type_from_json_schema(subschema, definitions) for subschema in data[\"oneOf\"]])\n\n    if \"anyOf\" in data:\n        return UnionField([type_from_json_schema(subschema, definitions) for subschema in data[\"anyOf\"]])\n\n    if \"allOf\" in data:\n        # allOf can be interpreted as intersection or composition;\n        # here we assume composition merging all field types\n        fields = [type_from_json_schema(subschema, definitions) for subschema in data[\"allOf\"]]\n        return IntersectionField(fields)\n\n    schema_type = data.get(\"type\")\n    if schema_type == \"object\":\n        properties = data.get(\"properties\", {})\n        required = data.get(\"required\", [])\n        fields = {}\n        for prop_name, prop_schema in properties.items():\n            field_type = type_from_json_schema(prop_schema, definitions)\n            fields[prop_name] = field_type if prop_name in required else OptionalField(field_type)\n        return ObjectField(fields)\n\n    if schema_type == \"array\":\n        items_schema = data.get(\"items\", {})\n        item_type = type_from_json_schema(items_schema, definitions)\n        return ArrayField(item_type)\n\n    if schema_type == \"string\":\n        return StringField()\n\n    if schema_type == \"integer\":\n        return IntegerField()\n\n    if schema_type == \"number\":\n        return NumberField()\n\n    if schema_type == \"boolean\":\n        return BooleanField()\n\n    if schema_type == \"null\":\n        return NullField()\n\n    # If type is not specified or unknown\n    return AnyField()\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    if '$ref' in data:\n        ref = data['$ref']\n        return definitions.get(ref)\n    \n    if 'oneOf' in data:\n        options = [type_from_json_schema(schema, definitions) for schema in data['oneOf']]\n        return UnionField(options)\n    \n    if 'anyOf' in data:\n        options = [type_from_json_schema(schema, definitions) for schema in data['anyOf']]\n        return UnionField(options)\n    \n    if 'type' not in data:\n        return AnyField()\n    \n    t = data['type']\n    \n    if t == 'string':\n        return StringField()\n    elif t == 'number':\n        return NumberField()\n    elif t == 'integer':\n        return IntegerField()\n    elif t == 'boolean':\n        return BooleanField()\n    elif t == 'null':\n        return NullField()\n    elif t == 'object':\n        properties = data.get('properties', {})\n        required = set(data.get('required', []))\n        fields = {}\n        for prop, schema in properties.items():\n            field = type_from_json_schema(schema, definitions)\n            if prop not in required:\n                field = OptionalField(field)\n            fields[prop] = field\n        return ObjectField(fields)\n    elif t == 'array':\n        items_schema = data.get('items', {})\n        item_type = type_from_json_schema(items_schema, definitions)\n        return ArrayField(item_type)\n    \n    return AnyField()\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: 'SchemaDefinitions') -> 'Field':\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Handle $ref to definitions\n    if '$ref' in data:\n        ref = data['$ref']\n        if ref.startswith('#/definitions/'):\n            def_name = ref[len('#/definitions/'):]\n            if def_name in definitions:\n                return definitions[def_name]\n            else:\n                raise ValueError(f\"Referenced definition '{def_name}' not found.\")\n        else:\n            raise ValueError(f\"Unsupported $ref format: {ref}\")\n\n    # Handle \"oneOf\", \"anyOf\", \"allOf\" unions/intersections\n    if 'oneOf' in data:\n        fields = [type_from_json_schema(item, definitions) for item in data['oneOf']]\n        return Field.union(fields)\n    if 'anyOf' in data:\n        fields = [type_from_json_schema(item, definitions) for item in data['anyOf']]\n        return Field.union(fields)\n    if 'allOf' in data:\n        # Intersection logic might vary depending on Field; assume flatten intersection by combining fields\n        fields = [type_from_json_schema(item, definitions) for item in data['allOf']]\n        return Field.intersect(fields)\n\n    # Handle type\n    schema_type = data.get('type')\n    if isinstance(schema_type, list):\n        # Multiple types: treat as union\n        fields = [type_from_json_schema({'type': t}, definitions) for t in schema_type]\n        return Field.union(fields)\n\n    if schema_type == 'null':\n        return Field.none()\n    if schema_type == 'boolean':\n        return Field.bool()\n    if schema_type == 'integer':\n        return Field.int()\n    if schema_type == 'number':\n        return Field.float()\n    if schema_type == 'string':\n        # Possible \"format\" field handling (e.g. date-time), simplified here\n        return Field.str()\n    if schema_type == 'array':\n        items = data.get('items', {})\n        item_field = type_from_json_schema(items, definitions) if items else Field.any()\n        return Field.list(item_field)\n    if schema_type == 'object':\n        # Handle properties and required\n        props = data.get('properties', {})\n        required = set(data.get('required', []))\n        fields = {}\n        for prop_name, prop_schema in props.items():\n            field = type_from_json_schema(prop_schema, definitions)\n            if prop_name not in required:\n                field = Field.optional(field)\n            fields[prop_name] = field\n        return Field.object(fields)\n\n    # If no type is specified, treat as any\n    return Field.any()\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    from typing import Union\n\n    if \"$ref\" in data:\n        ref = data[\"$ref\"]\n        if ref.startswith(\"#/definitions/\"):\n            type_name = ref.split(\"/\")[-1]\n            return definitions[type_name]\n        else:\n            raise ValueError(f\"Unsupported $ref format: {ref}\")\n\n    if \"oneOf\" in data:\n        fields = [type_from_json_schema(schema, definitions) for schema in data[\"oneOf\"]]\n        return Union[tuple(fields)]\n\n    if \"anyOf\" in data:\n        fields = [type_from_json_schema(schema, definitions) for schema in data[\"anyOf\"]]\n        return Union[tuple(fields)]\n\n    if \"type\" not in data:\n        return Field()\n\n    typ = data[\"type\"]\n\n    if typ == \"string\":\n        return Field(str)\n    elif typ == \"integer\":\n        return Field(int)\n    elif typ == \"number\":\n        return Field(float)\n    elif typ == \"boolean\":\n        return Field(bool)\n    elif typ == \"null\":\n        return Field(type(None))\n    elif typ == \"array\":\n        items_schema = data.get(\"items\", {})\n        item_field = type_from_json_schema(items_schema, definitions)\n        return Field(list[item_field])  # type: ignore\n    elif typ == \"object\":\n        # For simplicity, return dict type with string keys and any values.\n        return Field(dict)\n    else:\n        raise ValueError(f\"Unsupported JSON schema type: {typ}\")\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: 'SchemaDefinitions') -> 'Field':\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Import here to avoid circular imports\n    from typing import Union\n\n    # Helper function to resolve $ref\n    def resolve_ref(ref: str) -> dict:\n        if not ref.startswith(\"#/definitions/\"):\n            raise ValueError(f\"Unsupported $ref: {ref}\")\n        ref_key = ref[len(\"#/definitions/\"):]\n        if ref_key not in definitions:\n            raise ValueError(f\"Reference {ref} not found in definitions\")\n        return definitions[ref_key]\n\n    # Main logic\n    if \"$ref\" in data:\n        resolved = resolve_ref(data[\"$ref\"])\n        return type_from_json_schema(resolved, definitions)\n\n    if \"anyOf\" in data:\n        types = [type_from_json_schema(subschema, definitions) for subschema in data[\"anyOf\"]]\n        # If all types are the same, return one of them\n        if all(t == types[0] for t in types[1:]):\n            return types[0]\n        # return a Union or a special Union Field\n        return Field(union=types)\n\n    if \"oneOf\" in data:\n        types = [type_from_json_schema(subschema, definitions) for subschema in data[\"oneOf\"]]\n        if all(t == types[0] for t in types[1:]):\n            return types[0]\n        return Field(union=types)\n\n    if \"type\" in data:\n        typ = data[\"type\"]\n        if typ == \"string\":\n            return Field(type=str)\n        elif typ == \"integer\":\n            return Field(type=int)\n        elif typ == \"number\":\n            return Field(type=float)\n        elif typ == \"boolean\":\n            return Field(type=bool)\n        elif typ == \"null\":\n            return Field(type=type(None))\n        elif typ == \"array\":\n            items = data.get(\"items\", {})\n            item_type = type_from_json_schema(items, definitions)\n            return Field(type=list, items=item_type)\n        elif typ == \"object\":\n            props = data.get(\"properties\", {})\n            required = set(data.get(\"required\", []))\n            fields = {}\n            for prop_name, prop_schema in props.items():\n                field = type_from_json_schema(prop_schema, definitions)\n                fields[prop_name] = (field, prop_name in required)\n            return Field(type=dict, fields=fields)\n        else:\n            raise ValueError(f\"Unsupported JSON schema type: {typ}\")\n\n    # If no type or $ref, return Any Field\n    return Field(type=object)\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n\n    type_strings = data.get(\"type\", [])\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    allow_null = False\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    return (type_strings, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_1():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'password'}, SchemaDefinitions()).validate('foo')\ntest_1()\n\ndef test_3():\n    assert \"3\" == type_from_json_schema({\"type\": \"string\"}, {}).validate(\"3\")\ntest_3()\n\ndef test_5():\n    assert 5 == type_from_json_schema({\"type\": \"integer\"}, None).validate_or_error(5).value\ntest_5()\n\ndef test_6():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3\")\ntest_6()\n\ndef test_7():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1\")\ntest_7()\n\ndef test_11():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'uri'}, SchemaDefinitions()).validate('foo')\ntest_11()\n\ndef test_12():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_12()\n\ndef test_13():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Float,\n    )\ntest_13()\n\ndef test_16():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'byte'}, SchemaDefinitions()).validate('foo')\ntest_16()\n\ndef test_17():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3)\ntest_17()\n\ndef test_20():\n    assert 3 == type_from_json_schema({\"type\": [\"number\"]}, {}).validate(3)\ntest_20()\n\ndef test_26():\n    assert isinstance(type_from_json_schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\"is_best_friend\": {\"type\": \"boolean\"}},\n            \"required\": [\"is_best_friend\"],\n        },\n        definitions={},\n    ),\n    Field\n    )\ntest_26()\n\ndef test_30():\n    assert 3.0 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.0\")\ntest_30()\n\ndef test_34():\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=False), SchemaDefinitions()), Array)\ntest_34()\n\ndef test_35():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'binary'}, SchemaDefinitions()).validate('foo')\ntest_35()\n\ndef test_40():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3.5)\ntest_40()\n\ndef test_41():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Integer,\n    )\ntest_41()\n\ndef test_44():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(u\"test\")\ntest_44()\n\ndef test_45():\n    assert isinstance(type_from_json_schema(dict(type=\"object\"), SchemaDefinitions()), Object)\ntest_45()\n\ndef test_46():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1.1)\ntest_46()\n\ndef test_50():\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=False), SchemaDefinitions()), Number)\ntest_50()\n\ndef test_51():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).serialize(3)\ntest_51()\n\ndef test_55():\n    assert 2 == type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_55()\n\ndef test_56():\n    assert isinstance(\n        type_from_json_schema({\"type\": \"string\", \"title\": \"aaa\", \"description\": \"bbb\"}, {}),\n        String,\n    )\ntest_56()\n\ndef test_57():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.0)\ntest_57()\n\ndef test_61():\n    assert isinstance(type_from_json_schema(dict(type=\"array\"), SchemaDefinitions()), Array)\ntest_61()\n\ndef test_62():\n    assert \"3\" == type_from_json_schema({\"type\": [\"string\"]}, {}).validate(\"3\")\ntest_62()\n\ndef test_63():\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_63()\n\ndef test_67():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\"], \"nullable\": True}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_67()\n\ndef test_68():\n    assert 3.5 == type_from_json_schema({\"type\": \"number\"}, {}).validate(\"3.5\")\ntest_68()\n\ndef test_70():\n    assert 3 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3)\ntest_70()\n\ndef test_75():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\"]}, {}).validate(\"3\")\ntest_75()\n\ndef test_78():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": \"string\", \"nullable\": True}, SchemaDefinitions()\n        ),\n        String\n    )\ntest_78()\n\ndef test_79():\n    assert isinstance(\n        type_from_json_schema(\n            {\"title\": \"Test\", \"type\": [\"string\", \"integer\", \"null\"]}, SchemaDefinitions()\n        ),\n        Union\n    )\ntest_79()\n\ndef test_80():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'hostname'}, SchemaDefinitions()).validate('foo')\ntest_80()\n\ndef test_84():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"array\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Array,\n    )\ntest_84()\n\ndef test_85():\n    assert 1 != type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(2)\ntest_85()\n\ndef test_86():\n    assert isinstance(type_from_json_schema(dict(type=\"string\"), SchemaDefinitions()), String)\ntest_86()\n\ndef test_91():\n    assert isinstance(type_from_json_schema(dict(type=\"number\"), SchemaDefinitions()), Number)\ntest_91()\n\ndef test_96():\n    assert 3 == type_from_json_schema({'type': 'integer', 'format': 'int64'}, SchemaDefinitions()).validate(3)\ntest_96()\n\ndef test_97():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv4'}, SchemaDefinitions()).validate('foo')\ntest_97()\n\ndef test_98():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_98()\n\ndef test_102():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"object\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Object,\n    )\ntest_102()\n\ndef test_103():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'email'}, SchemaDefinitions()).validate('foo')\ntest_103()\n\ndef test_104():\n    assert 3 == type_from_json_schema({\"type\": \"integer\"}, {}).validate(\"3\")\ntest_104()\n\ndef test_105():\n    assert 1 == type_from_json_schema(\n            data={\"type\": \"integer\", \"multipleOf\": 1}, definitions=SchemaDefinitions()\n        ).validate(1)\ntest_105()\n\ndef test_106():\n    assert 2.1 != type_from_json_schema(\n            data={\"type\": \"number\", \"multipleOf\": 0.5}, definitions=SchemaDefinitions()\n        ).validate(3)\ntest_106()\n\ndef test_113():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'double'}, SchemaDefinitions()).validate(3.2)\ntest_113()\n\ndef test_115():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(1)\ntest_115()\n\ndef test_116():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Boolean,\n    )\ntest_116()\n\ndef test_118():\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\"), SchemaDefinitions()), Boolean)\ntest_118()\n\ndef test_120():\n    assert isinstance(type_from_json_schema(dict(type=\"null\"), SchemaDefinitions()), Const)\ntest_120()\n\ndef test_122():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'date-time'}, SchemaDefinitions()).validate('foo')\ntest_122()\n\ndef test_123():\n    assert 3 == type_from_json_schema({\"type\": [\"integer\", \"string\"]}, {}).validate(\"3\")\ntest_123()\n\ndef test_126():\n    assert 3.5 == type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(3.5)\ntest_126()\n\ndef test_129():\n    assert 3 == type_from_json_schema({\"type\": \"number\"}, {}).validate(3)\ntest_129()\n\ndef test_134():\n    assert False == type_from_json_schema({'type': 'boolean', 'format': 'boolean'}, SchemaDefinitions()).validate(False)\ntest_134()\n\ndef test_138():\n    assert not type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(None)\ntest_138()\n\ndef test_139():\n    assert 3.2 == type_from_json_schema({'type': 'number', 'format': 'float'}, SchemaDefinitions()).validate(3.2)\ntest_139()\n\ndef test_141():\n    assert 'foo' == type_from_json_schema({'type': 'string', 'format': 'ipv6'}, SchemaDefinitions()).validate('foo')\ntest_141()\n\ndef test_144():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [\n                    {\"type\": \"string\", \"title\": \"MyStringField\", \"maxLength\": 3},\n                    {\"type\": \"integer\", \"title\": \"MyIntegerField\", \"maximum\": 999},\n                ]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_144()\n\ndef test_146():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"type\": \"string\",\n                \"title\": \"MyStringField\",\n                \"description\": \"This is my custom string field\",\n            },\n            SchemaDefinitions(),\n        ),\n        String,\n    )\ntest_146()\n\ndef test_150():\n    assert isinstance(type_from_json_schema(dict(type=\"integer\"), SchemaDefinitions()), Integer)\ntest_150()\n\ndef test_151():\n    assert 3 == type_from_json_schema({}, {}).validate(\"3\")\ntest_151()\n\ndef test_152():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(1)\ntest_152()\n\ndef test_154():\n    assert type_from_json_schema({\"type\": \"number\"}, SchemaDefinitions()).validate(\"1.1\")\ntest_154()\n\ndef test_155():\n    assert isinstance(type_from_json_schema(dict(type=\"null\", nullable=True), SchemaDefinitions()), Const)\ntest_155()\n\ndef test_157():\n    assert isinstance(type_from_json_schema(\n        {\"title\": \"Test\", \"type\": \"integer\"}, SchemaDefinitions()), Integer\n    )\ntest_157()\n\ndef test_159():\n    assert \"test\" == type_from_json_schema({\"type\": \"string\"}, {}).serialize(\"test\")\ntest_159()\n\ndef test_166():\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": [\"string\", \"null\"]}, SchemaDefinitions()\n        ),\n        String,\n    )\ntest_166()\n\ndef test_167():\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1\")\ntest_167()\n\ndef test_168():\n    assert type_from_json_schema({\"type\": [\"integer\", \"null\"]}, SchemaDefinitions()).validate(\"1\")\ntest_168()\n\ndef test_170():\n    assert isinstance(\n        type_from_json_schema(\n            {\n                \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]\n            },\n            SchemaDefinitions(),\n        ),\n        Union,\n    )\ntest_170()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"integer\"}, SchemaDefinitions()).validate(\"1.1\") == output\ntest_2()\n\ndef test_15():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"integer\", nullable=True), SchemaDefinitions()), Union) == output\ntest_15()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"object\", nullable=True), SchemaDefinitions()), Union) == output\ntest_25()\n\ndef test_37():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"number\", nullable=True), SchemaDefinitions()), Union) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"string\", \"title\": \"example\", \"const\": \"foo\"},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_42()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"number\", \"title\": \"example\", \"const\": 1.2},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"string\", \"number\"]}, {}).validate(\"3\") == output\ntest_48()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"boolean\", nullable=True), SchemaDefinitions()), Union) == output\ntest_54()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(data={\"type\": \"string\", \"default\": \"null\", \"nullable\": True}, definitions=SchemaDefinitions()), Const) == output\ntest_74()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"string\", nullable=True), SchemaDefinitions()), Union) == output\ntest_83()\n\ndef test_92():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"integer\", \"string\", \"null\"]}, SchemaDefinitions()).validate(None) == output\ntest_92()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(False) == output\ntest_95()\n\ndef test_100():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"integer\", \"title\": \"example\", \"const\": 1},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).serialize(3.3) == output\ntest_101()\n\ndef test_108():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(\n        type_from_json_schema(\n            {\"type\": \"boolean\", \"title\": \"example\", \"const\": True},\n            definitions=SchemaDefinitions(),\n        ),\n        Const,\n    ) == output\ntest_108()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"null\"}, SchemaDefinitions()).validate(None) == output\ntest_114()\n\ndef test_127():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"boolean\"}, {}).serialize(True) == output\ntest_127()\n\ndef test_131():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": [\"number\", \"string\"]}, {}).validate(\"3.5\") == output\ntest_131()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert type_from_json_schema({\"type\": \"number\"}, {}).validate(3.3) == output\ntest_137()\n\ndef test_156():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/type_from_json_schema/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(type_from_json_schema(dict(type=\"array\", nullable=True), SchemaDefinitions()), Union) == output\ntest_156()\n\n\n"]}
{"task_id": 332, "project": "test-apps/typesystem", "module": "typesystem.json_schema", "predictions": ["def get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    import typing\n\n    types = set()\n    allow_null = False\n\n    type_value = data.get(\"type\")\n    if isinstance(type_value, str):\n        if type_value == \"null\":\n            allow_null = True\n        else:\n            types.add(type_value)\n    elif isinstance(type_value, list):\n        for t in type_value:\n            if t == \"null\":\n                allow_null = True\n            else:\n                types.add(t)\n\n    return (types, allow_null)", "def get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    import typing\n\n    types = data.get('type')\n    allow_null = False\n\n    if isinstance(types, str):\n        type_strings = {types}\n    elif isinstance(types, list):\n        type_strings = set()\n        for t in types:\n            if t == 'null':\n                allow_null = True\n            else:\n                type_strings.add(t)\n    else:\n        # If type is missing or unexpected, assume any type allowed\n        type_strings = set()\n\n    return type_strings, allow_null", "def get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    type_strings = set()\n    allow_null = False\n\n    if \"type\" in data:\n        t = data[\"type\"]\n        if isinstance(t, list):\n            for item in t:\n                if item == \"null\":\n                    allow_null = True\n                else:\n                    type_strings.add(item)\n        else:\n            if t == \"null\":\n                allow_null = True\n            else:\n                type_strings.add(t)\n\n    return type_strings, allow_null", "def get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    type_strings = set()\n    allow_null = False\n\n    if not data:\n        return type_strings, allow_null\n\n    type_info = data.get(\"type\")\n    if isinstance(type_info, list):\n        for t in type_info:\n            if t == \"null\":\n                allow_null = True\n            else:\n                type_strings.add(t)\n    elif isinstance(type_info, str):\n        if type_info == \"null\":\n            allow_null = True\n        else:\n            type_strings.add(type_info)\n\n    return type_strings, allow_null", "def get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    import typing\n    \n    type_strings = set()\n    allow_null = False\n    \n    # If 'type' key is not in data, no types are specified\n    if 'type' not in data:\n        return type_strings, allow_null\n    \n    type_value = data['type']\n    \n    # If 'type' is a list, iterate over it\n    if isinstance(type_value, list):\n        for t in type_value:\n            if t == 'null':\n                allow_null = True\n            else:\n                type_strings.add(t)\n    else:\n        # Single type string\n        if type_value == 'null':\n            allow_null = True\n        else:\n            type_strings.add(type_value)\n    \n    return type_strings, allow_null"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    import typing\n\n    types = set()\n    allow_null = False\n\n    type_value = data.get(\"type\")\n    if isinstance(type_value, str):\n        if type_value == \"null\":\n            allow_null = True\n        else:\n            types.add(type_value)\n    elif isinstance(type_value, list):\n        for t in type_value:\n            if t == \"null\":\n                allow_null = True\n            else:\n                types.add(t)\n\n    return (types, allow_null)\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    import typing\n\n    types = data.get('type')\n    allow_null = False\n\n    if isinstance(types, str):\n        type_strings = {types}\n    elif isinstance(types, list):\n        type_strings = set()\n        for t in types:\n            if t == 'null':\n                allow_null = True\n            else:\n                type_strings.add(t)\n    else:\n        # If type is missing or unexpected, assume any type allowed\n        type_strings = set()\n\n    return type_strings, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    type_strings = set()\n    allow_null = False\n\n    if \"type\" in data:\n        t = data[\"type\"]\n        if isinstance(t, list):\n            for item in t:\n                if item == \"null\":\n                    allow_null = True\n                else:\n                    type_strings.add(item)\n        else:\n            if t == \"null\":\n                allow_null = True\n            else:\n                type_strings.add(t)\n\n    return type_strings, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    type_strings = set()\n    allow_null = False\n\n    if not data:\n        return type_strings, allow_null\n\n    type_info = data.get(\"type\")\n    if isinstance(type_info, list):\n        for t in type_info:\n            if t == \"null\":\n                allow_null = True\n            else:\n                type_strings.add(t)\n    elif isinstance(type_info, str):\n        if type_info == \"null\":\n            allow_null = True\n        else:\n            type_strings.add(type_info)\n\n    return type_strings, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nimport typing\n\nfrom typesystem.composites import AllOf, IfThenElse, NeverMatch, Not, OneOf\nfrom typesystem.fields import (\n    NO_DEFAULT,\n    Any,\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Union,\n)\nfrom typesystem.schemas import Reference, Schema, SchemaDefinitions\n\nTYPE_CONSTRAINTS = {\n    \"additionalItems\",\n    \"additionalProperties\",\n    \"boolean_schema\",\n    \"contains\",\n    \"dependencies\",\n    \"exclusiveMaximum\",\n    \"exclusiveMinimum\",\n    \"items\",\n    \"maxItems\",\n    \"maxLength\",\n    \"maxProperties\",\n    \"maximum\",\n    \"minItems\",\n    \"minLength\",\n    \"minProperties\",\n    \"minimum\",\n    \"multipleOf\",\n    \"pattern\",\n    \"patternProperties\",\n    \"properties\",\n    \"propertyNames\",\n    \"required\",\n    \"type\",\n    \"uniqueItems\",\n}\n\n\ndefinitions = SchemaDefinitions()\n\nJSONSchema = (\n    Object(\n        properties={\n            \"$ref\": String(),\n            \"type\": String() | Array(items=String()),\n            \"enum\": Array(unique_items=True, min_items=1),\n            \"definitions\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            # String\n            \"minLength\": Integer(minimum=0),\n            \"maxLength\": Integer(minimum=0),\n            \"pattern\": String(format=\"regex\"),\n            \"format\": String(),\n            # Numeric\n            \"minimum\": Number(),\n            \"maximum\": Number(),\n            \"exclusiveMinimum\": Number(),\n            \"exclusiveMaximum\": Number(),\n            \"multipleOf\": Number(exclusive_minimum=0),\n            # Object\n            \"properties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"minProperties\": Integer(minimum=0),\n            \"maxProperties\": Integer(minimum=0),\n            \"patternProperties\": Object(\n                additional_properties=Reference(\"JSONSchema\", definitions=definitions)\n            ),\n            \"additionalProperties\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"required\": Array(items=String(), unique_items=True),\n            # Array\n            \"items\": (\n                Reference(\"JSONSchema\", definitions=definitions)\n                | Array(\n                    items=Reference(\"JSONSchema\", definitions=definitions), min_items=1\n                )\n            ),\n            \"additionalItems\": (\n                Reference(\"JSONSchema\", definitions=definitions) | Boolean()\n            ),\n            \"minItems\": Integer(minimum=0),\n            \"maxItems\": Integer(minimum=0),\n            \"uniqueItems\": Boolean(),\n        }\n    )\n    | Boolean()\n)\n\ndefinitions[\"JSONSchema\"] = JSONSchema\n\n\ndef from_json_schema(\n    data: typing.Union[bool, dict], definitions: SchemaDefinitions = None\n) -> Field:\n    if isinstance(data, bool):\n        return {True: Any(), False: NeverMatch()}[data]\n\n    if definitions is None:\n        definitions = SchemaDefinitions()\n        for key, value in data.get(\"definitions\", {}).items():\n            ref = f\"#/definitions/{key}\"\n            definitions[ref] = from_json_schema(value, definitions=definitions)\n\n    if \"$ref\" in data:\n        return ref_from_json_schema(data, definitions=definitions)\n\n    constraints = []  # typing.List[Field]\n    if any([property_name in data for property_name in TYPE_CONSTRAINTS]):\n        constraints.append(type_from_json_schema(data, definitions=definitions))\n    if \"enum\" in data:\n        constraints.append(enum_from_json_schema(data, definitions=definitions))\n    if \"const\" in data:\n        constraints.append(const_from_json_schema(data, definitions=definitions))\n    if \"allOf\" in data:\n        constraints.append(all_of_from_json_schema(data, definitions=definitions))\n    if \"anyOf\" in data:\n        constraints.append(any_of_from_json_schema(data, definitions=definitions))\n    if \"oneOf\" in data:\n        constraints.append(one_of_from_json_schema(data, definitions=definitions))\n    if \"not\" in data:\n        constraints.append(not_from_json_schema(data, definitions=definitions))\n    if \"if\" in data:\n        constraints.append(if_then_else_from_json_schema(data, definitions=definitions))\n\n    if len(constraints) == 1:\n        return constraints[0]\n    elif len(constraints) > 1:\n        return AllOf(constraints)\n    return Any()\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    if len(type_strings) > 1:\n        items = [\n            from_json_schema_type(\n                data, type_string=type_string, allow_null=False, definitions=definitions\n            )\n            for type_string in type_strings\n        ]\n        return Union(any_of=items, allow_null=allow_null)\n\n    if len(type_strings) == 0:\n        return {True: Const(None), False: NeverMatch()}[allow_null]\n\n    type_string = type_strings.pop()\n    return from_json_schema_type(\n        data, type_string=type_string, allow_null=allow_null, definitions=definitions\n    )\n\n\ndef get_valid_types(data: dict) -> typing.Tuple[typing.Set[str], bool]:\n    \"\"\"\n    Returns a two-tuple of `(type_strings, allow_null)`.\n    \"\"\"\n    import typing\n    \n    type_strings = set()\n    allow_null = False\n    \n    # If 'type' key is not in data, no types are specified\n    if 'type' not in data:\n        return type_strings, allow_null\n    \n    type_value = data['type']\n    \n    # If 'type' is a list, iterate over it\n    if isinstance(type_value, list):\n        for t in type_value:\n            if t == 'null':\n                allow_null = True\n            else:\n                type_strings.add(t)\n    else:\n        # Single type string\n        if type_value == 'null':\n            allow_null = True\n        else:\n            type_strings.add(type_value)\n    \n    return type_strings, allow_null\n\n\ndef from_json_schema_type(\n    data: dict, type_string: str, allow_null: bool, definitions: SchemaDefinitions\n) -> Field:\n    \"\"\"\n    Build a typed field from a JSON schema object.\n    \"\"\"\n\n    if type_string == \"number\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Float(**kwargs)\n\n    elif type_string == \"integer\":\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"minimum\": data.get(\"minimum\", None),\n            \"maximum\": data.get(\"maximum\", None),\n            \"exclusive_minimum\": data.get(\"exclusiveMinimum\", None),\n            \"exclusive_maximum\": data.get(\"exclusiveMaximum\", None),\n            \"multiple_of\": data.get(\"multipleOf\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Integer(**kwargs)\n\n    elif type_string == \"string\":\n        min_length = data.get(\"minLength\", 0)\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"allow_blank\": min_length == 0,\n            \"min_length\": min_length if min_length > 1 else None,\n            \"max_length\": data.get(\"maxLength\", None),\n            \"format\": data.get(\"format\"),\n            \"pattern\": data.get(\"pattern\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return String(**kwargs)\n\n    elif type_string == \"boolean\":\n        kwargs = {\"allow_null\": allow_null, \"default\": data.get(\"default\", NO_DEFAULT)}\n        return Boolean(**kwargs)\n\n    elif type_string == \"array\":\n        items = data.get(\"items\", None)\n        if items is None:\n            items_argument: typing.Union[None, Field, typing.List[Field]] = None\n        elif isinstance(items, list):\n            items_argument = [\n                from_json_schema(item, definitions=definitions) for item in items\n            ]\n        else:\n            items_argument = from_json_schema(items, definitions=definitions)\n\n        additional_items = data.get(\"additionalItems\", None)\n        if additional_items is None:\n            additional_items_argument: typing.Union[bool, Field] = True\n        elif isinstance(additional_items, bool):\n            additional_items_argument = additional_items\n        else:\n            additional_items_argument = from_json_schema(\n                additional_items, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"min_items\": data.get(\"minItems\", 0),\n            \"max_items\": data.get(\"maxItems\", None),\n            \"additional_items\": additional_items_argument,\n            \"items\": items_argument,\n            \"unique_items\": data.get(\"uniqueItems\", False),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Array(**kwargs)\n\n    elif type_string == \"object\":\n        properties = data.get(\"properties\", None)\n        if properties is None:\n            properties_argument: typing.Optional[typing.Dict[str, Field]] = None\n        else:\n            properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in properties.items()\n            }\n\n        pattern_properties = data.get(\"patternProperties\", None)\n        if pattern_properties is None:\n            pattern_properties_argument: typing.Optional[typing.Dict[str, Field]] = (\n                None\n            )\n        else:\n            pattern_properties_argument = {\n                key: from_json_schema(value, definitions=definitions)\n                for key, value in pattern_properties.items()\n            }\n\n        additional_properties = data.get(\"additionalProperties\", None)\n        if additional_properties is None:\n            additional_properties_argument: typing.Union[None, bool, Field] = (None)\n        elif isinstance(additional_properties, bool):\n            additional_properties_argument = additional_properties\n        else:\n            additional_properties_argument = from_json_schema(\n                additional_properties, definitions=definitions\n            )\n\n        property_names = data.get(\"propertyNames\", None)\n        if property_names is None:\n            property_names_argument: typing.Optional[Field] = None\n        else:\n            property_names_argument = from_json_schema(\n                property_names, definitions=definitions\n            )\n\n        kwargs = {\n            \"allow_null\": allow_null,\n            \"properties\": properties_argument,\n            \"pattern_properties\": pattern_properties_argument,\n            \"additional_properties\": additional_properties_argument,\n            \"property_names\": property_names_argument,\n            \"min_properties\": data.get(\"minProperties\", None),\n            \"max_properties\": data.get(\"maxProperties\", None),\n            \"required\": data.get(\"required\", None),\n            \"default\": data.get(\"default\", NO_DEFAULT),\n        }\n        return Object(**kwargs)\n\n    assert False, f\"Invalid argument type_string={type_string!r}\"  # pragma: no cover\n\n\ndef ref_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    reference_string = data[\"$ref\"]\n    assert reference_string.startswith(\"#/\"), \"Unsupported $ref style in document.\"\n    return Reference(to=reference_string, definitions=definitions)\n\n\ndef enum_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    choices = [(item, item) for item in data[\"enum\"]]\n    kwargs = {\"choices\": choices, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Choice(**kwargs)\n\n\ndef const_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    const = data[\"const\"]\n    kwargs = {\"const\": const, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Const(**kwargs)\n\n\ndef all_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    all_of = [from_json_schema(item, definitions=definitions) for item in data[\"allOf\"]]\n    kwargs = {\"all_of\": all_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return AllOf(**kwargs)\n\n\ndef any_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    any_of = [from_json_schema(item, definitions=definitions) for item in data[\"anyOf\"]]\n    kwargs = {\"any_of\": any_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Union(**kwargs)\n\n\ndef one_of_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    one_of = [from_json_schema(item, definitions=definitions) for item in data[\"oneOf\"]]\n    kwargs = {\"one_of\": one_of, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return OneOf(**kwargs)\n\n\ndef not_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    negated = from_json_schema(data[\"not\"], definitions=definitions)\n    kwargs = {\"negated\": negated, \"default\": data.get(\"default\", NO_DEFAULT)}\n    return Not(**kwargs)\n\n\ndef if_then_else_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    if_clause = from_json_schema(data[\"if\"], definitions=definitions)\n    then_clause = (\n        from_json_schema(data[\"then\"], definitions=definitions)\n        if \"then\" in data\n        else None\n    )\n    else_clause = (\n        from_json_schema(data[\"else\"], definitions=definitions)\n        if \"else\" in data\n        else None\n    )\n    kwargs = {\n        \"if_clause\": if_clause,\n        \"then_clause\": then_clause,\n        \"else_clause\": else_clause,\n        \"default\": data.get(\"default\", NO_DEFAULT),\n    }\n    return IfThenElse(**kwargs)  # type: ignore\n\n\ndef to_json_schema(\n    arg: typing.Union[Field, typing.Type[Schema]], _definitions: dict = None\n) -> typing.Union[bool, dict]:\n\n    if isinstance(arg, Any):\n        return True\n    elif isinstance(arg, NeverMatch):\n        return False\n\n    data: dict = {}\n    is_root = _definitions is None\n    definitions = {} if _definitions is None else _definitions\n\n    if isinstance(arg, Field):\n        field = arg\n    elif isinstance(arg, SchemaDefinitions):\n        field = None\n        for key, value in arg.items():\n            definitions[key] = to_json_schema(value, _definitions=definitions)\n    else:\n        field = arg.make_validator()\n\n    if isinstance(field, Reference):\n        data[\"$ref\"] = f\"#/definitions/{field.target_string}\"\n        definitions[field.target_string] = to_json_schema(\n            field.target, _definitions=definitions\n        )\n\n    elif isinstance(field, String):\n        data[\"type\"] = [\"string\", \"null\"] if field.allow_null else \"string\"\n        data.update(get_standard_properties(field))\n        if field.min_length is not None or not field.allow_blank:\n            data[\"minLength\"] = field.min_length or 1\n        if field.max_length is not None:\n            data[\"maxLength\"] = field.max_length\n        if field.pattern_regex is not None:\n            if field.pattern_regex.flags != re.RegexFlag.UNICODE:\n                flags = re.RegexFlag(field.pattern_regex.flags)\n                raise ValueError(\n                    f\"Cannot convert regular expression with non-standard flags \"\n                    f\"to JSON schema: {flags!s}\"\n                )\n            data[\"pattern\"] = field.pattern_regex.pattern\n        if field.format is not None:\n            data[\"format\"] = field.format\n\n    elif isinstance(field, (Integer, Float, Decimal)):\n        base_type = \"integer\" if isinstance(field, Integer) else \"number\"\n        data[\"type\"] = [base_type, \"null\"] if field.allow_null else base_type\n        data.update(get_standard_properties(field))\n        if field.minimum is not None:\n            data[\"minimum\"] = field.minimum\n        if field.maximum is not None:\n            data[\"maximum\"] = field.maximum\n        if field.exclusive_minimum is not None:\n            data[\"exclusiveMinimum\"] = field.exclusive_minimum\n        if field.exclusive_maximum is not None:\n            data[\"exclusiveMaximum\"] = field.exclusive_maximum\n        if field.multiple_of is not None:\n            data[\"multipleOf\"] = field.multiple_of\n\n    elif isinstance(field, Boolean):\n        data[\"type\"] = [\"boolean\", \"null\"] if field.allow_null else \"boolean\"\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Array):\n        data[\"type\"] = [\"array\", \"null\"] if field.allow_null else \"array\"\n        data.update(get_standard_properties(field))\n        if field.min_items is not None:\n            data[\"minItems\"] = field.min_items\n        if field.max_items is not None:\n            data[\"maxItems\"] = field.max_items\n        if field.items is not None:\n            if isinstance(field.items, (list, tuple)):\n                data[\"items\"] = [\n                    to_json_schema(item, _definitions=definitions)\n                    for item in field.items\n                ]\n            else:\n                data[\"items\"] = to_json_schema(field.items, _definitions=definitions)\n        if field.additional_items is not None:\n            if isinstance(field.additional_items, bool):\n                data[\"additionalItems\"] = field.additional_items\n            else:\n                data[\"additionalItems\"] = to_json_schema(\n                    field.additional_items, _definitions=definitions\n                )\n        if field.unique_items is not False:\n            data[\"uniqueItems\"] = True\n\n    elif isinstance(field, Object):\n        data[\"type\"] = [\"object\", \"null\"] if field.allow_null else \"object\"\n        data.update(get_standard_properties(field))\n        if field.properties:\n            data[\"properties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.properties.items()\n            }\n        if field.pattern_properties:\n            data[\"patternProperties\"] = {\n                key: to_json_schema(value, _definitions=definitions)\n                for key, value in field.pattern_properties.items()\n            }\n        if field.additional_properties is not None:\n            if isinstance(field.additional_properties, bool):\n                data[\"additionalProperties\"] = field.additional_properties\n            else:\n                data[\"additionalProperties\"] = to_json_schema(\n                    field.additional_properties, _definitions=definitions\n                )\n        if field.property_names is not None:\n            data[\"propertyNames\"] = to_json_schema(\n                field.property_names, _definitions=definitions\n            )\n        if field.max_properties is not None:\n            data[\"maxProperties\"] = field.max_properties\n        if field.min_properties is not None:\n            data[\"minProperties\"] = field.min_properties\n        if field.required:\n            data[\"required\"] = field.required\n\n    elif isinstance(field, Choice):\n        data[\"enum\"] = [key for key, value in field.choices]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Const):\n        data[\"const\"] = field.const\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Union):\n        data[\"anyOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.any_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, OneOf):\n        data[\"oneOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.one_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, AllOf):\n        data[\"allOf\"] = [\n            to_json_schema(item, _definitions=definitions) for item in field.all_of\n        ]\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, IfThenElse):\n        data[\"if\"] = to_json_schema(field.if_clause, _definitions=definitions)\n        if field.then_clause is not None:\n            data[\"then\"] = to_json_schema(field.then_clause, _definitions=definitions)\n        if field.else_clause is not None:\n            data[\"else\"] = to_json_schema(field.else_clause, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif isinstance(field, Not):\n        data[\"not\"] = to_json_schema(field.negated, _definitions=definitions)\n        data.update(get_standard_properties(field))\n\n    elif field is not None:\n        name = type(field).__qualname__\n        raise ValueError(f\"Cannot convert field type {name!r} to JSON Schema\")\n\n    if is_root and definitions:\n        data[\"definitions\"] = definitions\n    return data\n\n\ndef get_standard_properties(field: Field) -> dict:\n    data = {}\n    if field.has_default():\n        data[\"default\"] = field.default\n    return data\n\n\nimport pickle\ndef test_0():\n    assert get_valid_types({\"type\": \"object\", \"additionalProperties\": {}}) == ({\"object\"}, False)\ntest_0()\n\ndef test_1():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == (\n        {\"object\"},\n        True,\n    )\ntest_1()\n\ndef test_4():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMinimum\": 10}) == ({\"integer\"}, False)\ntest_4()\n\ndef test_6():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({\"object\"}, True)\ntest_6()\n\ndef test_9():\n    assert get_valid_types({\"type\": \"integer\", \"exclusiveMaximum\": 10}) == ({\"integer\"}, False)\ntest_9()\n\ndef test_13():\n    assert get_valid_types({\"type\": [\"object\", \"array\"]}) == ({\"object\", \"array\"}, False)\ntest_13()\n\ndef test_14():\n    assert get_valid_types({'type': ['string', 'integer', 'null']}) == ({'string', 'integer'}, True)\ntest_14()\n\ndef test_15():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\", \"integer\"]})[0]\ntest_15()\n\ndef test_18():\n    assert get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False)\ntest_18()\n\ndef test_19():\n    assert get_valid_types({'type': 'integer'}) == ({'integer'}, False)\ntest_19()\n\ndef test_21():\n    assert get_valid_types({\"type\": [\"object\", \"integer\", \"null\"]}) == ({'object', 'integer'}, True)\ntest_21()\n\ndef test_24():\n    assert set((\"object\",)) == get_valid_types({\"type\": \"object\"})[0]\ntest_24()\n\ndef test_26():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"integer\"]}) == ({'object', 'integer'}, True)\ntest_26()\n\ndef test_27():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": \"boolean\"})\ntest_27()\n\ndef test_30():\n    assert (\n        get_valid_types({'type': ['boolean', 'integer']})\n        == ({\"boolean\", \"integer\"}, False)\n    )\ntest_30()\n\ndef test_31():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"integer\", \"null\"]}) == ({'object', 'array', 'integer'}, True)\ntest_31()\n\ndef test_32():\n    assert get_valid_types({\"type\": [\"number\", \"null\"]}) == ({'number'}, True)\ntest_32()\n\ndef test_33():\n    assert set((\"number\",)) == get_valid_types({\"type\": [\"number\", \"null\"]})[0]\ntest_33()\n\ndef test_34():\n    assert (\n        get_valid_types({\"type\": [\"string\", \"null\"]})\n        == ({\"string\"}, True)\n    )\ntest_34()\n\ndef test_35():\n    assert (get_valid_types({\"type\": \"number\"}) == ({\"number\"}, False))\ntest_35()\n\ndef test_36():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'array']})\n        == ({\"string\", \"array\"}, True)\n    )\ntest_36()\n\ndef test_37():\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == (\n        {\"boolean\", \"object\", \"array\", \"number\", \"string\"}, False\n    )\ntest_37()\n\ndef test_38():\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == ({'string', 'number'}, True)\ntest_38()\n\ndef test_39():\n    assert (get_valid_types({\"type\": [\"number\", \"string\"]}) == ({\"number\", \"string\"}, False))\ntest_39()\n\ndef test_40():\n    assert 2 == len(get_valid_types({\"type\": [\"number\", \"string\"]})[0])\ntest_40()\n\ndef test_41():\n    assert get_valid_types({'type': 'object'}) == ({'object'}, False)\ntest_41()\n\ndef test_43():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({'number'}, False)\ntest_43()\n\ndef test_45():\n    assert get_valid_types({\"type\": \"string\"}) == ({'string'}, False)\ntest_45()\n\ndef test_46():\n    assert 3 == len(get_valid_types({\"type\": [\"number\", \"string\", \"null\", \"boolean\"]})[0])\ntest_46()\n\ndef test_50():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\"]}) == \n        ({\"number\"}, True)\n    )\ntest_50()\n\ndef test_51():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({'string', 'number'}, False)\ntest_51()\n\ndef test_52():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({\"string\"}, True)\ntest_52()\n\ndef test_59():\n    assert get_valid_types({\"type\": [\"null\", \"number\"]}) == ({\"number\"}, True)\ntest_59()\n\ndef test_61():\n    assert get_valid_types({\"type\": \"integer\", \"pattern\": \"[0-9]+\"}) == ({\"integer\"}, False)\ntest_61()\n\ndef test_62():\n    assert get_valid_types({'type': ['string']}) == ({'string'}, False)\ntest_62()\n\ndef test_63():\n    assert get_valid_types({\"type\": [\"integer\"]}) == (\n        {\"integer\"},\n        False,\n    )\ntest_63()\n\ndef test_64():\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == ({\"integer\", \"string\"}, False)\ntest_64()\n\ndef test_67():\n    assert get_valid_types({\"type\": [\"number\", \"object\", \"null\"]}) == ({'number', 'object'}, True)\ntest_67()\n\ndef test_69():\n    assert set((\"object\",)) == get_valid_types({\"type\": [\"object\"]})[0]\ntest_69()\n\ndef test_71():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({'integer'}, False)\ntest_71()\n\ndef test_72():\n    assert ({\"boolean\"}, False) == get_valid_types({\"type\": [\"boolean\"]})\ntest_72()\n\ndef test_73():\n    assert get_valid_types({\"type\": \"integer\", \"maximum\": 10}) == ({\"integer\"}, False)\ntest_73()\n\ndef test_75():\n    assert (set([\"boolean\", \"object\"]), False) == get_valid_types({\"type\":[\"boolean\", \"object\"]})\ntest_75()\n\ndef test_76():\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == ({'number', 'string'}, True)\ntest_76()\n\ndef test_80():\n    assert get_valid_types({'type': ['string', 'integer']}) == ({'string', 'integer'}, False)\ntest_80()\n\ndef test_82():\n    assert (get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False))\ntest_82()\n\ndef test_84():\n    assert get_valid_types({\"type\": \"object\"}) == ({\"object\"}, False)\ntest_84()\n\ndef test_87():\n    assert get_valid_types({\n            \"properties\": {\n                \"example\": {\"type\": \"string\", \"maxLength\": 12}\n            },\n            \"type\": \"object\"\n        }) == ({'object'}, False)\ntest_87()\n\ndef test_88():\n    assert (\n        get_valid_types({'type': ['null', 'string', 'integer']})\n        == ({\"string\", \"integer\"}, True)\n    )\ntest_88()\n\ndef test_90():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({\"string\"}, False)\ntest_90()\n\ndef test_92():\n    assert (set([\"string\", \"object\"]), False) == get_valid_types({\"type\":[\"string\", \"object\"]})\ntest_92()\n\ndef test_99():\n    assert set((\"string\", \"number\")) == get_valid_types({\"type\": [\"string\", \"number\"]})[0]\ntest_99()\n\ndef test_100():\n    assert get_valid_types({\"type\": [\"object\", \"null\", \"string\"]}) == ({'object', 'string'}, True)\ntest_100()\n\ndef test_101():\n    assert (set([\"integer\", \"object\"]), False) == get_valid_types({\"type\":[\"integer\", \"object\"]})\ntest_101()\n\ndef test_102():\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == ({'string'}, True)\ntest_102()\n\ndef test_105():\n    assert get_valid_types({'type': \"boolean\"}) == (\n        {\"boolean\"}, False\n    )\ntest_105()\n\ndef test_108():\n    assert get_valid_types({\"type\": [\"string\", \"null\", \"integer\"]}) == ({'string', 'integer'}, True)\ntest_108()\n\ndef test_109():\n    assert get_valid_types({\"type\": [\"integer\", \"string\", \"null\"]}) == ({'integer', 'string'}, True)\ntest_109()\n\ndef test_110():\n    assert get_valid_types({\"type\": [\"boolean\", \"null\", \"integer\"]}) == ({\"integer\", \"boolean\"}, True)\ntest_110()\n\ndef test_111():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"x\": {\"type\": \"string\"}}}) == ({\"object\"}, False)\ntest_111()\n\ndef test_112():\n    assert get_valid_types({\"type\": [\"any\", \"null\"]}) == ({\"any\"}, True)\ntest_112()\n\ndef test_113():\n    assert get_valid_types({\"type\": \"integer\"}) == ({'integer'}, False)\ntest_113()\n\ndef test_117():\n    assert get_valid_types({\"type\": \"object\"}) == (\n        {\"object\"},\n        False,\n    )\ntest_117()\n\ndef test_120():\n    assert get_valid_types({\"type\": \"string\"}) != ({\"string\"}, True)\ntest_120()\n\ndef test_121():\n    assert set((\"number\", \"boolean\")) == get_valid_types({\"type\": [\"number\", \"boolean\"]})[0]\ntest_121()\n\ndef test_123():\n    assert get_valid_types({\"type\": \"string\"}) == ({\"string\"}, False)\ntest_123()\n\ndef test_124():\n    assert (\n        get_valid_types({\"type\": \"string\"}) == \n        ({\"string\"}, False)\n    )\ntest_124()\n\ndef test_127():\n    assert get_valid_types({\"type\": \"array\", \"items\": {\"type\": \"string\"}}) == ({\"array\"}, False)\ntest_127()\n\ndef test_128():\n    assert (get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == ({\"number\", \"string\"}, True))\ntest_128()\n\ndef test_129():\n    assert get_valid_types({\"type\": [\"object\", \"null\"]}) == ({'object'}, True)\ntest_129()\n\ndef test_130():\n    assert get_valid_types({\"type\": \"integer\", \"minimum\": 10}) == ({\"integer\"}, False)\ntest_130()\n\ndef test_131():\n    assert get_valid_types({\"type\": \"number\"}) == ({'number'}, False)\ntest_131()\n\ndef test_133():\n    assert (set([\"boolean\", \"object\", \"array\", \"number\", \"string\"]), False) == get_valid_types({\"type\": [\"boolean\", \"object\", \"array\", \"number\", \"string\"]})\ntest_133()\n\ndef test_134():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({'object', 'array'}, True)\ntest_134()\n\ndef test_136():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({\"integer\"}, True)\ntest_136()\n\ndef test_140():\n    assert get_valid_types({\"type\": [\"object\", \"string\", \"null\"]}) == ({'object', 'string'}, True)\ntest_140()\n\ndef test_141():\n    assert get_valid_types({\"type\": [\"number\"]}) == ({\"number\"}, False)\ntest_141()\n\ndef test_142():\n    assert get_valid_types({\"type\": [\"integer\", \"string\"]}) == (\n        {\"integer\", \"string\"},\n        False,\n    )\ntest_142()\n\ndef test_143():\n    assert get_valid_types({\"type\": [\"string\"]}) == (set({\"string\"}), False)\ntest_143()\n\ndef test_144():\n    assert set((\"number\", \"string\")) == get_valid_types({\"type\": [\"number\", \"string\"]})[0]\ntest_144()\n\ndef test_145():\n    assert get_valid_types({\"type\": \"integer\"}) == ({\"integer\"}, False)\ntest_145()\n\ndef test_146():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({\"object\"}, False)\ntest_146()\n\ndef test_148():\n    assert get_valid_types({\"type\": [\"integer\", \"object\", \"null\"]}) == ({'integer', 'object'}, True)\ntest_148()\n\ndef test_149():\n    assert (set([\"string\"]), True) == get_valid_types({\"type\":[\"string\", \"null\"]})\ntest_149()\n\ndef test_150():\n    assert get_valid_types({'type': ['boolean']}) == ({'boolean'}, False)\ntest_150()\n\ndef test_152():\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == ({\"string\"}, True)\ntest_152()\n\ndef test_156():\n    assert get_valid_types({\"type\": \"object\", \"maxProperties\": 2})\ntest_156()\n\ndef test_158():\n    assert set((\"string\",)) == get_valid_types({\"type\": [\"string\", \"null\"]})[0]\ntest_158()\n\ndef test_159():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"null\"]}) == ({\"object\", \"array\"}, True)\ntest_159()\n\ndef test_162():\n    assert get_valid_types({\"type\": [\"object\", \"array\", \"string\", \"null\"]}) == ({'object', 'array', 'string'}, True)\ntest_162()\n\ndef test_163():\n    assert (\n        get_valid_types(\n            {\"type\": [\"string\"]}\n        )\n    ) == (\n        {\"string\"}, False\n    )\ntest_163()\n\ndef test_165():\n    assert get_valid_types({\"type\": [\"object\"]}) == ({'object'}, False)\ntest_165()\n\ndef test_168():\n    assert get_valid_types({\"type\": \"any\"}) == ({\"any\"}, False)\ntest_168()\n\ndef test_169():\n    assert (set([\"number\", \"object\"]), False) == get_valid_types({\"type\":[\"number\", \"object\"]})\ntest_169()\n\ndef test_171():\n    assert (get_valid_types({\"type\": [\"number\", \"integer\"]}) == ({\"number\"}, False))\ntest_171()\n\ndef test_172():\n    assert get_valid_types({\"type\": \"object\"}) != ({\"object\"}, True)\ntest_172()\n\ndef test_173():\n    assert get_valid_types({\"type\": \"object\", \"properties\": {\"a\": {}}}) == ({\"object\"}, False)\ntest_173()\n\ndef test_174():\n    assert get_valid_types({\"type\": [\"integer\"]}) == ({\"integer\"}, False)\ntest_174()\n\ndef test_175():\n    assert get_valid_types({\"type\": [\"string\", \"number\"]}) == ({\"string\", \"number\"}, False)\ntest_175()\n\ndef test_177():\n    assert 2 == len(get_valid_types({\"type\": [\"null\", \"object\"]}))\ntest_177()\n\ndef test_179():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, False)\ntest_179()\n\ndef test_180():\n    assert get_valid_types({\"type\": \"integer\", \"multipleOf\": 2}) == ({\"integer\"}, False)\ntest_180()\n\ndef test_183():\n    assert (\n        get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        })\n    ) != ({'null', 'boolean', 'object', 'array', 'number', 'string'}, True)\ntest_183()\n\ndef test_185():\n    assert (\n        get_valid_types({\"type\": \"integer\"})\n        == ({\"integer\"}, False)\n    )\ntest_185()\n\ndef test_186():\n    assert get_valid_types({\"type\": [\"string\"]}) == ({'string'}, False)\ntest_186()\n\ndef test_187():\n    assert get_valid_types({\"type\": \"integer\", \"enum\": [1, 2]}) == ({\"integer\"}, False)\ntest_187()\n\ndef test_190():\n    assert get_valid_types({'type': 'string'}) == ({'string'}, False)\ntest_190()\n\ndef test_195():\n    assert get_valid_types({\"type\": [\"integer\", \"null\"]}) == ({'integer'}, True)\ntest_195()\n\ndef test_196():\n    assert (\n        get_valid_types({\"type\": [\"null\", \"number\", \"string\"]}) == \n        ({\"string\", \"number\"}, True)\n    )\ntest_196()\n\ndef test_197():\n    assert get_valid_types({\"type\": \"array\"}) == ({\"array\"}, False)\ntest_197()\n\ndef test_2():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_3()\n\ndef test_5():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"number\", \"string\", \"null\"]})[0]) == output\ntest_5()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": \"boolean\"}}) == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"integer\", \"null\"]}) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"null\", \"object\"]})) == output\ntest_12()\n\ndef test_16():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_17()\n\ndef test_20():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"number\", \"null\"]}) == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"null\"]}) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_25()\n\ndef test_28():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"not\": []}}) == output\ntest_29()\n\ndef test_42():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\"]})[0]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": []}}) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\", \"null\"]}) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": \"boolean\"}}) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\"]})[0]) == output\ntest_49()\n\ndef test_53():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"null\", \"boolean\", \"object\"]})) == output\ntest_55()\n\ndef test_56():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'string', 'boolean']}) == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"null\"]}) == output\ntest_66()\n\ndef test_68():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_70()\n\ndef test_74():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\"]}) == output\ntest_74()\n\ndef test_77():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['object', 'boolean', 'array', 'null']}) == output\ntest_79()\n\ndef test_81():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"object\", \"null\", \"number\"]})[0]) == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"number\"}) == output\ntest_83()\n\ndef test_85():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"boolean\", \"integer\", \"number\"]}) == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_86()\n\ndef test_89():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\"]}) == output\ntest_89()\n\ndef test_91():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"number\", \"string\", \"integer\"]}) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"object\"})[0]) == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\", \"number\"]}) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": \"null\"})[0]) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_98()\n\ndef test_103():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': ['null', 'boolean']}) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_104()\n\ndef test_106():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"]}) == output\ntest_107()\n\ndef test_114():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null'}) == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n        \"type\": [\n            \"null\",\n            \"boolean\",\n            \"integer\",\n            \"number\",\n            \"array\",\n        ]\n    }) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"number\", \"null\"]}) == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': 'null', 'anyOf': [{'type': 'boolean'}]}) == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": []}) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\n        \"null\",\n        \"integer\",\n        \"number\"\n    ]}) == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({'type': [\"boolean\", \"object\", \"array\", \"number\", \"string\", \"null\"]}) == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\":[\"null\", \"number\", \"object\"]}) == output\ntest_126()\n\ndef test_132():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"string\"], \"example\": \"abc\"}) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\", \"number\"]}) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types(\n            {\"type\": [\"number\", \"integer\", \"null\", \"string\"]}\n        ) == output\ntest_139()\n\ndef test_147():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_147()\n\ndef test_151():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\"}) == output\ntest_151()\n\ndef test_153():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\n            'properties': {'result': {'type': 'integer'}},\n            'type': ['null', 'object']\n        }) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_154()\n\ndef test_155():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_155()\n\ndef test_157():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": \"boolean\"}}) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"\"}) == output\ntest_161()\n\ndef test_164():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\"]}) == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"allOf\": \"boolean\"}}) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"object\"]}) == output\ntest_167()\n\ndef test_170():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"type\": []}}) == output\ntest_170()\n\ndef test_176():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": []}}) == output\ntest_176()\n\ndef test_178():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_178\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"null\", \"string\"]}) == output\ntest_178()\n\ndef test_181():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_181()\n\ndef test_182():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_182\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_valid_types({\"type\": [\"integer\", \"string\", \"number\", \"object\"]})) == output\ntest_182()\n\ndef test_184():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"anyOf\": []}}) == output\ntest_184()\n\ndef test_188():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({}) == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"string\", \"integer\"]}) == output\ntest_189()\n\ndef test_191():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"null\"}) == output\ntest_191()\n\ndef test_192():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_192\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": {\"oneOf\": \"boolean\"}}) == output\ntest_192()\n\ndef test_193():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": [\"integer\", \"null\", \"number\"]}) == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+json_schema/get_valid_types/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_valid_types({\"type\": \"string\", \"example\": \"abc\"}) == output\ntest_194()\n\n\n"]}
{"task_id": 333, "project": "test-apps/typesystem", "module": "typesystem.tokenize.tokenize_json", "predictions": ["def validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import ValidationError, Schema\n    from marshmallow.fields import Field\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode(\"utf-8\")\n        parsed = json.loads(content)\n    except json.JSONDecodeError as e:\n        pos_msg = f\"JSON parse error at line {e.lineno} column {e.colno}: {e.msg}\"\n        return None, [pos_msg]\n\n    schema_instance = None\n    if isinstance(validator, Field):\n        try:\n            value = validator.deserialize(parsed)\n            return value, []\n        except ValidationError as ve:\n            errors = []\n            for loc, msgs in ve.messages.items():\n                loc_str = \".\".join(str(x) for x in (loc if isinstance(loc, (list, tuple)) else [loc]))\n                for msg in msgs:\n                    errors.append(f\"{loc_str}: {msg}\")\n            return None, errors\n    elif isinstance(validator, type) and issubclass(validator, Schema):\n        schema_instance = validator()\n        try:\n            value = schema_instance.load(parsed)\n            return value, []\n        except ValidationError as ve:\n            errors = []\n            def _extract_errors(errors_dict, prefix=\"\"):\n                if isinstance(errors_dict, dict):\n                    for key, val in errors_dict.items():\n                        new_prefix = f\"{prefix}.{key}\" if prefix else str(key)\n                        _extract_errors(val, new_prefix)\n                elif isinstance(errors_dict, list):\n                    for item in errors_dict:\n                        errors.append(f\"{prefix}: {item}\")\n                else:\n                    errors.append(f\"{prefix}: {errors_dict}\")\n            _extract_errors(ve.messages)\n            return None, errors\n    else:\n        raise TypeError(\"validator must be a marshmallow Field or a Schema class\")", "def validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import ValidationError\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except json.JSONDecodeError as e:\n        # Return no value and error message about JSON parsing failure\n        return None, [f\"JSON parse error: {e.msg} at line {e.lineno} column {e.colno}\"]\n\n    try:\n        if isinstance(validator, Field):\n            value = validator.deserialize(data)\n        else:\n            schema = validator()\n            value = schema.load(data)\n    except ValidationError as e:\n        # Validation errors are typically a dict of field: [messages]\n        errors = []\n        def flatten_errors(errs, prefix=''):\n            if isinstance(errs, dict):\n                for k, v in errs.items():\n                    flatten_errors(v, prefix + str(k) + '.')\n            elif isinstance(errs, list):\n                for msg in errs:\n                    errors.append(prefix.rstrip('.') + ': ' + str(msg))\n            else:\n                errors.append(prefix.rstrip('.') + ': ' + str(errs))\n\n        flatten_errors(e.messages)\n        return None, errors\n\n    return value, None", "def validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import ValidationError\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except (ValueError, json.JSONDecodeError) as e:\n        # Return the raw error message as a single-item list\n        return None, [f\"JSON parse error: {str(e)}\"]\n\n    # Instantiate schema if a Field instance is not given\n    if isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n    elif hasattr(validator, 'deserialize'):\n        # assuming validator is a Field instance\n        schema = None\n    else:\n        # invalid validator type\n        raise TypeError(\"Validator must be a marshmallow Field instance or Schema class\")\n\n    errors = None\n    value = None\n    try:\n        if schema is not None:\n            # Validate with schema.load returning dict and possible errors\n            value = schema.load(data)\n        else:\n            # Validate with Field.deserialize which raises ValidationError on failure\n            value = validator.deserialize(data)\n    except ValidationError as err:\n        errors = err.messages\n\n    if errors:\n        # Flatten error messages with position info if possible\n        err_list = []\n        def flatten_errors(errs, prefix=''):\n            if isinstance(errs, dict):\n                for key, val in errs.items():\n                    flatten_errors(val, f\"{prefix}{key}.\")\n            elif isinstance(errs, list):\n                for item in errs:\n                    flatten_errors(item, prefix)\n            else:\n                err_list.append(f\"{prefix}{errs}\")\n\n        flatten_errors(errors)\n        return None, err_list\n    else:\n        return value, None", "def validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import Schema, ValidationError, fields as ma_fields\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except json.JSONDecodeError as e:\n        # Returning error message with position information\n        # e.pos gives the position in the input string where parse failed\n        return None, [f\"JSON decode error at pos {e.pos}: {e.msg}\"]\n\n    # instantiate schema if validator is a Schema class\n    if isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n    elif isinstance(validator, ma_fields.Field):\n        # Create a temporary schema with a single field named 'root' to validate the data\n        class TempSchema(Schema):\n            root = validator\n\n        schema = TempSchema()\n        data = {'root': data}  # wrap data for validation\n    else:\n        return None, [\"Validator must be a Schema class or a marshmallow Field instance.\"]\n\n    try:\n        result = schema.load(data)\n        if isinstance(validator, ma_fields.Field):\n            # unwrap the data\n            result = result['root']\n        return result, []\n    except ValidationError as err:\n        errors = err.messages\n        # Format errors to include positional information if possible\n        def format_errors(errs, path=''):\n            msgs = []\n            if isinstance(errs, dict):\n                for key, val in errs.items():\n                    new_path = f\"{path}.{key}\" if path else key\n                    msgs.extend(format_errors(val, new_path))\n            elif isinstance(errs, list):\n                for item in errs:\n                    if isinstance(item, str):\n                        msgs.append(f\"{path}: {item}\" if path else item)\n                    else:\n                        msgs.extend(format_errors(item, path))\n            else:\n                if path:\n                    msgs.append(f\"{path}: {errs}\")\n                else:\n                    msgs.append(str(errs))\n            return msgs\n\n        error_messages = format_errors(errors)\n        return None, error_messages", "def validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import Schema, ValidationError, fields\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except json.JSONDecodeError as e:\n        # Return parse error with no value\n        pos = (e.lineno, e.colno)\n        error_message = {f\"line {pos[0]} col {pos[1]}\": [str(e)]}\n        return None, error_message\n\n    schema = None\n    if isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n    elif isinstance(validator, fields.Field):\n        class TmpSchema(Schema):\n            tmp = validator\n        schema = TmpSchema()\n\n        data = {\"tmp\": data}\n    else:\n        raise TypeError(\"Validator must be a Field instance or a Schema class\")\n\n    try:\n        result = schema.load(data)\n        if isinstance(validator, fields.Field):\n            return result['tmp'], None\n        return result, None\n    except ValidationError as err:\n        return None, err.messages"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import ValidationError, Schema\n    from marshmallow.fields import Field\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode(\"utf-8\")\n        parsed = json.loads(content)\n    except json.JSONDecodeError as e:\n        pos_msg = f\"JSON parse error at line {e.lineno} column {e.colno}: {e.msg}\"\n        return None, [pos_msg]\n\n    schema_instance = None\n    if isinstance(validator, Field):\n        try:\n            value = validator.deserialize(parsed)\n            return value, []\n        except ValidationError as ve:\n            errors = []\n            for loc, msgs in ve.messages.items():\n                loc_str = \".\".join(str(x) for x in (loc if isinstance(loc, (list, tuple)) else [loc]))\n                for msg in msgs:\n                    errors.append(f\"{loc_str}: {msg}\")\n            return None, errors\n    elif isinstance(validator, type) and issubclass(validator, Schema):\n        schema_instance = validator()\n        try:\n            value = schema_instance.load(parsed)\n            return value, []\n        except ValidationError as ve:\n            errors = []\n            def _extract_errors(errors_dict, prefix=\"\"):\n                if isinstance(errors_dict, dict):\n                    for key, val in errors_dict.items():\n                        new_prefix = f\"{prefix}.{key}\" if prefix else str(key)\n                        _extract_errors(val, new_prefix)\n                elif isinstance(errors_dict, list):\n                    for item in errors_dict:\n                        errors.append(f\"{prefix}: {item}\")\n                else:\n                    errors.append(f\"{prefix}: {errors_dict}\")\n            _extract_errors(ve.messages)\n            return None, errors\n    else:\n        raise TypeError(\"validator must be a marshmallow Field or a Schema class\")\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import ValidationError\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except json.JSONDecodeError as e:\n        # Return no value and error message about JSON parsing failure\n        return None, [f\"JSON parse error: {e.msg} at line {e.lineno} column {e.colno}\"]\n\n    try:\n        if isinstance(validator, Field):\n            value = validator.deserialize(data)\n        else:\n            schema = validator()\n            value = schema.load(data)\n    except ValidationError as e:\n        # Validation errors are typically a dict of field: [messages]\n        errors = []\n        def flatten_errors(errs, prefix=''):\n            if isinstance(errs, dict):\n                for k, v in errs.items():\n                    flatten_errors(v, prefix + str(k) + '.')\n            elif isinstance(errs, list):\n                for msg in errs:\n                    errors.append(prefix.rstrip('.') + ': ' + str(msg))\n            else:\n                errors.append(prefix.rstrip('.') + ': ' + str(errs))\n\n        flatten_errors(e.messages)\n        return None, errors\n\n    return value, None\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import ValidationError\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except (ValueError, json.JSONDecodeError) as e:\n        # Return the raw error message as a single-item list\n        return None, [f\"JSON parse error: {str(e)}\"]\n\n    # Instantiate schema if a Field instance is not given\n    if isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n    elif hasattr(validator, 'deserialize'):\n        # assuming validator is a Field instance\n        schema = None\n    else:\n        # invalid validator type\n        raise TypeError(\"Validator must be a marshmallow Field instance or Schema class\")\n\n    errors = None\n    value = None\n    try:\n        if schema is not None:\n            # Validate with schema.load returning dict and possible errors\n            value = schema.load(data)\n        else:\n            # Validate with Field.deserialize which raises ValidationError on failure\n            value = validator.deserialize(data)\n    except ValidationError as err:\n        errors = err.messages\n\n    if errors:\n        # Flatten error messages with position info if possible\n        err_list = []\n        def flatten_errors(errs, prefix=''):\n            if isinstance(errs, dict):\n                for key, val in errs.items():\n                    flatten_errors(val, f\"{prefix}{key}.\")\n            elif isinstance(errs, list):\n                for item in errs:\n                    flatten_errors(item, prefix)\n            else:\n                err_list.append(f\"{prefix}{errs}\")\n\n        flatten_errors(errors)\n        return None, err_list\n    else:\n        return value, None\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import Schema, ValidationError, fields as ma_fields\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except json.JSONDecodeError as e:\n        # Returning error message with position information\n        # e.pos gives the position in the input string where parse failed\n        return None, [f\"JSON decode error at pos {e.pos}: {e.msg}\"]\n\n    # instantiate schema if validator is a Schema class\n    if isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n    elif isinstance(validator, ma_fields.Field):\n        # Create a temporary schema with a single field named 'root' to validate the data\n        class TempSchema(Schema):\n            root = validator\n\n        schema = TempSchema()\n        data = {'root': data}  # wrap data for validation\n    else:\n        return None, [\"Validator must be a Schema class or a marshmallow Field instance.\"]\n\n    try:\n        result = schema.load(data)\n        if isinstance(validator, ma_fields.Field):\n            # unwrap the data\n            result = result['root']\n        return result, []\n    except ValidationError as err:\n        errors = err.messages\n        # Format errors to include positional information if possible\n        def format_errors(errs, path=''):\n            msgs = []\n            if isinstance(errs, dict):\n                for key, val in errs.items():\n                    new_path = f\"{path}.{key}\" if path else key\n                    msgs.extend(format_errors(val, new_path))\n            elif isinstance(errs, list):\n                for item in errs:\n                    if isinstance(item, str):\n                        msgs.append(f\"{path}: {item}\" if path else item)\n                    else:\n                        msgs.extend(format_errors(item, path))\n            else:\n                if path:\n                    msgs.append(f\"{path}: {errs}\")\n                else:\n                    msgs.append(str(errs))\n            return msgs\n\n        error_messages = format_errors(errors)\n        return None, error_messages\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/typesystem\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\nimport typing\nfrom json.decoder import JSONDecodeError, JSONDecoder, scanstring \n\nfrom typesystem.base import Message, ParseError, Position, ValidationError\nfrom typesystem.fields import Field\nfrom typesystem.schemas import Schema\nfrom typesystem.tokenize.positional_validation import validate_with_positions\nfrom typesystem.tokenize.tokens import DictToken, ListToken, ScalarToken, Token\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r\"[ \\t\\n\\r]*\", FLAGS)\nWHITESPACE_STR = \" \\t\\n\\r\"\nNUMBER_RE = re.compile(\n    r\"(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\",\n    (re.VERBOSE | re.MULTILINE | re.DOTALL),\n)\n\n\ndef _TokenizingJSONObject(\n    s_and_end: typing.Tuple[str, int],\n    strict: bool,\n    scan_once: typing.Callable[[str, int], typing.Tuple[Token, int]],\n    memo: dict,\n    content: str,\n    _w: typing.Callable = WHITESPACE.match,\n    _ws: str = WHITESPACE_STR,\n) -> typing.Tuple[dict, int]:\n    s, end = s_and_end\n    pairs: typing.List[typing.Tuple[Token, Token]] = []\n    pairs_append = pairs.append\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end : end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end : end + 1]\n        # Trivial empty object\n        if nextchar == \"}\":\n            return {}, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end\n            )\n    end += 1\n    while True:\n        start = end - 1\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        key = ScalarToken(memo_get(key, key), start, end - 1, content)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end : end + 1] != \":\":\n            end = _w(s, end).end()\n            if s[end : end + 1] != \":\":\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \"\"\n        end += 1\n\n        if nextchar == \"}\":\n            break\n        elif nextchar != \",\":\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        end = _w(s, end).end()\n        nextchar = s[end : end + 1]\n        end += 1\n        if nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1\n            )\n    return dict(pairs), end\n\n\ndef _make_scanner(\n    context: typing.Any, content: str\n) -> typing.Callable[[str, int], typing.Tuple[Token, int]]:\n    parse_object = _TokenizingJSONObject\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    memo = context.memo\n\n    def _scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration(idx) from None\n\n        if nextchar == '\"':\n            value, end = parse_string(string, idx + 1, strict)\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"{\":\n            value, end = parse_object(\n                (string, idx + 1), strict, _scan_once, memo, content\n            )\n            return DictToken(value, idx, end - 1, content), end\n        elif nextchar == \"[\":\n            value, end = parse_array((string, idx + 1), _scan_once)\n            return ListToken(value, idx, end - 1, content), end\n        elif nextchar == \"n\" and string[idx : idx + 4] == \"null\":\n            value, end = None, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"t\" and string[idx : idx + 4] == \"true\":\n            value, end = True, idx + 4\n            return ScalarToken(value, idx, end - 1, content), end\n        elif nextchar == \"f\" and string[idx : idx + 5] == \"false\":\n            value, end = False, idx + 5\n            return ScalarToken(value, idx, end - 1, content), end\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \"\") + (exp or \"\"))\n            else:\n                res = parse_int(integer)\n            value, end = res, m.end()\n            return ScalarToken(value, idx, end - 1, content), end\n        else:  # pragma: no cover\n            raise StopIteration(idx)\n\n    def scan_once(string: str, idx: int) -> typing.Tuple[Token, int]:\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\n\nclass _TokenizingDecoder(JSONDecoder):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -> None:\n        content = kwargs.pop(\"content\")\n        super().__init__(*args, **kwargs)\n        self.scan_once = _make_scanner(self, content)\n\n\ndef tokenize_json(content: typing.Union[str, bytes]) -> Token:\n    if isinstance(content, bytes):\n        content = content.decode(\"utf-8\", \"ignore\")\n\n    if not content.strip():\n        # Handle the empty string case explicitly for clear error messaging.\n        position = Position(column_no=1, line_no=1, char_index=0)\n        raise ParseError(text=\"No content.\", code=\"no_content\", position=position)\n\n    decoder = _TokenizingDecoder(content=content)\n    try:\n        return decoder.decode(content)\n    except JSONDecodeError as exc:\n        # Handle cases that result in a JSON parse error.\n        position = Position(column_no=exc.colno, line_no=exc.lineno, char_index=exc.pos)\n        raise ParseError(text=exc.msg + \".\", code=\"parse_error\", position=position)\n\n\ndef validate_json(\n    content: typing.Union[str, bytes],\n    validator: typing.Union[Field, typing.Type[Schema]],\n) -> typing.Any:\n    \"\"\"\n    Parse and validate a JSON string, returning positionally marked error\n    messages on parse or validation failures.\n\n    content - A JSON string or bytestring.\n    validator - A Field instance or Schema class to validate against.\n\n    Returns a two-tuple of (value, error_messages)\n    \"\"\"\n    import json\n    from marshmallow import Schema, ValidationError, fields\n\n    try:\n        if isinstance(content, bytes):\n            content = content.decode('utf-8')\n        data = json.loads(content)\n    except json.JSONDecodeError as e:\n        # Return parse error with no value\n        pos = (e.lineno, e.colno)\n        error_message = {f\"line {pos[0]} col {pos[1]}\": [str(e)]}\n        return None, error_message\n\n    schema = None\n    if isinstance(validator, type) and issubclass(validator, Schema):\n        schema = validator()\n    elif isinstance(validator, fields.Field):\n        class TmpSchema(Schema):\n            tmp = validator\n        schema = TmpSchema()\n\n        data = {\"tmp\": data}\n    else:\n        raise TypeError(\"Validator must be a Field instance or a Schema class\")\n\n    try:\n        result = schema.load(data)\n        if isinstance(validator, fields.Field):\n            return result['tmp'], None\n        return result, None\n    except ValidationError as err:\n        return None, err.messages\n\n\nimport pickle\ndef test_4():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"name\": \"mike\"}', Schema) == output\ntest_4()\n\ndef test_7():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema), str) == output\ntest_7()\n\ndef test_14():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"code\": 200, \"message\": \"OK\"}', Schema) == output\ntest_14()\n\ndef test_18():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"a\": 23, \"b\": [1,2,3]}', Schema) == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json(b'{\"a\":\"hello\"}', Schema()) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+typesystem/test_output/typesystem+tokenize+tokenize_json/validate_json/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert validate_json('{\"test_field\": \"test\"}', Schema) == output\ntest_22()\n\n\n"]}
