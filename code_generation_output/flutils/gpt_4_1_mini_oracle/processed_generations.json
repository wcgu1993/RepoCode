{"task_id": 125, "project": "test-apps/flutils", "module": "flutils.packages", "predictions": ["from typing import Optional, Union\nfrom distutils.version import StrictVersion\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index and validate\n    pos = _build_version_bump_position(position)\n\n    # Get detailed version info\n    version_info = _build_version_info(version)\n\n    # Determine bump type based on position and prerelease input\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract the version parts as mutable variables\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Detect existing prerelease info at patch or minor level\n    current_pre_pos = version_info.pre_pos\n    current_pre_part = None\n    if current_pre_pos != -1:\n        # current pre-release part exists\n        if current_pre_pos == 1:\n            current_pre_part = version_info.minor\n        elif current_pre_pos == 2:\n            current_pre_part = version_info.patch\n\n    # Helper to convert bump_type int to actual increments and pre-release\n    def bump_and_build_version() -> str:\n        # Starting base values possibly adjusted by bump\n        new_major = major_num\n        new_minor = minor_num\n        new_patch = patch_num\n        pre_txt = ''\n        pre_num = -1\n\n        if bump_type == _BUMP_VERSION_MAJOR:\n            # Increment major, reset minor and patch\n            new_major += 1\n            new_minor = 0\n            new_patch = 0\n        elif bump_type == _BUMP_VERSION_MINOR:\n            new_minor += 1\n            new_patch = 0\n        elif bump_type == _BUMP_VERSION_PATCH:\n            new_patch += 1\n        elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n            # prerelease is alpha at minor\n            new_minor += 1\n            new_patch = 0\n            pre_txt = 'a'\n            pre_num = 0\n        elif bump_type == _BUMP_VERSION_MINOR_BETA:\n            new_minor += 1\n            new_patch = 0\n            pre_txt = 'b'\n            pre_num = 0\n        elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n            new_patch = patch_num  # stay same patch if prerelease bump at patch\n            pre_txt = 'a'\n            if current_pre_part and current_pre_part.pre_txt == 'a':\n                pre_num = current_pre_part.pre_num + 1\n            else:\n                pre_num = 0\n        elif bump_type == _BUMP_VERSION_PATCH_BETA:\n            new_patch = patch_num\n            pre_txt = 'b'\n            if current_pre_part and current_pre_part.pre_txt == 'b':\n                pre_num = current_pre_part.pre_num + 1\n            else:\n                pre_num = 0\n        else:\n            # Should not happen, bump_type validated upstream\n            raise ValueError(f\"Unknown bump_type {bump_type}\")\n\n        # Compose version string parts\n        # Major part always included\n        parts = [str(new_major)]\n\n        # Add minor only if > 0 or bump_type > _BUMP_VERSION_MAJOR to reduce trailing parts\n        # But examples show minor is always included for position 1 or 0 bumps\n        if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA) or new_minor != 0 or new_patch != 0:\n            parts.append(str(new_minor))\n\n        # Add patch if bump position is patch or there was patch part originally\n        # but if patch num is zero and pre-release at patch with alpha/beta the patch zero is kept\n        # Examples show patch generally included for position=2 bumps or if patch nonzero\n        # Special case: if bump at major (pos=0), example shows version like '2.0' (no patch). We'll omit patch if zero in that case.\n        if bump_type in (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA) or new_patch != 0:\n            # Only add patch if patch is non-zero or if bump_type targets patch (or alpha/beta patch)\n            # To align with examples: patch can be omitted if zero and bump_type is major or minor.\n            if not (bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA) and new_patch == 0):\n                # For patch zero, only include if example shows it (like '1.2.0'), else omit.\n                parts.append(str(new_patch))\n\n        # Build base version string\n        base_version = '.'.join(parts)\n\n        # Add prerelease if exists\n        if pre_num >= 0:\n            base_version += f\"{pre_txt}{pre_num}\"\n\n        return base_version\n\n    # Handle special case: if no pre_release argument but current version has pre-release,\n    # bumping without pre_release removes the pre-release by increasing the numeric portion appropriately.\n    # According to examples:\n    # bump_version('1.2.4a1') -> '1.2.4'\n    # bump_version('1.2.4b0') -> '1.2.4'\n    # So if pre_release is None and version is prerelease => remove prerelease by bumping numeric?\n    if pre_release is None and current_pre_pos != -1:\n        # We remove prerelease by incrementing the numeric part if possible\n        # Based on examples, bump_version('1.2.4a1') -> '1.2.4' (no bump, just strip prerelease)\n        # So, basically, remove prerelease without incrementing numeric part.\n        # That means return version without prerelease string\n\n        # Compose parts without prerelease\n        # The original version_parts are major.minor.patch as integers\n        # But if patch is zero and omitted in string, we should replicate that behavior.\n        # From _each_version_part, patch part is empty string if 0 at patch: '1.3' instead of '1.3.0'\n\n        # Construct version string removing prerelease\n\n        parts = [str(major_num)]\n\n        # Include minor if > 0 or patch>0 or minor prerelease\n        include_minor = (minor_num != 0) or (patch_num != 0) or (current_pre_pos == 1)\n\n        if include_minor:\n            parts.append(str(minor_num))\n\n        # Include patch if patch number > 0\n        include_patch = patch_num != 0\n\n        if include_patch:\n            parts.append(str(patch_num))\n\n        return '.'.join(parts)\n\n    # Otherwise proceed with normal bump and pre_release handling\n    return bump_and_build_version()", "from typing import Optional, Union\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n    _BUMP_VERSION_MINORS,\n    _BUMP_VERSION_PATCHES,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n\n    # Parse version into detailed parts\n    version_info = _build_version_info(version)\n\n    # Determine bump type (major, minor, patch, pre-release variants)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract base version components as a list of integers [major, minor, patch]\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Existing pre-release data\n    pre_pos = version_info.pre_pos\n    pre_txt = ''\n    pre_num = -1\n    if pre_pos != -1:\n        # Extract current prerelease info on that part\n        if pre_pos == 0:\n            # Major part cannot have prerelease per rules, but just in case\n            pre_txt, pre_num = '', -1\n        elif pre_pos == 1:\n            pre_txt = version_info.minor.pre_txt\n            pre_num = version_info.minor.pre_num\n        elif pre_pos == 2:\n            pre_txt = version_info.patch.pre_txt\n            pre_num = version_info.patch.pre_num\n\n    # Result parts (will build after bumping)\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n\n    # Function to clear lower parts after the bumped one\n    def clear_lower_parts(pos_to_clear: int):\n        nonlocal new_major, new_minor, new_patch\n        if pos_to_clear < 2:\n            new_patch = 0\n        if pos_to_clear < 1:\n            new_minor = 0\n\n    # Handle the bump types:\n    # bump_type tells exactly which kind of bump needed\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch, no prerelease allowed here\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increment minor, reset patch, remove prerelease\n        if pos > 2:\n            raise ValueError(f\"Invalid position {position} for minor bump\")\n        new_minor += 1\n        new_patch = 0\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increment patch, remove prerelease\n        if pos > 2:\n            raise ValueError(f\"Invalid position {position} for patch bump\")\n        new_patch += 1\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type in _BUMP_VERSION_MINORS:\n        # Minor pre-release bump: minor part stays same but prerelease bumps\n        # Position must be 1\n        if pos != 1:\n            raise ValueError(\"Minor alpha/beta bumps only allowed at position 1\")\n        # For pre-release minor bump:\n        # If current prerelease matches requested type (alpha or beta), increment pre_num\n        # Otherwise reset pre_num to 0 and set pre_txt to new pre-release type\n        is_alpha = bump_type == _BUMP_VERSION_MINOR_ALPHA\n        want_pre_txt = 'a' if is_alpha else 'b'\n        if pre_pos == 1 and pre_txt == want_pre_txt:\n            pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            pre_num = 0\n            pre_txt = want_pre_txt\n        # minor version number stays unchanged, patch set to 0 (don't bump it)\n        new_patch = 0\n        # major and minor stay unchanged\n        new_major = major_num\n        new_minor = minor_num\n\n    elif bump_type in _BUMP_VERSION_PATCHES:\n        # Patch pre-release bump: patch part stays same but prerelease bumps\n        # Position must be 2 (patch)\n        if pos != 2:\n            raise ValueError(\"Patch alpha/beta bumps only allowed at position 2\")\n        is_alpha = bump_type == _BUMP_VERSION_PATCH_ALPHA\n        want_pre_txt = 'a' if is_alpha else 'b'\n        if pre_pos == 2 and pre_txt == want_pre_txt:\n            pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            pre_num = 0\n            pre_txt = want_pre_txt\n        # major, minor, patch stay unchanged\n        new_major = major_num\n        new_minor = minor_num\n        new_patch = patch_num\n\n    else:\n        # Unknown bump type (should not occur)\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # If no pre_release argument given, but the version has prerelease, then\n    # we remove the prerelease by returning the cleaned version (strip prerelease)\n    if pre_release is None and pre_pos != -1:\n        # remove prerelease, return just \"major.minor.patch\" (dropping trailing zero patch if 0)\n        parts = [new_major, new_minor]\n        if new_patch != 0:\n            parts.append(new_patch)\n        else:\n            # in original code, patch 0 can be omitted if position < 2\n            pass\n        version_str = '.'.join(str(p) for p in parts)\n        return version_str\n\n    # Compose final version string with possible prerelease suffix:\n    parts = [str(new_major), str(new_minor)]\n    # Decide if patch part needed in the version string:\n    # If position is 0 or 1 and patch == 0, patch can be omitted\n    # If position is 2, patch always shown\n    if pos == 2 or new_patch != 0:\n        parts.append(str(new_patch))\n\n    version_str = '.'.join(parts)\n    if pre_txt and pre_num >= 0:\n        version_str += f\"{pre_txt}{pre_num}\"\n\n    return version_str", "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index, validating range\n    pos = _build_version_bump_position(position)\n\n    # Build detailed version information from the given version string\n    ver_info = _build_version_info(version)\n\n    # Determine the bump type constant based on position and pre_release indicator\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract parts for easy reference\n    major = ver_info.major\n    minor = ver_info.minor\n    patch = ver_info.patch\n\n    # Initialize new version parts as integers\n    new_major = major.num\n    new_minor = minor.num\n    new_patch = patch.num\n\n    # Determine current pre-release text and number for the bump position\n    cur_pre_txt = ''\n    cur_pre_num = -1\n    if ver_info.pre_pos == pos:\n        # There is a prerelease at the bumped position\n        if pos == 0:\n            # The code does not support prerelease on major (raises earlier)\n            pass\n        else:\n            # Assign existing prerelease text and number from the part\n            parts_map = {0: major, 1: minor, 2: patch}\n            part = parts_map[pos]\n            cur_pre_txt = part.pre_txt\n            cur_pre_num = part.pre_num\n\n    # Logic to bump version parts depending on bump_type:\n    # The bump types are:\n    # Major: 0\n    # Minor: 1\n    # Patch: 2\n    # Minor Alpha: 3\n    # Minor Beta: 4\n    # Patch Alpha: 5\n    # Patch Beta: 6\n\n    # We'll build the bumped version string at the end step by step.\n\n    # Function to reset lower parts when major/minor increments happen\n    def reset_lower_parts(upto_pos: int):\n        nonlocal new_major, new_minor, new_patch\n        # Reset parts below the given position\n        if upto_pos == 0:\n            new_minor = 0\n            new_patch = 0\n        elif upto_pos == 1:\n            new_patch = 0\n\n    # Primary bump logic\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        reset_lower_parts(0)\n        # Prerelease not allowed for major bump, so ignore any pre-release suffix\n        bumped_version = f\"{new_major}.0\"\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increment minor, reset patch, drop prerelease if any\n        new_minor += 1\n        new_patch = 0\n        bumped_version = f\"{new_major}.{new_minor}\"\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increment patch, drop prerelease if any\n        new_patch += 1\n        # Special case: if patch is 0 after increment (should not happen here), omit patch\n        if new_patch == 0:\n            # E.g. 1.2.0 -> '1.2'\n            bumped_version = f\"{new_major}.{new_minor}\"\n        else:\n            bumped_version = f\"{new_major}.{new_minor}.{new_patch}\"\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Minor pre-release bump (alpha: 3, beta:4)\n        # Reset patch to 0, increment minor if needed, handle prerelease number increment\n        # The pre-release tag depends on bump_type: alpha or beta\n\n        pre_txt = 'a' if bump_type == _BUMP_VERSION_MINOR_ALPHA else 'b'\n\n        # For minor prerelease bump:\n        # if current version's pre-release at minor position matches pre_txt,\n        # increment the pre-release num; else start at 0\n        # If current minor == ver_info.minor.num and prerelease matches pre_txt, bump pre_num\n        # else increment minor and start pre_num at 0\n\n        if pos != 1:\n            # Defensive, position for minor pre-release bump must be 1\n            raise ValueError(\"Minor pre-release bump must have position == 1\")\n\n        if ver_info.pre_pos == 1 and minor.pre_txt == pre_txt:\n            new_minor = minor.num\n            new_patch = 0\n            new_pre_num = minor.pre_num + 1\n        else:\n            # Increment minor, reset patch, start pre_num at 0\n            new_minor = minor.num + 1\n            new_patch = 0\n            new_pre_num = 0\n\n        # Prepare the bumped version string\n        bumped_version = f\"{new_major}.{new_minor}{pre_txt}{new_pre_num}\"\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Patch pre-release bump (alpha: 5, beta: 6)\n        pre_txt = 'a' if bump_type == _BUMP_VERSION_PATCH_ALPHA else 'b'\n\n        # For patch prerelease bump:\n        # if current version's pre-release at patch position matches pre_txt,\n        # increment the pre-release num; else start at 0\n        # If current patch == ver_info.patch.num and prerelease matches pre_txt, bump pre_num\n        # else increment patch and start pre_num at 0\n\n        if pos != 2:\n            # Defensive, position for patch pre-release bump must be 2\n            raise ValueError(\"Patch pre-release bump must have position == 2\")\n\n        if ver_info.pre_pos == 2 and patch.pre_txt == pre_txt:\n            new_patch = patch.num\n            new_pre_num = patch.pre_num + 1\n        else:\n            # Increment patch and start pre_num at 0\n            new_patch = patch.num + 1\n            new_pre_num = 0\n\n        # Prepare bumped version string\n        bumped_version = f\"{new_major}.{new_minor}.{new_patch}{pre_txt}{new_pre_num}\"\n    else:\n        # Defensive fallback: if bump_type unexpected, raise error\n        raise ValueError(f\"Unhandled bump type: {bump_type}\")\n\n    # If bump_type is *not* a prerelease, but the original version had a prerelease,\n    # and no pre_release argument was given, strip prerelease suffix (i.e., return final release)\n    # This is shown by examples: bump_version('1.2.4a1') -> '1.2.4'\n    # So if pre_release is None, and version has a prerelease component,\n    # and bump_type is a regular bump (major, minor, patch), strip the prerelease\n\n    is_prerelease_bump = bump_type in (\n        _BUMP_VERSION_MINOR_ALPHA,\n        _BUMP_VERSION_MINOR_BETA,\n        _BUMP_VERSION_PATCH_ALPHA,\n        _BUMP_VERSION_PATCH_BETA,\n    )\n\n    if not is_prerelease_bump and pre_release is None and ver_info.pre_pos != -1:\n        # Remove pre-release suffix from bumped_version:\n        # The bumped_version was built with no prerelease suffix,\n        # but original version had prerelease -> we want the final release version (no suffix)\n        # So nothing to remove actually, just return bumped_version as is.\n        # Because bumped_version was built without suffix already.\n\n        # But edge case: if bumped_version still has trailing zero patch which should not be displayed\n        # For example, if bumped_version ends with \".0\" in patch, drop it as per examples\n        # Actually, examples suggest that:\n        # - If patch == 0, and position==1, just return major.minor (e.g. '1.3')\n        # - If patch == 0, position==0, '2.0'\n        # - Else 'x.y.z'\n\n        # Already handled in bump string construction above.\n\n        pass\n\n    return bumped_version", "from typing import Optional, Union, cast, List\nfrom distutils.version import StrictVersion\n\n# Constants (copied from file content for standalone code)\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: tuple = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: tuple = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\n# NamedTuple for version parts\nfrom collections import namedtuple\n_VersionPart = namedtuple('_VersionPart', ['pos', 'txt', 'num', 'pre_txt', 'pre_num', 'name'])\n_VersionInfo = namedtuple('_VersionInfo', ['version', 'major', 'minor', 'patch', 'pre_pos'])\n\n\ndef _each_version_part(ver_obj: StrictVersion):\n    version = ver_obj.version\n    prerelease = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n\n        if (prerelease_built is False and pos > 0 and prerelease is not None):\n            prerelease = cast(tuple, prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\ndef _build_version_info(version: str) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(position: int) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Parse and validate version\n    ver_info = _build_version_info(version)\n\n    # Normalize position (handle negative and range checks)\n    position_positive = _build_version_bump_position(position)\n\n    bump_type = _build_version_bump_type(position_positive, pre_release)\n\n    # Extract version numbers to manipulate\n    major_num = ver_info.major.num\n    minor_num = ver_info.minor.num\n    patch_num = ver_info.patch.num\n\n    major_txt = ver_info.major.txt\n    minor_txt = ver_info.minor.txt\n    patch_txt = ver_info.patch.txt\n\n    major_pre_txt = ver_info.major.pre_txt\n    minor_pre_txt = ver_info.minor.pre_txt\n    patch_pre_txt = ver_info.patch.pre_txt\n\n    major_pre_num = ver_info.major.pre_num\n    minor_pre_num = ver_info.minor.pre_num\n    patch_pre_num = ver_info.patch.pre_num\n\n    # Handle bumps depending on type:\n    # First, some helper logic:\n\n    def _clear_lower_positions(start_pos: int):\n        # After bumping the given position, all lower positions should be reset to zero\n        nonlocal major_num, minor_num, patch_num\n        if start_pos <= 0:\n            minor_num = 0\n            patch_num = 0\n        elif start_pos == 1:\n            patch_num = 0\n        # For position 2 (patch), no lower to reset\n\n    def _clear_pre_releases_except(pos: int):\n        # Clear pre_release on all parts except the one at pos\n        nonlocal major_pre_txt, minor_pre_txt, patch_pre_txt\n        nonlocal major_pre_num, minor_pre_num, patch_pre_num\n        if pos != 0:\n            major_pre_txt = ''\n            major_pre_num = -1\n        if pos != 1:\n            minor_pre_txt = ''\n            minor_pre_num = -1\n        if pos != 2:\n            patch_pre_txt = ''\n            patch_pre_num = -1\n\n    # Determine if it's a pre-release bump or normal bump\n    is_pre_release = bump_type in _BUMP_VERSION_MINORS + _BUMP_VERSION_PATCHES\n\n    # For major bump, must not be pre-release (checked in _build_version_bump_type)\n\n    # Handle bump types:\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Major bump: increment major, reset minor and patch, drop pre-release\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        major_pre_txt = ''\n        major_pre_num = -1\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        # Return just major.minor (patch dropped if zero)\n        # According to example: bumping position=0 from 1.3.4 -> 2.0 (so patch dropped)\n        # So we return major.minor without patch if patch zero\n        # If patch is zero (which it always is here), omit patch\n        return f\"{major_num}.{minor_num}\"\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Minor bump normal: increment minor, reset patch, clear pre-release on minor and patch\n        minor_num += 1\n        patch_num = 0\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Patch bump normal\n        patch_num += 1\n\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n        # pre-release alpha bump on minor\n        # increment minor if jump from no pre-release or different pre-release?\n        # refer examples: bump_position=1, prerelease='a'\n\n        # We only bump pre_num if pre_txt matches alpha, else start a0\n        # or if previously beta, start alpha anew (0)\n\n        # If current minor pre_txt != 'a' or 'alpha', start at 0, else increment\n        if minor_pre_txt not in ('a', 'alpha'):\n            # new alpha pre-release\n            minor_num += 1\n            minor_pre_num = 0\n            minor_pre_txt = 'a'\n        else:\n            # increment alpha pre\n            minor_pre_num += 1\n\n        # clear patch and patch pre-release\n        patch_num = 0\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        # clear major pre-release\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_MINOR_BETA:\n        # pre-release beta bump on minor\n        if minor_pre_txt not in ('b', 'beta'):\n            minor_num += 1\n            minor_pre_num = 0\n            minor_pre_txt = 'b'\n        else:\n            minor_pre_num += 1\n\n        patch_num = 0\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n        # pre-release alpha bump on patch\n        if patch_pre_txt not in ('a', 'alpha'):\n            patch_num += 1\n            patch_pre_num = 0\n            patch_pre_txt = 'a'\n        else:\n            patch_pre_num += 1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    elif bump_type == _BUMP_VERSION_PATCH_BETA:\n        # pre-release beta bump on patch\n        if patch_pre_txt not in ('b', 'beta'):\n            patch_num += 1\n            patch_pre_num = 0\n            patch_pre_txt = 'b'\n        else:\n            patch_pre_num += 1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    else:\n        # Should never occur due to _build_version_bump_type validation\n        raise ValueError(\"Unsupported bump type: %r\" % bump_type)\n\n    # After bump, if no pre_release arg given but version had pre_release, we remove it (like examples)\n    if pre_release is None and (minor_pre_txt or patch_pre_txt):\n        # Remove pre-release from bumped minor or patch\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n    # Compose version string\n\n    def _compose_part(num: int, pre_txt: str, pre_num: int) -> str:\n        if num == 0 and pre_txt == '' and pre_num == -1:\n            # For patch zero, often ommitted (e.g., '1.2'), but in examples patch 0 is included sometimes\n            # Nicer to include zero, except in patch 0 at end with no pre-release - then omit patch\n            return '0'\n        part = str(num)\n        if pre_txt:\n            part += f\"{pre_txt}{pre_num}\"\n        return part\n\n    # Format depends on position, but safely always include major, minor,\n    # and include patch only if it is non-zero or needed\n\n    # According to examples:\n    # - major bump: output major.minor (patch zero omitted)\n    # - minor bump: output major.minor (patch zero omitted)\n    # - patch bump: output major.minor.patch\n    # - pre-release bumps may have alpha/beta suffix on minor or patch\n\n    # Determine text parts for output:\n    major_part = str(major_num)\n    # Include pre-release on major? Examples have no pre-release on major, so no\n\n    minor_part = str(minor_num)\n    if minor_pre_txt:\n        minor_part += f\"{minor_pre_txt}{minor_pre_num}\"\n\n    patch_part = ''\n    if patch_num != 0 or patch_pre_txt:\n        patch_part = str(patch_num)\n        if patch_pre_txt:\n            patch_part += f\"{patch_pre_txt}{patch_pre_num}\"\n\n    # Compose final version string:\n    # If patch is empty string or zero and position is 0 or 1 bump, omit patch (as in examples)\n    # Otherwise include patch part\n\n    if patch_part == '' or patch_part == '0':\n        # If patch empty or 0 without pre_release, omit patch\n        # Include patch if pre-release is on patch (non-empty patch_part)\n        if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n            # major or minor bumps -> return major.minor only\n            return f\"{major_part}.{minor_part}\"\n        else:\n            # patch bumps, include patch even if zero\n            # but example '1.2b0' bump with position=2 -> '1.2.1' means patch included\n            return f\"{major_part}.{minor_part}.0\"\n    else:\n        return f\"{major_part}.{minor_part}.{patch_part}\"", "from typing import Optional, Union, cast\nfrom distutils.version import StrictVersion\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS = (_BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES = (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA)\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart:\n    def __init__(self, pos: int, txt: str, num: int, pre_txt: str, pre_num: int, name: str) -> None:\n        self.pos = pos\n        self.txt = txt\n        self.num = num\n        self.pre_txt = pre_txt\n        self.pre_num = pre_num\n        self.name = name\n\n\ndef _each_version_part(ver_obj: StrictVersion):\n    version = ver_obj.version\n    prerelease = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        pre_txt = ''\n        pre_num = -1\n        if not prerelease_built and pos > 0 and prerelease is not None:\n            prerelease = cast(tuple, prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add:\n                txt = '%s%s%s' % (txt, prerelease[0], prerelease[1])\n                pre_txt = prerelease[0]\n                pre_num = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(pos, txt, num, pre_txt, pre_num, _BUMP_VERSION_POSITION_NAMES[pos])\n\n\nclass _VersionInfo:\n    def __init__(self, version: str, major: _VersionPart, minor: _VersionPart,\n                 patch: _VersionPart, pre_pos: int) -> None:\n        self.version = version\n        self.major = major\n        self.minor = minor\n        self.patch = patch\n        self.pre_pos = pre_pos\n\n\ndef _build_version_info(version: str) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    parts = []\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        parts.append(part)\n    # parts order: major, minor, patch\n    return _VersionInfo(version, parts[0], parts[1], parts[2], pre_pos)\n\n\ndef _build_version_bump_position(position: int) -> int:\n    pos_min = -3\n    pos_max = 2\n    if not (pos_min <= position <= pos_max):\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(position_positive: int, pre_release: Union[str, None]) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = prerelease in ('a', 'alpha')\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n    # Build current version info\n    info = _build_version_info(version)\n    # Determine bump type from position and pre_release\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current version parts for easier manipulation\n    major_num = info.major.num\n    minor_num = info.minor.num\n    patch_num = info.patch.num\n\n    major_pre_txt = info.major.pre_txt\n    major_pre_num = info.major.pre_num\n    minor_pre_txt = info.minor.pre_txt\n    minor_pre_num = info.minor.pre_num\n    patch_pre_txt = info.patch.pre_txt\n    patch_pre_num = info.patch.pre_num\n\n    # Define helper to format version parts with or without pre-release\n    def format_version_part(num: int, pre_txt: str = '', pre_num: int = -1) -> str:\n        if num == 0:\n            base = ''\n        else:\n            base = str(num)\n        if pre_txt and pre_num >= 0:\n            return f\"{base}{pre_txt}{pre_num}\"\n        return base\n\n    # Build new version components initialization\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n\n    # Manage bump logic based on bump_type:\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch to 0, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # pre-release not allowed on major, so no pre text/num\n        return f\"{new_major}.0\"\n\n    if bump_type in (_BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Bumping minor (may be prerelease)\n        new_minor = minor_num\n        new_patch = 0\n\n        if bump_type == _BUMP_VERSION_MINOR:\n            # Normal minor bump: increment minor, reset patch (no prerelease)\n            new_minor = minor_num + 1\n            # After bump, no prerelease allowed, so just \"X.Y\"\n            # Major untouched\n            return f\"{major_num}.{new_minor}\"\n        else:\n            # Minor prerelease bump (alpha or beta)\n            is_alpha = bump_type == _BUMP_VERSION_MINOR_ALPHA\n            pre_txt = 'a' if is_alpha else 'b'\n            # Determine number for prerelease:\n            if info.pre_pos == 1 and minor_pre_txt == pre_txt and minor_pre_num >= 0:\n                # bump existing prerelease number\n                new_pre_num = minor_pre_num + 1\n            else:\n                # start new prerelease at 0\n                new_pre_num = 0\n\n            # increment minor if not already incremented to start prerelease (if current minor is different)\n            if info.pre_pos != 1 or minor_pre_txt != pre_txt:\n                # This indicates the version wasn't already on this prerelease, so bump minor\n                new_minor = minor_num + 1\n            return f\"{major_num}.{new_minor}{pre_txt}{new_pre_num}\"\n\n    if bump_type in (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Bumping patch (may be prerelease)\n        new_patch = patch_num\n\n        if bump_type == _BUMP_VERSION_PATCH:\n            # Normal patch bump: increment patch, no prerelease\n            new_patch = patch_num + 1\n            return f\"{major_num}.{minor_num}.{new_patch}\"\n\n        # Patch prerelease bump alpha or beta\n        is_alpha = bump_type == _BUMP_VERSION_PATCH_ALPHA\n        pre_txt = 'a' if is_alpha else 'b'\n        # Determine number for prerelease:\n        if info.pre_pos == 2 and patch_pre_txt == pre_txt and patch_pre_num >= 0:\n            new_pre_num = patch_pre_num + 1\n            new_patch = patch_num\n        else:\n            # If current prerelease is different or doesn't exist, start patch bump from patch_num +1 pre 0\n            # But if it was a prerelease with different pre_txt (ex. a->b), keep patch_num unchanged and reset\n            # Need to handle cases like bump_version('1.2.4a1', pre_release='b') -> '1.2.4b0'\n            if info.pre_pos == 2:\n                # Different prerelease on patch part\n                new_pre_num = 0\n                new_patch = patch_num\n            else:\n                # No prerelease or prerelease on other position: increment patch and start prerelease\n                new_patch = patch_num + 1\n                new_pre_num = 0\n\n        return f\"{major_num}.{minor_num}.{new_patch}{pre_txt}{new_pre_num}\"\n\n    # If none matched (should not happen)\n    raise RuntimeError(\"Unhandled bump type\")"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional, Union\nfrom distutils.version import StrictVersion\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index and validate\n    pos = _build_version_bump_position(position)\n\n    # Get detailed version info\n    version_info = _build_version_info(version)\n\n    # Determine bump type based on position and prerelease input\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract the version parts as mutable variables\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Detect existing prerelease info at patch or minor level\n    current_pre_pos = version_info.pre_pos\n    current_pre_part = None\n    if current_pre_pos != -1:\n        # current pre-release part exists\n        if current_pre_pos == 1:\n            current_pre_part = version_info.minor\n        elif current_pre_pos == 2:\n            current_pre_part = version_info.patch\n\n    # Helper to convert bump_type int to actual increments and pre-release\n    def bump_and_build_version() -> str:\n        # Starting base values possibly adjusted by bump\n        new_major = major_num\n        new_minor = minor_num\n        new_patch = patch_num\n        pre_txt = ''\n        pre_num = -1\n\n        if bump_type == _BUMP_VERSION_MAJOR:\n            # Increment major, reset minor and patch\n            new_major += 1\n            new_minor = 0\n            new_patch = 0\n        elif bump_type == _BUMP_VERSION_MINOR:\n            new_minor += 1\n            new_patch = 0\n        elif bump_type == _BUMP_VERSION_PATCH:\n            new_patch += 1\n        elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n            # prerelease is alpha at minor\n            new_minor += 1\n            new_patch = 0\n            pre_txt = 'a'\n            pre_num = 0\n        elif bump_type == _BUMP_VERSION_MINOR_BETA:\n            new_minor += 1\n            new_patch = 0\n            pre_txt = 'b'\n            pre_num = 0\n        elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n            new_patch = patch_num  # stay same patch if prerelease bump at patch\n            pre_txt = 'a'\n            if current_pre_part and current_pre_part.pre_txt == 'a':\n                pre_num = current_pre_part.pre_num + 1\n            else:\n                pre_num = 0\n        elif bump_type == _BUMP_VERSION_PATCH_BETA:\n            new_patch = patch_num\n            pre_txt = 'b'\n            if current_pre_part and current_pre_part.pre_txt == 'b':\n                pre_num = current_pre_part.pre_num + 1\n            else:\n                pre_num = 0\n        else:\n            # Should not happen, bump_type validated upstream\n            raise ValueError(f\"Unknown bump_type {bump_type}\")\n\n        # Compose version string parts\n        # Major part always included\n        parts = [str(new_major)]\n\n        # Add minor only if > 0 or bump_type > _BUMP_VERSION_MAJOR to reduce trailing parts\n        # But examples show minor is always included for position 1 or 0 bumps\n        if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA) or new_minor != 0 or new_patch != 0:\n            parts.append(str(new_minor))\n\n        # Add patch if bump position is patch or there was patch part originally\n        # but if patch num is zero and pre-release at patch with alpha/beta the patch zero is kept\n        # Examples show patch generally included for position=2 bumps or if patch nonzero\n        # Special case: if bump at major (pos=0), example shows version like '2.0' (no patch). We'll omit patch if zero in that case.\n        if bump_type in (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA) or new_patch != 0:\n            # Only add patch if patch is non-zero or if bump_type targets patch (or alpha/beta patch)\n            # To align with examples: patch can be omitted if zero and bump_type is major or minor.\n            if not (bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA) and new_patch == 0):\n                # For patch zero, only include if example shows it (like '1.2.0'), else omit.\n                parts.append(str(new_patch))\n\n        # Build base version string\n        base_version = '.'.join(parts)\n\n        # Add prerelease if exists\n        if pre_num >= 0:\n            base_version += f\"{pre_txt}{pre_num}\"\n\n        return base_version\n\n    # Handle special case: if no pre_release argument but current version has pre-release,\n    # bumping without pre_release removes the pre-release by increasing the numeric portion appropriately.\n    # According to examples:\n    # bump_version('1.2.4a1') -> '1.2.4'\n    # bump_version('1.2.4b0') -> '1.2.4'\n    # So if pre_release is None and version is prerelease => remove prerelease by bumping numeric?\n    if pre_release is None and current_pre_pos != -1:\n        # We remove prerelease by incrementing the numeric part if possible\n        # Based on examples, bump_version('1.2.4a1') -> '1.2.4' (no bump, just strip prerelease)\n        # So, basically, remove prerelease without incrementing numeric part.\n        # That means return version without prerelease string\n\n        # Compose parts without prerelease\n        # The original version_parts are major.minor.patch as integers\n        # But if patch is zero and omitted in string, we should replicate that behavior.\n        # From _each_version_part, patch part is empty string if 0 at patch: '1.3' instead of '1.3.0'\n\n        # Construct version string removing prerelease\n\n        parts = [str(major_num)]\n\n        # Include minor if > 0 or patch>0 or minor prerelease\n        include_minor = (minor_num != 0) or (patch_num != 0) or (current_pre_pos == 1)\n\n        if include_minor:\n            parts.append(str(minor_num))\n\n        # Include patch if patch number > 0\n        include_patch = patch_num != 0\n\n        if include_patch:\n            parts.append(str(patch_num))\n\n        return '.'.join(parts)\n\n    # Otherwise proceed with normal bump and pre_release handling\n    return bump_and_build_version()\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional, Union\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n    _BUMP_VERSION_MINORS,\n    _BUMP_VERSION_PATCHES,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n\n    # Parse version into detailed parts\n    version_info = _build_version_info(version)\n\n    # Determine bump type (major, minor, patch, pre-release variants)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract base version components as a list of integers [major, minor, patch]\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Existing pre-release data\n    pre_pos = version_info.pre_pos\n    pre_txt = ''\n    pre_num = -1\n    if pre_pos != -1:\n        # Extract current prerelease info on that part\n        if pre_pos == 0:\n            # Major part cannot have prerelease per rules, but just in case\n            pre_txt, pre_num = '', -1\n        elif pre_pos == 1:\n            pre_txt = version_info.minor.pre_txt\n            pre_num = version_info.minor.pre_num\n        elif pre_pos == 2:\n            pre_txt = version_info.patch.pre_txt\n            pre_num = version_info.patch.pre_num\n\n    # Result parts (will build after bumping)\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n\n    # Function to clear lower parts after the bumped one\n    def clear_lower_parts(pos_to_clear: int):\n        nonlocal new_major, new_minor, new_patch\n        if pos_to_clear < 2:\n            new_patch = 0\n        if pos_to_clear < 1:\n            new_minor = 0\n\n    # Handle the bump types:\n    # bump_type tells exactly which kind of bump needed\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch, no prerelease allowed here\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increment minor, reset patch, remove prerelease\n        if pos > 2:\n            raise ValueError(f\"Invalid position {position} for minor bump\")\n        new_minor += 1\n        new_patch = 0\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increment patch, remove prerelease\n        if pos > 2:\n            raise ValueError(f\"Invalid position {position} for patch bump\")\n        new_patch += 1\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type in _BUMP_VERSION_MINORS:\n        # Minor pre-release bump: minor part stays same but prerelease bumps\n        # Position must be 1\n        if pos != 1:\n            raise ValueError(\"Minor alpha/beta bumps only allowed at position 1\")\n        # For pre-release minor bump:\n        # If current prerelease matches requested type (alpha or beta), increment pre_num\n        # Otherwise reset pre_num to 0 and set pre_txt to new pre-release type\n        is_alpha = bump_type == _BUMP_VERSION_MINOR_ALPHA\n        want_pre_txt = 'a' if is_alpha else 'b'\n        if pre_pos == 1 and pre_txt == want_pre_txt:\n            pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            pre_num = 0\n            pre_txt = want_pre_txt\n        # minor version number stays unchanged, patch set to 0 (don't bump it)\n        new_patch = 0\n        # major and minor stay unchanged\n        new_major = major_num\n        new_minor = minor_num\n\n    elif bump_type in _BUMP_VERSION_PATCHES:\n        # Patch pre-release bump: patch part stays same but prerelease bumps\n        # Position must be 2 (patch)\n        if pos != 2:\n            raise ValueError(\"Patch alpha/beta bumps only allowed at position 2\")\n        is_alpha = bump_type == _BUMP_VERSION_PATCH_ALPHA\n        want_pre_txt = 'a' if is_alpha else 'b'\n        if pre_pos == 2 and pre_txt == want_pre_txt:\n            pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            pre_num = 0\n            pre_txt = want_pre_txt\n        # major, minor, patch stay unchanged\n        new_major = major_num\n        new_minor = minor_num\n        new_patch = patch_num\n\n    else:\n        # Unknown bump type (should not occur)\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # If no pre_release argument given, but the version has prerelease, then\n    # we remove the prerelease by returning the cleaned version (strip prerelease)\n    if pre_release is None and pre_pos != -1:\n        # remove prerelease, return just \"major.minor.patch\" (dropping trailing zero patch if 0)\n        parts = [new_major, new_minor]\n        if new_patch != 0:\n            parts.append(new_patch)\n        else:\n            # in original code, patch 0 can be omitted if position < 2\n            pass\n        version_str = '.'.join(str(p) for p in parts)\n        return version_str\n\n    # Compose final version string with possible prerelease suffix:\n    parts = [str(new_major), str(new_minor)]\n    # Decide if patch part needed in the version string:\n    # If position is 0 or 1 and patch == 0, patch can be omitted\n    # If position is 2, patch always shown\n    if pos == 2 or new_patch != 0:\n        parts.append(str(new_patch))\n\n    version_str = '.'.join(parts)\n    if pre_txt and pre_num >= 0:\n        version_str += f\"{pre_txt}{pre_num}\"\n\n    return version_str\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index, validating range\n    pos = _build_version_bump_position(position)\n\n    # Build detailed version information from the given version string\n    ver_info = _build_version_info(version)\n\n    # Determine the bump type constant based on position and pre_release indicator\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract parts for easy reference\n    major = ver_info.major\n    minor = ver_info.minor\n    patch = ver_info.patch\n\n    # Initialize new version parts as integers\n    new_major = major.num\n    new_minor = minor.num\n    new_patch = patch.num\n\n    # Determine current pre-release text and number for the bump position\n    cur_pre_txt = ''\n    cur_pre_num = -1\n    if ver_info.pre_pos == pos:\n        # There is a prerelease at the bumped position\n        if pos == 0:\n            # The code does not support prerelease on major (raises earlier)\n            pass\n        else:\n            # Assign existing prerelease text and number from the part\n            parts_map = {0: major, 1: minor, 2: patch}\n            part = parts_map[pos]\n            cur_pre_txt = part.pre_txt\n            cur_pre_num = part.pre_num\n\n    # Logic to bump version parts depending on bump_type:\n    # The bump types are:\n    # Major: 0\n    # Minor: 1\n    # Patch: 2\n    # Minor Alpha: 3\n    # Minor Beta: 4\n    # Patch Alpha: 5\n    # Patch Beta: 6\n\n    # We'll build the bumped version string at the end step by step.\n\n    # Function to reset lower parts when major/minor increments happen\n    def reset_lower_parts(upto_pos: int):\n        nonlocal new_major, new_minor, new_patch\n        # Reset parts below the given position\n        if upto_pos == 0:\n            new_minor = 0\n            new_patch = 0\n        elif upto_pos == 1:\n            new_patch = 0\n\n    # Primary bump logic\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        reset_lower_parts(0)\n        # Prerelease not allowed for major bump, so ignore any pre-release suffix\n        bumped_version = f\"{new_major}.0\"\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increment minor, reset patch, drop prerelease if any\n        new_minor += 1\n        new_patch = 0\n        bumped_version = f\"{new_major}.{new_minor}\"\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increment patch, drop prerelease if any\n        new_patch += 1\n        # Special case: if patch is 0 after increment (should not happen here), omit patch\n        if new_patch == 0:\n            # E.g. 1.2.0 -> '1.2'\n            bumped_version = f\"{new_major}.{new_minor}\"\n        else:\n            bumped_version = f\"{new_major}.{new_minor}.{new_patch}\"\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Minor pre-release bump (alpha: 3, beta:4)\n        # Reset patch to 0, increment minor if needed, handle prerelease number increment\n        # The pre-release tag depends on bump_type: alpha or beta\n\n        pre_txt = 'a' if bump_type == _BUMP_VERSION_MINOR_ALPHA else 'b'\n\n        # For minor prerelease bump:\n        # if current version's pre-release at minor position matches pre_txt,\n        # increment the pre-release num; else start at 0\n        # If current minor == ver_info.minor.num and prerelease matches pre_txt, bump pre_num\n        # else increment minor and start pre_num at 0\n\n        if pos != 1:\n            # Defensive, position for minor pre-release bump must be 1\n            raise ValueError(\"Minor pre-release bump must have position == 1\")\n\n        if ver_info.pre_pos == 1 and minor.pre_txt == pre_txt:\n            new_minor = minor.num\n            new_patch = 0\n            new_pre_num = minor.pre_num + 1\n        else:\n            # Increment minor, reset patch, start pre_num at 0\n            new_minor = minor.num + 1\n            new_patch = 0\n            new_pre_num = 0\n\n        # Prepare the bumped version string\n        bumped_version = f\"{new_major}.{new_minor}{pre_txt}{new_pre_num}\"\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Patch pre-release bump (alpha: 5, beta: 6)\n        pre_txt = 'a' if bump_type == _BUMP_VERSION_PATCH_ALPHA else 'b'\n\n        # For patch prerelease bump:\n        # if current version's pre-release at patch position matches pre_txt,\n        # increment the pre-release num; else start at 0\n        # If current patch == ver_info.patch.num and prerelease matches pre_txt, bump pre_num\n        # else increment patch and start pre_num at 0\n\n        if pos != 2:\n            # Defensive, position for patch pre-release bump must be 2\n            raise ValueError(\"Patch pre-release bump must have position == 2\")\n\n        if ver_info.pre_pos == 2 and patch.pre_txt == pre_txt:\n            new_patch = patch.num\n            new_pre_num = patch.pre_num + 1\n        else:\n            # Increment patch and start pre_num at 0\n            new_patch = patch.num + 1\n            new_pre_num = 0\n\n        # Prepare bumped version string\n        bumped_version = f\"{new_major}.{new_minor}.{new_patch}{pre_txt}{new_pre_num}\"\n    else:\n        # Defensive fallback: if bump_type unexpected, raise error\n        raise ValueError(f\"Unhandled bump type: {bump_type}\")\n\n    # If bump_type is *not* a prerelease, but the original version had a prerelease,\n    # and no pre_release argument was given, strip prerelease suffix (i.e., return final release)\n    # This is shown by examples: bump_version('1.2.4a1') -> '1.2.4'\n    # So if pre_release is None, and version has a prerelease component,\n    # and bump_type is a regular bump (major, minor, patch), strip the prerelease\n\n    is_prerelease_bump = bump_type in (\n        _BUMP_VERSION_MINOR_ALPHA,\n        _BUMP_VERSION_MINOR_BETA,\n        _BUMP_VERSION_PATCH_ALPHA,\n        _BUMP_VERSION_PATCH_BETA,\n    )\n\n    if not is_prerelease_bump and pre_release is None and ver_info.pre_pos != -1:\n        # Remove pre-release suffix from bumped_version:\n        # The bumped_version was built with no prerelease suffix,\n        # but original version had prerelease -> we want the final release version (no suffix)\n        # So nothing to remove actually, just return bumped_version as is.\n        # Because bumped_version was built without suffix already.\n\n        # But edge case: if bumped_version still has trailing zero patch which should not be displayed\n        # For example, if bumped_version ends with \".0\" in patch, drop it as per examples\n        # Actually, examples suggest that:\n        # - If patch == 0, and position==1, just return major.minor (e.g. '1.3')\n        # - If patch == 0, position==0, '2.0'\n        # - Else 'x.y.z'\n\n        # Already handled in bump string construction above.\n\n        pass\n\n    return bumped_version\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional, Union, cast, List\nfrom distutils.version import StrictVersion\n\n# Constants (copied from file content for standalone code)\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: tuple = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: tuple = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\n# NamedTuple for version parts\nfrom collections import namedtuple\n_VersionPart = namedtuple('_VersionPart', ['pos', 'txt', 'num', 'pre_txt', 'pre_num', 'name'])\n_VersionInfo = namedtuple('_VersionInfo', ['version', 'major', 'minor', 'patch', 'pre_pos'])\n\n\ndef _each_version_part(ver_obj: StrictVersion):\n    version = ver_obj.version\n    prerelease = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n\n        if (prerelease_built is False and pos > 0 and prerelease is not None):\n            prerelease = cast(tuple, prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\ndef _build_version_info(version: str) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(position: int) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Parse and validate version\n    ver_info = _build_version_info(version)\n\n    # Normalize position (handle negative and range checks)\n    position_positive = _build_version_bump_position(position)\n\n    bump_type = _build_version_bump_type(position_positive, pre_release)\n\n    # Extract version numbers to manipulate\n    major_num = ver_info.major.num\n    minor_num = ver_info.minor.num\n    patch_num = ver_info.patch.num\n\n    major_txt = ver_info.major.txt\n    minor_txt = ver_info.minor.txt\n    patch_txt = ver_info.patch.txt\n\n    major_pre_txt = ver_info.major.pre_txt\n    minor_pre_txt = ver_info.minor.pre_txt\n    patch_pre_txt = ver_info.patch.pre_txt\n\n    major_pre_num = ver_info.major.pre_num\n    minor_pre_num = ver_info.minor.pre_num\n    patch_pre_num = ver_info.patch.pre_num\n\n    # Handle bumps depending on type:\n    # First, some helper logic:\n\n    def _clear_lower_positions(start_pos: int):\n        # After bumping the given position, all lower positions should be reset to zero\n        nonlocal major_num, minor_num, patch_num\n        if start_pos <= 0:\n            minor_num = 0\n            patch_num = 0\n        elif start_pos == 1:\n            patch_num = 0\n        # For position 2 (patch), no lower to reset\n\n    def _clear_pre_releases_except(pos: int):\n        # Clear pre_release on all parts except the one at pos\n        nonlocal major_pre_txt, minor_pre_txt, patch_pre_txt\n        nonlocal major_pre_num, minor_pre_num, patch_pre_num\n        if pos != 0:\n            major_pre_txt = ''\n            major_pre_num = -1\n        if pos != 1:\n            minor_pre_txt = ''\n            minor_pre_num = -1\n        if pos != 2:\n            patch_pre_txt = ''\n            patch_pre_num = -1\n\n    # Determine if it's a pre-release bump or normal bump\n    is_pre_release = bump_type in _BUMP_VERSION_MINORS + _BUMP_VERSION_PATCHES\n\n    # For major bump, must not be pre-release (checked in _build_version_bump_type)\n\n    # Handle bump types:\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Major bump: increment major, reset minor and patch, drop pre-release\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        major_pre_txt = ''\n        major_pre_num = -1\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        # Return just major.minor (patch dropped if zero)\n        # According to example: bumping position=0 from 1.3.4 -> 2.0 (so patch dropped)\n        # So we return major.minor without patch if patch zero\n        # If patch is zero (which it always is here), omit patch\n        return f\"{major_num}.{minor_num}\"\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Minor bump normal: increment minor, reset patch, clear pre-release on minor and patch\n        minor_num += 1\n        patch_num = 0\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Patch bump normal\n        patch_num += 1\n\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n        # pre-release alpha bump on minor\n        # increment minor if jump from no pre-release or different pre-release?\n        # refer examples: bump_position=1, prerelease='a'\n\n        # We only bump pre_num if pre_txt matches alpha, else start a0\n        # or if previously beta, start alpha anew (0)\n\n        # If current minor pre_txt != 'a' or 'alpha', start at 0, else increment\n        if minor_pre_txt not in ('a', 'alpha'):\n            # new alpha pre-release\n            minor_num += 1\n            minor_pre_num = 0\n            minor_pre_txt = 'a'\n        else:\n            # increment alpha pre\n            minor_pre_num += 1\n\n        # clear patch and patch pre-release\n        patch_num = 0\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        # clear major pre-release\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_MINOR_BETA:\n        # pre-release beta bump on minor\n        if minor_pre_txt not in ('b', 'beta'):\n            minor_num += 1\n            minor_pre_num = 0\n            minor_pre_txt = 'b'\n        else:\n            minor_pre_num += 1\n\n        patch_num = 0\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n        # pre-release alpha bump on patch\n        if patch_pre_txt not in ('a', 'alpha'):\n            patch_num += 1\n            patch_pre_num = 0\n            patch_pre_txt = 'a'\n        else:\n            patch_pre_num += 1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    elif bump_type == _BUMP_VERSION_PATCH_BETA:\n        # pre-release beta bump on patch\n        if patch_pre_txt not in ('b', 'beta'):\n            patch_num += 1\n            patch_pre_num = 0\n            patch_pre_txt = 'b'\n        else:\n            patch_pre_num += 1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    else:\n        # Should never occur due to _build_version_bump_type validation\n        raise ValueError(\"Unsupported bump type: %r\" % bump_type)\n\n    # After bump, if no pre_release arg given but version had pre_release, we remove it (like examples)\n    if pre_release is None and (minor_pre_txt or patch_pre_txt):\n        # Remove pre-release from bumped minor or patch\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n    # Compose version string\n\n    def _compose_part(num: int, pre_txt: str, pre_num: int) -> str:\n        if num == 0 and pre_txt == '' and pre_num == -1:\n            # For patch zero, often ommitted (e.g., '1.2'), but in examples patch 0 is included sometimes\n            # Nicer to include zero, except in patch 0 at end with no pre-release - then omit patch\n            return '0'\n        part = str(num)\n        if pre_txt:\n            part += f\"{pre_txt}{pre_num}\"\n        return part\n\n    # Format depends on position, but safely always include major, minor,\n    # and include patch only if it is non-zero or needed\n\n    # According to examples:\n    # - major bump: output major.minor (patch zero omitted)\n    # - minor bump: output major.minor (patch zero omitted)\n    # - patch bump: output major.minor.patch\n    # - pre-release bumps may have alpha/beta suffix on minor or patch\n\n    # Determine text parts for output:\n    major_part = str(major_num)\n    # Include pre-release on major? Examples have no pre-release on major, so no\n\n    minor_part = str(minor_num)\n    if minor_pre_txt:\n        minor_part += f\"{minor_pre_txt}{minor_pre_num}\"\n\n    patch_part = ''\n    if patch_num != 0 or patch_pre_txt:\n        patch_part = str(patch_num)\n        if patch_pre_txt:\n            patch_part += f\"{patch_pre_txt}{patch_pre_num}\"\n\n    # Compose final version string:\n    # If patch is empty string or zero and position is 0 or 1 bump, omit patch (as in examples)\n    # Otherwise include patch part\n\n    if patch_part == '' or patch_part == '0':\n        # If patch empty or 0 without pre_release, omit patch\n        # Include patch if pre-release is on patch (non-empty patch_part)\n        if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n            # major or minor bumps -> return major.minor only\n            return f\"{major_part}.{minor_part}\"\n        else:\n            # patch bumps, include patch even if zero\n            # but example '1.2b0' bump with position=2 -> '1.2.1' means patch included\n            return f\"{major_part}.{minor_part}.0\"\n    else:\n        return f\"{major_part}.{minor_part}.{patch_part}\"\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional, Union, cast\nfrom distutils.version import StrictVersion\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS = (_BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES = (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA)\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart:\n    def __init__(self, pos: int, txt: str, num: int, pre_txt: str, pre_num: int, name: str) -> None:\n        self.pos = pos\n        self.txt = txt\n        self.num = num\n        self.pre_txt = pre_txt\n        self.pre_num = pre_num\n        self.name = name\n\n\ndef _each_version_part(ver_obj: StrictVersion):\n    version = ver_obj.version\n    prerelease = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        pre_txt = ''\n        pre_num = -1\n        if not prerelease_built and pos > 0 and prerelease is not None:\n            prerelease = cast(tuple, prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add:\n                txt = '%s%s%s' % (txt, prerelease[0], prerelease[1])\n                pre_txt = prerelease[0]\n                pre_num = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(pos, txt, num, pre_txt, pre_num, _BUMP_VERSION_POSITION_NAMES[pos])\n\n\nclass _VersionInfo:\n    def __init__(self, version: str, major: _VersionPart, minor: _VersionPart,\n                 patch: _VersionPart, pre_pos: int) -> None:\n        self.version = version\n        self.major = major\n        self.minor = minor\n        self.patch = patch\n        self.pre_pos = pre_pos\n\n\ndef _build_version_info(version: str) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    parts = []\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        parts.append(part)\n    # parts order: major, minor, patch\n    return _VersionInfo(version, parts[0], parts[1], parts[2], pre_pos)\n\n\ndef _build_version_bump_position(position: int) -> int:\n    pos_min = -3\n    pos_max = 2\n    if not (pos_min <= position <= pos_max):\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(position_positive: int, pre_release: Union[str, None]) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = prerelease in ('a', 'alpha')\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n    # Build current version info\n    info = _build_version_info(version)\n    # Determine bump type from position and pre_release\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current version parts for easier manipulation\n    major_num = info.major.num\n    minor_num = info.minor.num\n    patch_num = info.patch.num\n\n    major_pre_txt = info.major.pre_txt\n    major_pre_num = info.major.pre_num\n    minor_pre_txt = info.minor.pre_txt\n    minor_pre_num = info.minor.pre_num\n    patch_pre_txt = info.patch.pre_txt\n    patch_pre_num = info.patch.pre_num\n\n    # Define helper to format version parts with or without pre-release\n    def format_version_part(num: int, pre_txt: str = '', pre_num: int = -1) -> str:\n        if num == 0:\n            base = ''\n        else:\n            base = str(num)\n        if pre_txt and pre_num >= 0:\n            return f\"{base}{pre_txt}{pre_num}\"\n        return base\n\n    # Build new version components initialization\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n\n    # Manage bump logic based on bump_type:\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch to 0, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # pre-release not allowed on major, so no pre text/num\n        return f\"{new_major}.0\"\n\n    if bump_type in (_BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Bumping minor (may be prerelease)\n        new_minor = minor_num\n        new_patch = 0\n\n        if bump_type == _BUMP_VERSION_MINOR:\n            # Normal minor bump: increment minor, reset patch (no prerelease)\n            new_minor = minor_num + 1\n            # After bump, no prerelease allowed, so just \"X.Y\"\n            # Major untouched\n            return f\"{major_num}.{new_minor}\"\n        else:\n            # Minor prerelease bump (alpha or beta)\n            is_alpha = bump_type == _BUMP_VERSION_MINOR_ALPHA\n            pre_txt = 'a' if is_alpha else 'b'\n            # Determine number for prerelease:\n            if info.pre_pos == 1 and minor_pre_txt == pre_txt and minor_pre_num >= 0:\n                # bump existing prerelease number\n                new_pre_num = minor_pre_num + 1\n            else:\n                # start new prerelease at 0\n                new_pre_num = 0\n\n            # increment minor if not already incremented to start prerelease (if current minor is different)\n            if info.pre_pos != 1 or minor_pre_txt != pre_txt:\n                # This indicates the version wasn't already on this prerelease, so bump minor\n                new_minor = minor_num + 1\n            return f\"{major_num}.{new_minor}{pre_txt}{new_pre_num}\"\n\n    if bump_type in (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Bumping patch (may be prerelease)\n        new_patch = patch_num\n\n        if bump_type == _BUMP_VERSION_PATCH:\n            # Normal patch bump: increment patch, no prerelease\n            new_patch = patch_num + 1\n            return f\"{major_num}.{minor_num}.{new_patch}\"\n\n        # Patch prerelease bump alpha or beta\n        is_alpha = bump_type == _BUMP_VERSION_PATCH_ALPHA\n        pre_txt = 'a' if is_alpha else 'b'\n        # Determine number for prerelease:\n        if info.pre_pos == 2 and patch_pre_txt == pre_txt and patch_pre_num >= 0:\n            new_pre_num = patch_pre_num + 1\n            new_patch = patch_num\n        else:\n            # If current prerelease is different or doesn't exist, start patch bump from patch_num +1 pre 0\n            # But if it was a prerelease with different pre_txt (ex. a->b), keep patch_num unchanged and reset\n            # Need to handle cases like bump_version('1.2.4a1', pre_release='b') -> '1.2.4b0'\n            if info.pre_pos == 2:\n                # Different prerelease on patch part\n                new_pre_num = 0\n                new_patch = patch_num\n            else:\n                # No prerelease or prerelease on other position: increment patch and start prerelease\n                new_patch = patch_num + 1\n                new_pre_num = 0\n\n        return f\"{major_num}.{minor_num}.{new_patch}{pre_txt}{new_pre_num}\"\n\n    # If none matched (should not happen)\n    raise RuntimeError(\"Unhandled bump type\")\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n"]}
{"task_id": 126, "project": "test-apps/flutils", "module": "flutils.namedtupleutils", "predictions": ["from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom types import SimpleNamespace\nfrom typing import (\n    NamedTuple,\n    Tuple,\n    List,\n    Union,\n    cast,\n)\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper to check if key is allowed attribute name for NamedTuple\n    def _is_valid_identifier(key: str) -> bool:\n        # Must be a valid python identifier, cannot start with underscore,\n        # and validated by external validate_identifier\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        return validate_identifier(key)\n\n    # Recursive conversion function\n    def _convert(obj: Any) -> Any:\n        # Lists: return new list with items converted recursively\n        if isinstance(obj, list):\n            return [_convert(item) for item in obj]\n\n        # Tuples: return new tuple with items converted recursively\n        if isinstance(obj, tuple):\n            return tuple(_convert(item) for item in obj)\n\n        # Mapping types (dict or OrderedDict)\n        if isinstance(obj, Mapping):\n            # Determine keys for NamedTuple:\n            # OrderedDict keys preserve order, dict keys are sorted\n            if isinstance(obj, OrderedDict):\n                keys = list(obj.keys())\n            else:\n                keys = sorted(obj.keys())\n\n            # Filter keys that are valid names (no underscore start and valid identifier)\n            filtered_keys = [k for k in keys if _is_valid_identifier(k)]\n\n            # Recursively convert values corresponding to filtered keys\n            values = [_convert(obj[k]) for k in filtered_keys]\n\n            # Create NamedTuple type with given fields order\n            NT = namedtuple('NamedTuple', filtered_keys)\n            return NT(*values)\n\n        # SimpleNamespace: treat attributes like a dict, attributes sorted\n        if isinstance(obj, SimpleNamespace):\n            attrs = {k: v for k, v in vars(obj).items() if _is_valid_identifier(k)}\n            keys = sorted(attrs.keys())\n            values = [_convert(attrs[k]) for k in keys]\n            NT = namedtuple('NamedTuple', keys)\n            return NT(*values)\n\n        # For already a NamedTuple: convert its fields like a tuple\n        if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n            # NamedTuple is a subclass of tuple with _fields attribute\n            # We convert its items recursively, output another NamedTuple instance with same fields\n            converted_items = tuple(_convert(getattr(obj, field)) for field in obj._fields)\n            NT = namedtuple(type(obj).__name__, obj._fields)\n            return NT(*converted_items)\n\n        # Other types: return as is\n        return obj\n\n    return _convert(obj)", "from collections import OrderedDict, namedtuple\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Tuple, List, Union, Any, cast\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Helper function to check if a string is a valid identifier and doesn't start with underscore\n    def _is_valid_identifier(name: Any) -> bool:\n        if not isinstance(name, str):\n            return False\n        if name.startswith(\"_\"):\n            return False\n        return validate_identifier(name)\n\n    # If the object is a list, return a new list where each item is converted recursively if possible\n    if isinstance(obj, list):\n        return [to_namedtuple(item) if _is_convertible(item) else item for item in obj]\n\n    # If the object is a tuple, return a new tuple with converted items recursively if possible\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) if _is_convertible(item) else item for item in obj)\n\n    # If the object is a Mapping (including dict and OrderedDict)\n    if isinstance(obj, Mapping):\n\n        # Determine the keys/attributes order:\n        # If OrderedDict: preserve order\n        # else: sort keys alphabetically\n\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(obj.keys())\n\n        # Filter keys that can be attribute names (valid identifiers, no leading underscore)\n        # and convert their corresponding values recursively\n\n        attrs = []\n        values = []\n\n        for key in keys:\n            if _is_valid_identifier(key):\n                attrs.append(key)\n                values.append(to_namedtuple(obj[key]))\n        # Build the namedtuple type\n        # Use a fixed typename, e.g. 'NamedTuple'\n        NTType = namedtuple('NamedTuple', attrs)\n        return NTType(*values)\n\n    # If the object is SimpleNamespace, attributes are the __dict__ keys, sorted alphabetically\n    if isinstance(obj, SimpleNamespace):\n        keys = sorted(vars(obj).keys())\n\n        attrs = []\n        values = []\n        for key in keys:\n            if _is_valid_identifier(key):\n                attrs.append(key)\n                values.append(to_namedtuple(getattr(obj, key)))\n        NTType = namedtuple('NamedTuple', attrs)\n        return NTType(*values)\n\n    # If the object is already a NamedTuple (or a tuple subclass with _fields)\n    # just return as is; this does not appear directly in doc, but safest to handle\n    if hasattr(obj, '_fields'):\n        # However, we may wish to recursively convert its values\n        # Let's convert fields to maintain recursive conversions\n        attrs = obj._fields\n        values = []\n        for attr in attrs:\n            value = getattr(obj, attr)\n            values.append(to_namedtuple(value) if _is_convertible(value) else value)\n        NTType = namedtuple(type(obj).__name__, attrs)\n        return NTType(*values)\n\n    # Otherwise, return the object as is\n    return obj\n\n\ndef _is_convertible(value: Any) -> bool:\n    \"\"\"Return True if the value is of a type that can be converted by to_namedtuple.\"\"\"\n\n    # Based on _AllowedTypes definition: list, Mapping, NamedTuple, SimpleNamespace, tuple\n\n    # Check for list or tuple\n    if isinstance(value, (list, tuple)):\n        return True\n\n    # Mapping types - dict, OrderedDict, etc.\n    if isinstance(value, Mapping):\n        return True\n\n    # SimpleNamespace\n    if isinstance(value, SimpleNamespace):\n        return True\n\n    # NamedTuple: any tuple subclass with _fields attribute is treated as NamedTuple\n    if hasattr(value, '_fields') and isinstance(value, tuple):\n        return True\n\n    return False", "from collections import OrderedDict, namedtuple\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, cast\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    def is_valid_identifier(s: str) -> bool:\n        # Valid identifiers do not start with underscore and satisfy Python identifier rule\n        return s.isidentifier() and not s.startswith('_')\n\n    # Recursive conversion starts here\n    # Handle list: return a new list with converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuple: return a new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # Handle Mapping (like dict or OrderedDict)\n    if isinstance(obj, Mapping):\n        # Determine keys for attributes\n        # Keys must be strings and valid identifiers and not starting with underscore\n        # For OrderedDict, keep order; otherwise, sort alphabetically\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            # sort keys alphabetically (converted to strings), but filter out bad keys first\n            keys = sorted(k for k in obj.keys() if isinstance(k, str))\n\n        # Filter keys to only valid identifiers and no underscore start\n        filtered_keys = [k for k in keys if isinstance(k, str) and is_valid_identifier(k)]\n\n        # Recursively convert values for these keys\n        values = [to_namedtuple(obj[k]) for k in filtered_keys]\n\n        # Create namedtuple type with name 'NamedTuple'\n        NT = namedtuple('NamedTuple', filtered_keys)\n        return NT(*values)\n\n    # Handle SimpleNamespace\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes dict\n        attrs = vars(obj)\n        # Sort keys alphabetically\n        keys = sorted(k for k in attrs.keys() if is_valid_identifier(k))\n        values = [to_namedtuple(attrs[k]) for k in keys]\n        NT = namedtuple('NamedTuple', keys)\n        return NT(*values)\n\n    # For NamedTuple instances or other types (including primitives), \n    # leave as is\n    return obj", "from collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Tuple, List, Union, Mapping, Any, cast\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper function to check if a string is a valid identifier for NamedTuple attribute\n    def is_valid_identifier(s: str) -> bool:\n        # Must not start with underscore, must be valid identifier, and validated by flutils.validator\n        if not isinstance(s, str):\n            return False\n        if s.startswith('_'):\n            return False\n        try:\n            # Use the validate_identifier function from flutils.validators to check validity\n            # If this raises, it's invalid\n            validate_identifier(s)\n            return True\n        except Exception:\n            return False\n\n    # If obj is a list, recursively convert each element and return a new list\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # If obj is a tuple, recursively convert each element and return a new tuple\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # If obj is a Mapping subclass (dict, OrderedDict), convert keys and values \n    if isinstance(obj, Mapping):\n        # Determine if obj is OrderedDict to preserve order or normal dict to sort keys\n        keys = list(obj.keys())\n        if isinstance(obj, OrderedDict):\n            # keep order\n            keys_for_attrs = keys\n        else:\n            # sort keys alphabetically\n            keys_for_attrs = sorted(keys)\n\n        # Filter keys to valid identifiers per rules (no underscore start and valid identifier)\n        valid_keys = [k for k in keys_for_attrs if is_valid_identifier(k)]\n\n        # Prepare values, recursively converted\n        values = [to_namedtuple(obj[k]) for k in valid_keys]\n\n        # Create a NamedTuple subclass dynamically with these valid keys\n        NT = namedtuple('NamedTuple', valid_keys)\n\n        # Instantiate and return\n        return NT(*values)\n\n    # If obj is a SimpleNamespace, treat similarly with sorting its __dict__ keys alphabetically\n    if isinstance(obj, SimpleNamespace):\n        attr_dict = vars(obj)\n        keys_for_attrs = sorted(attr_dict.keys())\n        valid_keys = [k for k in keys_for_attrs if is_valid_identifier(k)]\n        values = [to_namedtuple(attr_dict[k]) for k in valid_keys]\n\n        NT = namedtuple('NamedTuple', valid_keys)\n        return NT(*values)\n\n    # If obj is already a NamedTuple (has _fields attribute), then convert its fields recursively and rebuild it\n    # But the docstring doesn't explicitly mention this; we can safely return obj as is, or convert.\n    # Since NamedTuple is an instance of tuple and has _fields, we convert the fields recursively\n\n    # For safety, detect NamedTuple (has _fields) and is not a Mapping or SimpleNamespace or normal tuple or list.\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # Get the field names\n        field_names = obj._fields\n        # Recursively convert each field value\n        values = [to_namedtuple(getattr(obj, f)) for f in field_names]\n        NT = namedtuple(obj.__class__.__name__, field_names)\n        return NT(*values)\n\n    # For any other type, return as is\n    return obj", "from collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, Tuple, List, Mapping, Any, cast\n\n# We assume validate_identifier function is available from flutils.validators as per file content,\n# but since we must make the code self-contained, let's implement a minimal version here:\n# The description indicates keys must be proper identifiers and not start with underscore.\n# validate_identifier likely returns True if valid, False otherwise.\n# To avoid import, define a simple validator:\ndef validate_identifier(name: str) -> bool:\n    if not isinstance(name, str):\n        return False\n    if not name.isidentifier():\n        return False\n    if name.startswith('_'):\n        return False\n    return True\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Internal helper for recursively converting mapping to NamedTuple\n    def _mapping_to_namedtuple(mapping: Mapping[str, Any]) -> NamedTuple:\n        # Filter valid keys: strings that are valid identifiers and don't start with underscore\n        if isinstance(mapping, OrderedDict):\n            keys_iter = mapping.keys()\n        else:\n            keys_iter = sorted(mapping.keys())\n\n        # Collect attributes and recursively convert their values\n        attrs = []\n        values = []\n        for key in keys_iter:\n            # Only string keys that are valid identifiers and do not start with _\n            if isinstance(key, str) and validate_identifier(key):\n                value = mapping[key]\n                value = to_namedtuple(value)  # recursive convert\n                attrs.append(key)\n                values.append(value)\n            # keys not pass filter are ignored and not added as attributes\n\n        # Create a NamedTuple subclass dynamically with these attribute names\n        NT = namedtuple('NamedTuple', attrs)\n        return NT(*values)\n\n    # Main conversion logic:\n    # If list -> recurse each item and return new list\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # If tuple -> recurse each item and return new tuple\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # If SimpleNamespace -> convert vars (attributes) dict, sorted keys\n    if isinstance(obj, SimpleNamespace):\n        d = vars(obj)\n        # We must sort keys alphabetically, then filter by validate_identifier rules\n        # This logic is re-used in _mapping_to_namedtuple, so reuse that function by passing a sorted dict.\n        sorted_dict = OrderedDict(sorted(d.items()))\n        return _mapping_to_namedtuple(sorted_dict)\n\n    # If Mapping (dict or OrderedDict etc)\n    if isinstance(obj, Mapping):\n        # If OrderedDict: preserve order; else sort keys\n        # if OrderedDict, _mapping_to_namedtuple will preserve order\n        # if not ordered, we sort keys alphabetically in that function\n        return _mapping_to_namedtuple(obj)\n\n    # If NamedTuple (is a subclass of tuple with _fields attribute)\n    # According to _AllowedTypes, NamedTuple is allowed input.\n    # NamedTuple is a subclass of tuple, but has _fields attribute containing attribute names,\n    # but the docstring doesn't mention special treatment for input NamedTuple.\n    # Therefore, to follow the recursion rules, convert each field value and recreate the NamedTuple.\n\n    # If obj has _fields attribute and is tuple subclass, treat as NamedTuple\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # get type to reconstruct NamedTuple instance with same type\n        cls = type(obj)\n        # recurse each item\n        values = tuple(to_namedtuple(getattr(obj, field)) for field in obj._fields)\n        # create new instance with these values\n        return cls(*values)\n\n    # Otherwise, type not handled, return as is\n    return obj"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom types import SimpleNamespace\nfrom typing import (\n    NamedTuple,\n    Tuple,\n    List,\n    Union,\n    cast,\n)\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper to check if key is allowed attribute name for NamedTuple\n    def _is_valid_identifier(key: str) -> bool:\n        # Must be a valid python identifier, cannot start with underscore,\n        # and validated by external validate_identifier\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        return validate_identifier(key)\n\n    # Recursive conversion function\n    def _convert(obj: Any) -> Any:\n        # Lists: return new list with items converted recursively\n        if isinstance(obj, list):\n            return [_convert(item) for item in obj]\n\n        # Tuples: return new tuple with items converted recursively\n        if isinstance(obj, tuple):\n            return tuple(_convert(item) for item in obj)\n\n        # Mapping types (dict or OrderedDict)\n        if isinstance(obj, Mapping):\n            # Determine keys for NamedTuple:\n            # OrderedDict keys preserve order, dict keys are sorted\n            if isinstance(obj, OrderedDict):\n                keys = list(obj.keys())\n            else:\n                keys = sorted(obj.keys())\n\n            # Filter keys that are valid names (no underscore start and valid identifier)\n            filtered_keys = [k for k in keys if _is_valid_identifier(k)]\n\n            # Recursively convert values corresponding to filtered keys\n            values = [_convert(obj[k]) for k in filtered_keys]\n\n            # Create NamedTuple type with given fields order\n            NT = namedtuple('NamedTuple', filtered_keys)\n            return NT(*values)\n\n        # SimpleNamespace: treat attributes like a dict, attributes sorted\n        if isinstance(obj, SimpleNamespace):\n            attrs = {k: v for k, v in vars(obj).items() if _is_valid_identifier(k)}\n            keys = sorted(attrs.keys())\n            values = [_convert(attrs[k]) for k in keys]\n            NT = namedtuple('NamedTuple', keys)\n            return NT(*values)\n\n        # For already a NamedTuple: convert its fields like a tuple\n        if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n            # NamedTuple is a subclass of tuple with _fields attribute\n            # We convert its items recursively, output another NamedTuple instance with same fields\n            converted_items = tuple(_convert(getattr(obj, field)) for field in obj._fields)\n            NT = namedtuple(type(obj).__name__, obj._fields)\n            return NT(*converted_items)\n\n        # Other types: return as is\n        return obj\n\n    return _convert(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import OrderedDict, namedtuple\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Tuple, List, Union, Any, cast\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Helper function to check if a string is a valid identifier and doesn't start with underscore\n    def _is_valid_identifier(name: Any) -> bool:\n        if not isinstance(name, str):\n            return False\n        if name.startswith(\"_\"):\n            return False\n        return validate_identifier(name)\n\n    # If the object is a list, return a new list where each item is converted recursively if possible\n    if isinstance(obj, list):\n        return [to_namedtuple(item) if _is_convertible(item) else item for item in obj]\n\n    # If the object is a tuple, return a new tuple with converted items recursively if possible\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) if _is_convertible(item) else item for item in obj)\n\n    # If the object is a Mapping (including dict and OrderedDict)\n    if isinstance(obj, Mapping):\n\n        # Determine the keys/attributes order:\n        # If OrderedDict: preserve order\n        # else: sort keys alphabetically\n\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(obj.keys())\n\n        # Filter keys that can be attribute names (valid identifiers, no leading underscore)\n        # and convert their corresponding values recursively\n\n        attrs = []\n        values = []\n\n        for key in keys:\n            if _is_valid_identifier(key):\n                attrs.append(key)\n                values.append(to_namedtuple(obj[key]))\n        # Build the namedtuple type\n        # Use a fixed typename, e.g. 'NamedTuple'\n        NTType = namedtuple('NamedTuple', attrs)\n        return NTType(*values)\n\n    # If the object is SimpleNamespace, attributes are the __dict__ keys, sorted alphabetically\n    if isinstance(obj, SimpleNamespace):\n        keys = sorted(vars(obj).keys())\n\n        attrs = []\n        values = []\n        for key in keys:\n            if _is_valid_identifier(key):\n                attrs.append(key)\n                values.append(to_namedtuple(getattr(obj, key)))\n        NTType = namedtuple('NamedTuple', attrs)\n        return NTType(*values)\n\n    # If the object is already a NamedTuple (or a tuple subclass with _fields)\n    # just return as is; this does not appear directly in doc, but safest to handle\n    if hasattr(obj, '_fields'):\n        # However, we may wish to recursively convert its values\n        # Let's convert fields to maintain recursive conversions\n        attrs = obj._fields\n        values = []\n        for attr in attrs:\n            value = getattr(obj, attr)\n            values.append(to_namedtuple(value) if _is_convertible(value) else value)\n        NTType = namedtuple(type(obj).__name__, attrs)\n        return NTType(*values)\n\n    # Otherwise, return the object as is\n    return obj\n\n\ndef _is_convertible(value: Any) -> bool:\n    \"\"\"Return True if the value is of a type that can be converted by to_namedtuple.\"\"\"\n\n    # Based on _AllowedTypes definition: list, Mapping, NamedTuple, SimpleNamespace, tuple\n\n    # Check for list or tuple\n    if isinstance(value, (list, tuple)):\n        return True\n\n    # Mapping types - dict, OrderedDict, etc.\n    if isinstance(value, Mapping):\n        return True\n\n    # SimpleNamespace\n    if isinstance(value, SimpleNamespace):\n        return True\n\n    # NamedTuple: any tuple subclass with _fields attribute is treated as NamedTuple\n    if hasattr(value, '_fields') and isinstance(value, tuple):\n        return True\n\n    return False\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import OrderedDict, namedtuple\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, cast\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    def is_valid_identifier(s: str) -> bool:\n        # Valid identifiers do not start with underscore and satisfy Python identifier rule\n        return s.isidentifier() and not s.startswith('_')\n\n    # Recursive conversion starts here\n    # Handle list: return a new list with converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuple: return a new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # Handle Mapping (like dict or OrderedDict)\n    if isinstance(obj, Mapping):\n        # Determine keys for attributes\n        # Keys must be strings and valid identifiers and not starting with underscore\n        # For OrderedDict, keep order; otherwise, sort alphabetically\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            # sort keys alphabetically (converted to strings), but filter out bad keys first\n            keys = sorted(k for k in obj.keys() if isinstance(k, str))\n\n        # Filter keys to only valid identifiers and no underscore start\n        filtered_keys = [k for k in keys if isinstance(k, str) and is_valid_identifier(k)]\n\n        # Recursively convert values for these keys\n        values = [to_namedtuple(obj[k]) for k in filtered_keys]\n\n        # Create namedtuple type with name 'NamedTuple'\n        NT = namedtuple('NamedTuple', filtered_keys)\n        return NT(*values)\n\n    # Handle SimpleNamespace\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes dict\n        attrs = vars(obj)\n        # Sort keys alphabetically\n        keys = sorted(k for k in attrs.keys() if is_valid_identifier(k))\n        values = [to_namedtuple(attrs[k]) for k in keys]\n        NT = namedtuple('NamedTuple', keys)\n        return NT(*values)\n\n    # For NamedTuple instances or other types (including primitives), \n    # leave as is\n    return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Tuple, List, Union, Mapping, Any, cast\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper function to check if a string is a valid identifier for NamedTuple attribute\n    def is_valid_identifier(s: str) -> bool:\n        # Must not start with underscore, must be valid identifier, and validated by flutils.validator\n        if not isinstance(s, str):\n            return False\n        if s.startswith('_'):\n            return False\n        try:\n            # Use the validate_identifier function from flutils.validators to check validity\n            # If this raises, it's invalid\n            validate_identifier(s)\n            return True\n        except Exception:\n            return False\n\n    # If obj is a list, recursively convert each element and return a new list\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # If obj is a tuple, recursively convert each element and return a new tuple\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # If obj is a Mapping subclass (dict, OrderedDict), convert keys and values \n    if isinstance(obj, Mapping):\n        # Determine if obj is OrderedDict to preserve order or normal dict to sort keys\n        keys = list(obj.keys())\n        if isinstance(obj, OrderedDict):\n            # keep order\n            keys_for_attrs = keys\n        else:\n            # sort keys alphabetically\n            keys_for_attrs = sorted(keys)\n\n        # Filter keys to valid identifiers per rules (no underscore start and valid identifier)\n        valid_keys = [k for k in keys_for_attrs if is_valid_identifier(k)]\n\n        # Prepare values, recursively converted\n        values = [to_namedtuple(obj[k]) for k in valid_keys]\n\n        # Create a NamedTuple subclass dynamically with these valid keys\n        NT = namedtuple('NamedTuple', valid_keys)\n\n        # Instantiate and return\n        return NT(*values)\n\n    # If obj is a SimpleNamespace, treat similarly with sorting its __dict__ keys alphabetically\n    if isinstance(obj, SimpleNamespace):\n        attr_dict = vars(obj)\n        keys_for_attrs = sorted(attr_dict.keys())\n        valid_keys = [k for k in keys_for_attrs if is_valid_identifier(k)]\n        values = [to_namedtuple(attr_dict[k]) for k in valid_keys]\n\n        NT = namedtuple('NamedTuple', valid_keys)\n        return NT(*values)\n\n    # If obj is already a NamedTuple (has _fields attribute), then convert its fields recursively and rebuild it\n    # But the docstring doesn't explicitly mention this; we can safely return obj as is, or convert.\n    # Since NamedTuple is an instance of tuple and has _fields, we convert the fields recursively\n\n    # For safety, detect NamedTuple (has _fields) and is not a Mapping or SimpleNamespace or normal tuple or list.\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # Get the field names\n        field_names = obj._fields\n        # Recursively convert each field value\n        values = [to_namedtuple(getattr(obj, f)) for f in field_names]\n        NT = namedtuple(obj.__class__.__name__, field_names)\n        return NT(*values)\n\n    # For any other type, return as is\n    return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, Tuple, List, Mapping, Any, cast\n\n# We assume validate_identifier function is available from flutils.validators as per file content,\n# but since we must make the code self-contained, let's implement a minimal version here:\n# The description indicates keys must be proper identifiers and not start with underscore.\n# validate_identifier likely returns True if valid, False otherwise.\n# To avoid import, define a simple validator:\ndef validate_identifier(name: str) -> bool:\n    if not isinstance(name, str):\n        return False\n    if not name.isidentifier():\n        return False\n    if name.startswith('_'):\n        return False\n    return True\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Internal helper for recursively converting mapping to NamedTuple\n    def _mapping_to_namedtuple(mapping: Mapping[str, Any]) -> NamedTuple:\n        # Filter valid keys: strings that are valid identifiers and don't start with underscore\n        if isinstance(mapping, OrderedDict):\n            keys_iter = mapping.keys()\n        else:\n            keys_iter = sorted(mapping.keys())\n\n        # Collect attributes and recursively convert their values\n        attrs = []\n        values = []\n        for key in keys_iter:\n            # Only string keys that are valid identifiers and do not start with _\n            if isinstance(key, str) and validate_identifier(key):\n                value = mapping[key]\n                value = to_namedtuple(value)  # recursive convert\n                attrs.append(key)\n                values.append(value)\n            # keys not pass filter are ignored and not added as attributes\n\n        # Create a NamedTuple subclass dynamically with these attribute names\n        NT = namedtuple('NamedTuple', attrs)\n        return NT(*values)\n\n    # Main conversion logic:\n    # If list -> recurse each item and return new list\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # If tuple -> recurse each item and return new tuple\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # If SimpleNamespace -> convert vars (attributes) dict, sorted keys\n    if isinstance(obj, SimpleNamespace):\n        d = vars(obj)\n        # We must sort keys alphabetically, then filter by validate_identifier rules\n        # This logic is re-used in _mapping_to_namedtuple, so reuse that function by passing a sorted dict.\n        sorted_dict = OrderedDict(sorted(d.items()))\n        return _mapping_to_namedtuple(sorted_dict)\n\n    # If Mapping (dict or OrderedDict etc)\n    if isinstance(obj, Mapping):\n        # If OrderedDict: preserve order; else sort keys\n        # if OrderedDict, _mapping_to_namedtuple will preserve order\n        # if not ordered, we sort keys alphabetically in that function\n        return _mapping_to_namedtuple(obj)\n\n    # If NamedTuple (is a subclass of tuple with _fields attribute)\n    # According to _AllowedTypes, NamedTuple is allowed input.\n    # NamedTuple is a subclass of tuple, but has _fields attribute containing attribute names,\n    # but the docstring doesn't mention special treatment for input NamedTuple.\n    # Therefore, to follow the recursion rules, convert each field value and recreate the NamedTuple.\n\n    # If obj has _fields attribute and is tuple subclass, treat as NamedTuple\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # get type to reconstruct NamedTuple instance with same type\n        cls = type(obj)\n        # recurse each item\n        values = tuple(to_namedtuple(getattr(obj, field)) for field in obj._fields)\n        # create new instance with these values\n        return cls(*values)\n\n    # Otherwise, type not handled, return as is\n    return obj\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n"]}
{"task_id": 127, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["from typing import Tuple\nimport keyword\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # foreign_name format possibilities:\n    # 1) \"attr_name=mod_name.mod_attr_name\"  (attr_name set on module, comes from mod_name.mod_attr_name)\n    # 2) \"attr_name=mod_name\"                (attr_name set on module, comes from entire mod_name module)\n    # 3) \"mod_name.mod_attr_name\"            (attr_name is mod_attr_name, from mod_name.mod_attr_name)\n    # 4) \"mod_name\"                          (attr_name is mod_name, from entire mod_name module)\n\n    # We'll parse according to these rules:\n\n    line = foreign_name.strip()\n    if '=' in line:\n        # \"attr_name=rest\"\n        attr_name, rest = map(str.strip, line.split('=', 1))\n        attr_name = _validate_attr_identifier(attr_name, line)\n        if '.' in rest:\n            # rest is \"mod_name.mod_attr_name\"\n            mod_name, mod_attr_name = rest.rsplit('.', 1)\n            mod_name = mod_name.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n        else:\n            # rest is just \"mod_name\", entire module to be used\n            mod_name = rest\n            mod_attr_name = ''\n    else:\n        # No '=', so attr_name defaults from rightmost part as per format\n        if '.' in line:\n            # \"mod_name.mod_attr_name\"\n            mod_name, mod_attr_name = line.rsplit('.', 1)\n            mod_name = mod_name.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n            attr_name = mod_attr_name\n        else:\n            # \"mod_name\"\n            mod_name = line\n            mod_attr_name = ''\n            # attr_name is the last part of mod_name after splitting by '.'\n            attr_name = mod_name.rsplit('.', 1)[-1]\n\n        attr_name = _validate_attr_identifier(attr_name, line)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=line,\n    )", "from typing import Tuple\nimport keyword\n\n# _BUILTIN_NAMES and _DUNDERS are from file content; redefined here for the function to run standalone\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n_DUNDERS = (\n    '__author__',\n    '__author_email__',\n    '__description__',\n    '__doc__',\n    '__download_url__',\n    '__file__',\n    '__license__',\n    '__loader__maintainer_email__',  # Note: original file is missing a comma before 'maintainer'\n    '__maintainer__',\n    '__maintainer_email__',\n    '__path__',\n    '__python_requires__',\n    '__test_suite__',\n    '__url__',\n    '__version__'\n)\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n# _AttrMapping NamedTuple from file content\nfrom typing import NamedTuple\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n    item: str\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    item = foreign_name.strip()\n\n    # Split on colon first - splits to at most 2 parts\n    if ':' in item:\n        attr_name, foreign_name_remaining = map(str.strip, item.split(':', 1))\n    else:\n        attr_name = ''\n        foreign_name_remaining = item\n\n    # Split on dot to get mod_name and optional attribute on that module\n    if '.' in foreign_name_remaining:\n        mod_name, mod_attr_name = map(str.strip, foreign_name_remaining.split('.', 1))\n    else:\n        mod_name = foreign_name_remaining.strip()\n        mod_attr_name = ''\n\n    attr_name = _validate_attr_identifier(attr_name, item)\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name, item)", "from typing import Tuple\nfrom dataclasses import dataclass\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Strip whitespace\n    item = foreign_name.strip()\n\n    # Check if there is a single '=' separating attr_name and the rest\n    if '=' in item:\n        attr_name, rest = map(str.strip, item.split('=', 1))\n    else:\n        attr_name, rest = '', item\n\n    # Check if there is a ':' separating mod_name and mod_attr_name\n    if ':' in rest:\n        mod_name, mod_attr_name = map(str.strip, rest.split(':', 1))\n    else:\n        mod_name, mod_attr_name = rest, ''\n\n    # Validate attr_name only if it is given (non-empty)\n    from flutils.moduleutils import _validate_attr_identifier\n    if attr_name:\n        attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    else:\n        # If attr_name is empty, then mod_attr_name becomes attr_name if mod_attr_name exists\n        # But per spec, attr_name empty means entire module used. So leave attr_name empty.\n        attr_name = ''\n\n    # Validate mod_attr_name only if it is given (non-empty)\n    if mod_attr_name:\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=foreign_name,\n    )", "from typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Strip leading/trailing whitespace from the input string\n    line = foreign_name.strip()\n\n    # The foreign_name can be in one of these formats:\n    # 1. \"attr_name = mod_name.mod_attr_name\"  -> attribute aliasing\n    # 2. \"attr_name = mod_name\"                -> attr_name picks entire module\n    # 3. \"mod_name\"                           -> attr_name = last part of mod_name,\n    #                                          mod_attr_name = '' (entire module)\n    # 4. \"mod_name.mod_attr_name\"             -> attr_name = mod_attr_name,\n    #                                          module is mod_name\n\n    attr_name = ''\n    mod_name = ''\n    mod_attr_name = ''\n\n    if '=' in line:\n        # Case 1 and 2: \"attr_name = RHS\"\n        attr_name_part, rhs = map(str.strip, line.split('=', 1))\n\n        # Validate attr_name_part\n        attr_name = _validate_attr_identifier(attr_name_part, line)\n\n        # Now parse RHS: could be \"mod_name.mod_attr_name\" or just \"mod_name\"\n        if '.' in rhs:\n            mod_name_part, mod_attr_name_part = rhs.rsplit('.', 1)\n            mod_name = mod_name_part.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name_part.strip(), line)\n        else:\n            mod_name = rhs\n            mod_attr_name = ''\n\n    else:\n        # Case 3 or 4: No '=', so foreign_name is a module name or module + attribute\n        if '.' in line:\n            mod_name_part, mod_attr_name_part = line.rsplit('.', 1)\n            mod_name = mod_name_part.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name_part.strip(), line)\n            attr_name = mod_attr_name\n        else:\n            mod_name = line\n            mod_attr_name = ''\n            # attr_name is last part of mod_name\n            attr_name = _validate_attr_identifier(mod_name.rsplit('.', 1)[-1], line)\n\n    return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name)", "from typing import Tuple\nfrom types import SimpleNamespace\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # The format of foreign_name can be:\n    # \"attr_name=mod_name.mod_attr_name\"\n    # or \"attr_name=mod_name\"\n    # or just \"mod_name\" (the attribute name defaults to last part of mod_name)\n\n    # Start by splitting leftmost '=' to separate attr_name from mod part\n    if '=' in foreign_name:\n        attr_name_part, mod_full_part = foreign_name.split('=', 1)\n        attr_name_part = attr_name_part.strip()\n        mod_full_part = mod_full_part.strip()\n    else:\n        attr_name_part = ''\n        mod_full_part = foreign_name.strip()\n\n    # Now parse mod_full_part which may be dotted:\n    # If attr_name_part is set, then:\n    #   mod_name = all but last part of mod_full_part if there's a dot\n    #   mod_attr_name = last part of mod_full_part if there's a dot else ''\n    # else if attr_name_part is empty:\n    #   If there's a dot, attr_name = last part, mod_name = all but last part\n    #   if no dot, attr_name and mod_attr_name = ''\n\n    if attr_name_part:\n        # We have something like 'attr_name = mod_name[.mod_attr_name]'\n        if '.' in mod_full_part:\n            mod_name = mod_full_part.rsplit('.', 1)[0]\n            mod_attr_name = mod_full_part.rsplit('.', 1)[1]\n        else:\n            mod_name = mod_full_part\n            mod_attr_name = ''\n        attr_name = attr_name_part\n    else:\n        # No explicit attr_name; try to infer\n        if '.' in mod_full_part:\n            mod_name = mod_full_part.rsplit('.', 1)[0]\n            attr_name = mod_full_part.rsplit('.', 1)[1]\n            mod_attr_name = ''\n        else:\n            # Just a module name\n            mod_name = mod_full_part\n            attr_name = mod_full_part\n            mod_attr_name = ''\n\n    # Validate attr_name and mod_attr_name identifiers (mod_name is a module path, can have dots)\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=foreign_name,\n    )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nimport keyword\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # foreign_name format possibilities:\n    # 1) \"attr_name=mod_name.mod_attr_name\"  (attr_name set on module, comes from mod_name.mod_attr_name)\n    # 2) \"attr_name=mod_name\"                (attr_name set on module, comes from entire mod_name module)\n    # 3) \"mod_name.mod_attr_name\"            (attr_name is mod_attr_name, from mod_name.mod_attr_name)\n    # 4) \"mod_name\"                          (attr_name is mod_name, from entire mod_name module)\n\n    # We'll parse according to these rules:\n\n    line = foreign_name.strip()\n    if '=' in line:\n        # \"attr_name=rest\"\n        attr_name, rest = map(str.strip, line.split('=', 1))\n        attr_name = _validate_attr_identifier(attr_name, line)\n        if '.' in rest:\n            # rest is \"mod_name.mod_attr_name\"\n            mod_name, mod_attr_name = rest.rsplit('.', 1)\n            mod_name = mod_name.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n        else:\n            # rest is just \"mod_name\", entire module to be used\n            mod_name = rest\n            mod_attr_name = ''\n    else:\n        # No '=', so attr_name defaults from rightmost part as per format\n        if '.' in line:\n            # \"mod_name.mod_attr_name\"\n            mod_name, mod_attr_name = line.rsplit('.', 1)\n            mod_name = mod_name.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name, line)\n            attr_name = mod_attr_name\n        else:\n            # \"mod_name\"\n            mod_name = line\n            mod_attr_name = ''\n            # attr_name is the last part of mod_name after splitting by '.'\n            attr_name = mod_name.rsplit('.', 1)[-1]\n\n        attr_name = _validate_attr_identifier(attr_name, line)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=line,\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nimport keyword\n\n# _BUILTIN_NAMES and _DUNDERS are from file content; redefined here for the function to run standalone\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n_DUNDERS = (\n    '__author__',\n    '__author_email__',\n    '__description__',\n    '__doc__',\n    '__download_url__',\n    '__file__',\n    '__license__',\n    '__loader__maintainer_email__',  # Note: original file is missing a comma before 'maintainer'\n    '__maintainer__',\n    '__maintainer_email__',\n    '__path__',\n    '__python_requires__',\n    '__test_suite__',\n    '__url__',\n    '__version__'\n)\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n# _AttrMapping NamedTuple from file content\nfrom typing import NamedTuple\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n    item: str\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    item = foreign_name.strip()\n\n    # Split on colon first - splits to at most 2 parts\n    if ':' in item:\n        attr_name, foreign_name_remaining = map(str.strip, item.split(':', 1))\n    else:\n        attr_name = ''\n        foreign_name_remaining = item\n\n    # Split on dot to get mod_name and optional attribute on that module\n    if '.' in foreign_name_remaining:\n        mod_name, mod_attr_name = map(str.strip, foreign_name_remaining.split('.', 1))\n    else:\n        mod_name = foreign_name_remaining.strip()\n        mod_attr_name = ''\n\n    attr_name = _validate_attr_identifier(attr_name, item)\n\n    return _AttrMapping(attr_name, mod_name, mod_attr_name, item)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom dataclasses import dataclass\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Strip whitespace\n    item = foreign_name.strip()\n\n    # Check if there is a single '=' separating attr_name and the rest\n    if '=' in item:\n        attr_name, rest = map(str.strip, item.split('=', 1))\n    else:\n        attr_name, rest = '', item\n\n    # Check if there is a ':' separating mod_name and mod_attr_name\n    if ':' in rest:\n        mod_name, mod_attr_name = map(str.strip, rest.split(':', 1))\n    else:\n        mod_name, mod_attr_name = rest, ''\n\n    # Validate attr_name only if it is given (non-empty)\n    from flutils.moduleutils import _validate_attr_identifier\n    if attr_name:\n        attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    else:\n        # If attr_name is empty, then mod_attr_name becomes attr_name if mod_attr_name exists\n        # But per spec, attr_name empty means entire module used. So leave attr_name empty.\n        attr_name = ''\n\n    # Validate mod_attr_name only if it is given (non-empty)\n    if mod_attr_name:\n        mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=foreign_name,\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom flutils.moduleutils import _validate_attr_identifier\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # Strip leading/trailing whitespace from the input string\n    line = foreign_name.strip()\n\n    # The foreign_name can be in one of these formats:\n    # 1. \"attr_name = mod_name.mod_attr_name\"  -> attribute aliasing\n    # 2. \"attr_name = mod_name\"                -> attr_name picks entire module\n    # 3. \"mod_name\"                           -> attr_name = last part of mod_name,\n    #                                          mod_attr_name = '' (entire module)\n    # 4. \"mod_name.mod_attr_name\"             -> attr_name = mod_attr_name,\n    #                                          module is mod_name\n\n    attr_name = ''\n    mod_name = ''\n    mod_attr_name = ''\n\n    if '=' in line:\n        # Case 1 and 2: \"attr_name = RHS\"\n        attr_name_part, rhs = map(str.strip, line.split('=', 1))\n\n        # Validate attr_name_part\n        attr_name = _validate_attr_identifier(attr_name_part, line)\n\n        # Now parse RHS: could be \"mod_name.mod_attr_name\" or just \"mod_name\"\n        if '.' in rhs:\n            mod_name_part, mod_attr_name_part = rhs.rsplit('.', 1)\n            mod_name = mod_name_part.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name_part.strip(), line)\n        else:\n            mod_name = rhs\n            mod_attr_name = ''\n\n    else:\n        # Case 3 or 4: No '=', so foreign_name is a module name or module + attribute\n        if '.' in line:\n            mod_name_part, mod_attr_name_part = line.rsplit('.', 1)\n            mod_name = mod_name_part.strip()\n            mod_attr_name = _validate_attr_identifier(mod_attr_name_part.strip(), line)\n            attr_name = mod_attr_name\n        else:\n            mod_name = line\n            mod_attr_name = ''\n            # attr_name is last part of mod_name\n            attr_name = _validate_attr_identifier(mod_name.rsplit('.', 1)[-1], line)\n\n    return _AttrMapping(attr_name=attr_name, mod_name=mod_name, mod_attr_name=mod_attr_name)\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom typing import Tuple\nfrom types import SimpleNamespace\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    # The format of foreign_name can be:\n    # \"attr_name=mod_name.mod_attr_name\"\n    # or \"attr_name=mod_name\"\n    # or just \"mod_name\" (the attribute name defaults to last part of mod_name)\n\n    # Start by splitting leftmost '=' to separate attr_name from mod part\n    if '=' in foreign_name:\n        attr_name_part, mod_full_part = foreign_name.split('=', 1)\n        attr_name_part = attr_name_part.strip()\n        mod_full_part = mod_full_part.strip()\n    else:\n        attr_name_part = ''\n        mod_full_part = foreign_name.strip()\n\n    # Now parse mod_full_part which may be dotted:\n    # If attr_name_part is set, then:\n    #   mod_name = all but last part of mod_full_part if there's a dot\n    #   mod_attr_name = last part of mod_full_part if there's a dot else ''\n    # else if attr_name_part is empty:\n    #   If there's a dot, attr_name = last part, mod_name = all but last part\n    #   if no dot, attr_name and mod_attr_name = ''\n\n    if attr_name_part:\n        # We have something like 'attr_name = mod_name[.mod_attr_name]'\n        if '.' in mod_full_part:\n            mod_name = mod_full_part.rsplit('.', 1)[0]\n            mod_attr_name = mod_full_part.rsplit('.', 1)[1]\n        else:\n            mod_name = mod_full_part\n            mod_attr_name = ''\n        attr_name = attr_name_part\n    else:\n        # No explicit attr_name; try to infer\n        if '.' in mod_full_part:\n            mod_name = mod_full_part.rsplit('.', 1)[0]\n            attr_name = mod_full_part.rsplit('.', 1)[1]\n            mod_attr_name = ''\n        else:\n            # Just a module name\n            mod_name = mod_full_part\n            attr_name = mod_full_part\n            mod_attr_name = ''\n\n    # Validate attr_name and mod_attr_name identifiers (mod_name is a module path, can have dots)\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=foreign_name,\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()"]}
{"task_id": 128, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item, _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item, _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)", "from typing import Generator, Tuple\n\n# Assuming _AttrMapping and _expand_attr_map_item are defined in the same module or properly imported:\n# from .module_name import _AttrMapping, _expand_attr_map_item\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)", "from typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item, _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item, _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\n\n# Assuming _AttrMapping and _expand_attr_map_item are defined in the same module or properly imported:\n# from .module_name import _AttrMapping, _expand_attr_map_item\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nfrom typing import Generator, Tuple\nfrom flutils.moduleutils import _expand_attr_map_item\nfrom flutils.moduleutils import _AttrMapping\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for item in attr_map:\n        yield _expand_attr_map_item(item)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n"]}
{"task_id": 129, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["import base64\nfrom typing import Tuple, Union\nfrom collections.collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Remove whitespace and newlines to produce a valid base64 string\n    stripped_text = ''.join(text.split())\n\n    # Decode base64 string into bytes\n    decoded_bytes = base64.b64decode(stripped_text)\n\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize input: strip whitespace and newlines which may be present due to indentation or multiline text\n    # base64.b64decode can handle whitespace, but we explicitly strip leading/trailing whitespace to be safe.\n    # We do not care about errors argument as per docstring.\n\n    # If text is a UserString, convert it to str first\n    if isinstance(text, UserString):\n        raw_text = str(text)\n    else:\n        raw_text = text\n\n    # Strip leading/trailing whitespace and newlines from the input string\n    raw_text = raw_text.strip()\n\n    # Decode base64 string to bytes\n    decoded_bytes = base64.b64decode(raw_text, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections.collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize text: remove whitespace (spaces, newlines, indentation)\n    # base64 decode the normalized text\n    # Return the decoded bytes and its length\n    normalized_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(normalized_text)\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collections.collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize the input text: remove whitespace and linebreaks\n    # base64.b64decode ignores whitespace, but we explicitly strip to be safe\n    try:\n        # base64.b64decode accepts str and bytes. If str, ignores whitespace.\n        decoded_bytes = base64.b64decode(text, validate=True)\n    except Exception as e:\n        # If decoding fails, re-raise as Error from binascii with same message\n        from binascii import Error as BinAsciiError\n        raise BinAsciiError(str(e)) from e\n\n    return decoded_bytes, len(decoded_bytes)", "import base64\nfrom typing import Tuple, Union\nfrom collectionsctions import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize the input: remove whitespace and convert to base64 string\n    # Base64 decoding requires a string without whitespace and newlines\n    # We accept UserString or str - convert to str for processing\n    cleaned = ''.join(text.split())  # Remove all whitespace characters\n\n    # Decode the base64 string, which may raise binascii.Error if invalid,\n    # but no error argument handling is needed per the doc\n    decoded_bytes = base64.b64decode(cleaned, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections.collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Remove whitespace and newlines to produce a valid base64 string\n    stripped_text = ''.join(text.split())\n\n    # Decode base64 string into bytes\n    decoded_bytes = base64.b64decode(stripped_text)\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize input: strip whitespace and newlines which may be present due to indentation or multiline text\n    # base64.b64decode can handle whitespace, but we explicitly strip leading/trailing whitespace to be safe.\n    # We do not care about errors argument as per docstring.\n\n    # If text is a UserString, convert it to str first\n    if isinstance(text, UserString):\n        raw_text = str(text)\n    else:\n        raw_text = text\n\n    # Strip leading/trailing whitespace and newlines from the input string\n    raw_text = raw_text.strip()\n\n    # Decode base64 string to bytes\n    decoded_bytes = base64.b64decode(raw_text, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections.collections import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize text: remove whitespace (spaces, newlines, indentation)\n    # base64 decode the normalized text\n    # Return the decoded bytes and its length\n    normalized_text = ''.join(text.split())\n    decoded_bytes = base64.b64decode(normalized_text)\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collections.collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize the input text: remove whitespace and linebreaks\n    # base64.b64decode ignores whitespace, but we explicitly strip to be safe\n    try:\n        # base64.b64decode accepts str and bytes. If str, ignores whitespace.\n        decoded_bytes = base64.b64decode(text, validate=True)\n    except Exception as e:\n        # If decoding fails, re-raise as Error from binascii with same message\n        from binascii import Error as BinAsciiError\n        raise BinAsciiError(str(e)) from e\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom typing import Tuple, Union\nfrom collectionsctions import UserString\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Normalize the input: remove whitespace and convert to base64 string\n    # Base64 decoding requires a string without whitespace and newlines\n    # We accept UserString or str - convert to str for processing\n    cleaned = ''.join(text.split())  # Remove all whitespace characters\n\n    # Decode the base64 string, which may raise binascii.Error if invalid,\n    # but no error argument handling is needed per the doc\n    decoded_bytes = base64.b64decode(cleaned, validate=True)\n\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()"]}
{"task_id": 130, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert data bytes into base64 encoded bytes\n    b64_bytes = base64.encodebytes(data)\n\n    # The resulting base64 string is bytes with newlines at eol every 76 chars.\n    # In the encode function, the output does not strip newlines. We will keep the default.\n\n    # Decode base64 bytes into a UTF-8 string\n    b64_str = b64_bytes.decode('utf-8')\n\n    return b64_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the given bytes into base64 bytes\n    b64_bytes = base64.encodebytes(data)\n    # base64.encodebytes adds newline characters every 76 chars and ends with newline.\n    # The encode() in encode function uses decodebytes which accepts multiple lines and strips line ends.\n    # Here, decode returns base64 characters including potential newlines.\n\n    # Convert base64 bytes to string (utf-8)\n    b64_str = b64_bytes.decode('utf-8')\n\n    # Clean up trailing newline(s) to keep consistent with encode function's input style\n    b64_str = b64_str.strip()\n\n    return b64_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64 to encode the bytes into base64 ASCII bytes\n    encoded_bytes = base64.encodebytes(data)\n    # base64.encodebytes adds newlines every 76 characters, remove trailing newlines then strip any whitespace (like trailing newlines)\n    encoded_str = encoded_bytes.decode('ascii').strip()\n    return encoded_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the bytes into base64 bytes\n    base64_bytes = base64.encodebytes(data)\n    # Convert base64 bytes into UTF-8 string\n    base64_str = base64_bytes.decode('utf-8')\n    # Return the base64 string and the length of the input bytes\n    return base64_str, len(data)", "import base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode input bytes into base64 bytes without newlines\n    b64_bytes = base64.b64encode(data)\n    # Decode base64 bytes to string\n    b64_str = b64_bytes.decode('ascii')\n    # Return the base64 string and length of the consumed bytes\n    return b64_str, len(data)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert data bytes into base64 encoded bytes\n    b64_bytes = base64.encodebytes(data)\n\n    # The resulting base64 string is bytes with newlines at eol every 76 chars.\n    # In the encode function, the output does not strip newlines. We will keep the default.\n\n    # Decode base64 bytes into a UTF-8 string\n    b64_str = b64_bytes.decode('utf-8')\n\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the given bytes into base64 bytes\n    b64_bytes = base64.encodebytes(data)\n    # base64.encodebytes adds newline characters every 76 chars and ends with newline.\n    # The encode() in encode function uses decodebytes which accepts multiple lines and strips line ends.\n    # Here, decode returns base64 characters including potential newlines.\n\n    # Convert base64 bytes to string (utf-8)\n    b64_str = b64_bytes.decode('utf-8')\n\n    # Clean up trailing newline(s) to keep consistent with encode function's input style\n    b64_str = b64_str.strip()\n\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64 to encode the bytes into base64 ASCII bytes\n    encoded_bytes = base64.encodebytes(data)\n    # base64.encodebytes adds newlines every 76 characters, remove trailing newlines then strip any whitespace (like trailing newlines)\n    encoded_str = encoded_bytes.decode('ascii').strip()\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the bytes into base64 bytes\n    base64_bytes = base64.encodebytes(data)\n    # Convert base64 bytes into UTF-8 string\n    base64_str = base64_bytes.decode('utf-8')\n    # Return the base64 string and the length of the input bytes\n    return base64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple, Union, ByteString as _ByteString\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode input bytes into base64 bytes without newlines\n    b64_bytes = base64.b64encode(data)\n    # Decode base64 bytes to string\n    b64_str = b64_bytes.decode('ascii')\n    # Return the base64 string and length of the consumed bytes\n    return b64_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n"]}
{"task_id": 131, "project": "test-apps/flutils", "module": "flutils.txtutils", "predictions": ["import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove all ANSI sequences and return length of remaining string\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume iterable of strings; sum length of each with ANSI removed\n        total = 0\n        for s in seq:\n            if not isinstance(s, str):\n                raise TypeError(f\"Expected str items in sequence, got {type(s)}\")\n            cleaned = _ANSI_RE.sub('', s)\n            total += len(cleaned)\n        return total", "import re\nfrom typing import Sequence, Union\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove ansi sequences and return length of the clean string\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume seq is a list/tuple of strings\n        # Sum lengths of each string after removing ansi sequences\n        total_length = 0\n        for s in seq:\n            if not isinstance(s, str):\n                raise TypeError(f\"Expected string element, got {type(s)}\")\n            total_length += len(_ANSI_RE.sub('', s))\n        return total_length", "from typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n\n    if isinstance(seq, str):\n        # Remove ANSI sequences from the string and return length of the rest.\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume seq is sequence of strings, sum their cleaned lengths.\n        total_length = 0\n        for part in seq:\n            if isinstance(part, str):\n                cleaned = _ANSI_RE.sub('', part)\n                total_length += len(cleaned)\n            else:\n                # Defensive: if any element is not string, convert to string first.\n                cleaned = _ANSI_RE.sub('', str(part))\n                total_length += len(cleaned)\n        return total_length", "import re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove all ANSI sequences, then return length\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume seq is iterable of strings\n        total_length = 0\n        for part in seq:\n            # Defensive: convert to string just in case\n            part_str = str(part)\n            cleaned = _ANSI_RE.sub('', part_str)\n            total_length += len(cleaned)\n        return total_length", "import re\nfrom typing import Sequence, cast\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    # Convert to a single concatenated string if seq is a list or tuple of strings\n    if isinstance(seq, (list, tuple)):\n        combined = ''.join(cast(Sequence[str], seq))\n    else:\n        combined = cast(str, seq)\n\n    # Remove all ANSI escape sequences\n    cleaned = _ANSI_RE.sub('', combined)\n    # Return the length of the cleaned string\n    return len(cleaned)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove all ANSI sequences and return length of remaining string\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume iterable of strings; sum length of each with ANSI removed\n        total = 0\n        for s in seq:\n            if not isinstance(s, str):\n                raise TypeError(f\"Expected str items in sequence, got {type(s)}\")\n            cleaned = _ANSI_RE.sub('', s)\n            total += len(cleaned)\n        return total\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence, Union\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove ansi sequences and return length of the clean string\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume seq is a list/tuple of strings\n        # Sum lengths of each string after removing ansi sequences\n        total_length = 0\n        for s in seq:\n            if not isinstance(s, str):\n                raise TypeError(f\"Expected string element, got {type(s)}\")\n            total_length += len(_ANSI_RE.sub('', s))\n        return total_length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n\n    if isinstance(seq, str):\n        # Remove ANSI sequences from the string and return length of the rest.\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume seq is sequence of strings, sum their cleaned lengths.\n        total_length = 0\n        for part in seq:\n            if isinstance(part, str):\n                cleaned = _ANSI_RE.sub('', part)\n                total_length += len(cleaned)\n            else:\n                # Defensive: if any element is not string, convert to string first.\n                cleaned = _ANSI_RE.sub('', str(part))\n                total_length += len(cleaned)\n        return total_length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # Remove all ANSI sequences, then return length\n        cleaned = _ANSI_RE.sub('', seq)\n        return len(cleaned)\n    else:\n        # Assume seq is iterable of strings\n        total_length = 0\n        for part in seq:\n            # Defensive: convert to string just in case\n            part_str = str(part)\n            cleaned = _ANSI_RE.sub('', part_str)\n            total_length += len(cleaned)\n        return total_length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence, cast\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    # Convert to a single concatenated string if seq is a list or tuple of strings\n    if isinstance(seq, (list, tuple)):\n        combined = ''.join(cast(Sequence[str], seq))\n    else:\n        combined = cast(str, seq)\n\n    # Remove all ANSI escape sequences\n    cleaned = _ANSI_RE.sub('', combined)\n    # Return the length of the cleaned string\n    return len(cleaned)\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n"]}
{"task_id": 132, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        cp = ord(ch)\n        if cp <= 0xFF:\n            # Use \\xHH for characters in range 0-255\n            result.append(f\"\\\\x{cp:02x}\")\n        elif cp <= 0xFFFF:\n            # Use \\uHHHH for BMP characters (up to 0xFFFF)\n            result.append(f\"\\\\u{cp:04x}\")\n        else:\n            # Use \\UHHHHHHHH for characters beyond BMP (up to 0x10FFFF)\n            result.append(f\"\\\\U{cp:08x}\")\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for char in text:\n        codepoint = ord(char)\n        if codepoint <= 0xFF:\n            # \\xhh notation, two hex digits\n            result.append(f\"\\\\x{codepoint:02x}\")\n        elif codepoint <= 0xFFFF:\n            # \\uhhhh notation, four hex digits\n            result.append(f\"\\\\u{codepoint:04x}\")\n        else:\n            # \\Uhhhhhhhh notation, eight hex digits\n            result.append(f\"\\\\U{codepoint:08x}\")\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0xFF:\n            # Use \\xhh format for BMP characters <= 0xFF\n            result.append(f\"\\\\x{codepoint:02x}\")\n        elif codepoint <= 0xFFFF:\n            # Use \\uhhhh format for BMP characters > 0xFF\n            result.append(f\"\\\\u{codepoint:04x}\")\n        else:\n            # Use \\Uhhhhhhhh format for codepoints > 0xFFFF (supplementary planes)\n            result.append(f\"\\\\U{codepoint:08x}\")\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        ord_ch = ord(ch)\n        if ord_ch <= 0xFF:\n            # Use \\xHH format for BMP characters <= 0xFF\n            result.append(f'\\\\x{ord_ch:02x}')\n        elif ord_ch <= 0xFFFF:\n            # Use \\uHHHH format for BMP characters > 0xFF\n            result.append(f'\\\\u{ord_ch:04x}')\n        else:\n            # Use \\U00HHHHHH format for characters above BMP\n            result.append(f'\\\\U{ord_ch:08x}')\n    return ''.join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0x7F:\n            # ASCII range => \\xHH\n            result.append(\"\\\\\\\\x{:02x}\".format(codepoint))\n        elif codepoint <= 0xFFFF:\n            # BMP => \\uHHHH\n            result.append(\"\\\\\\\\u{:04x}\".format(codepoint))\n        else:\n            # Above BMP => \\U00HHHHHH (8 digits)\n            result.append(\"\\\\\\\\U{:08x}\".format(codepoint))\n    return \"\".join(result)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        cp = ord(ch)\n        if cp <= 0xFF:\n            # Use \\xHH for characters in range 0-255\n            result.append(f\"\\\\x{cp:02x}\")\n        elif cp <= 0xFFFF:\n            # Use \\uHHHH for BMP characters (up to 0xFFFF)\n            result.append(f\"\\\\u{cp:04x}\")\n        else:\n            # Use \\UHHHHHHHH for characters beyond BMP (up to 0x10FFFF)\n            result.append(f\"\\\\U{cp:08x}\")\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for char in text:\n        codepoint = ord(char)\n        if codepoint <= 0xFF:\n            # \\xhh notation, two hex digits\n            result.append(f\"\\\\x{codepoint:02x}\")\n        elif codepoint <= 0xFFFF:\n            # \\uhhhh notation, four hex digits\n            result.append(f\"\\\\u{codepoint:04x}\")\n        else:\n            # \\Uhhhhhhhh notation, eight hex digits\n            result.append(f\"\\\\U{codepoint:08x}\")\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0xFF:\n            # Use \\xhh format for BMP characters <= 0xFF\n            result.append(f\"\\\\x{codepoint:02x}\")\n        elif codepoint <= 0xFFFF:\n            # Use \\uhhhh format for BMP characters > 0xFF\n            result.append(f\"\\\\u{codepoint:04x}\")\n        else:\n            # Use \\Uhhhhhhhh format for codepoints > 0xFFFF (supplementary planes)\n            result.append(f\"\\\\U{codepoint:08x}\")\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        ord_ch = ord(ch)\n        if ord_ch <= 0xFF:\n            # Use \\xHH format for BMP characters <= 0xFF\n            result.append(f'\\\\x{ord_ch:02x}')\n        elif ord_ch <= 0xFFFF:\n            # Use \\uHHHH format for BMP characters > 0xFF\n            result.append(f'\\\\u{ord_ch:04x}')\n        else:\n            # Use \\U00HHHHHH format for characters above BMP\n            result.append(f'\\\\U{ord_ch:08x}')\n    return ''.join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result = []\n    for ch in text:\n        codepoint = ord(ch)\n        if codepoint <= 0x7F:\n            # ASCII range => \\xHH\n            result.append(\"\\\\\\\\x{:02x}\".format(codepoint))\n        elif codepoint <= 0xFFFF:\n            # BMP => \\uHHHH\n            result.append(\"\\\\\\\\u{:04x}\".format(codepoint))\n        else:\n            # Above BMP => \\U00HHHHHH (8 digits)\n            result.append(\"\\\\\\\\U{:08x}\".format(codepoint))\n    return \"\".join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n"]}
{"task_id": 133, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    out = ''\n    for b in text.encode('utf-8'):\n        out += '\\\\x{:02x}'.format(b)\n    return out", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    out = ''\n    for b in text.encode('utf-8'):\n        out += '\\\\x{:02x}'.format(b)\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    utf8_bytes = text.encode('utf-8')\n    for b in utf8_bytes:\n        out += '\\\\x{:02x}'.format(b)\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n"]}
{"task_id": 134, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the pre-compiled regex _CAMEL_TO_UNDERSCORE_RE to find camel case boundaries,\n    # and insert underscore before uppercase letters where needed.\n    # Then lower-case the entire string.\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regex _CAMEL_TO_UNDERSCORE_RE to find boundaries between lowercase/number and uppercase letters\n    # or uppercase letters followed by lowercase letters not at string start,\n    # then replace them with underscores preceding the matched upper case character.\n    underscored = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Return the lowercase version of the modified string.\n    return underscored.lower()", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regex to find positions where an uppercase letter\n    # should be preceded by an underscore (except at the start)\n    underscored = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Return the string lowercased\n    return underscored.lower()", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the pre-compiled regex _CAMEL_TO_UNDERSCORE_RE to find the positions\n    # where uppercase letters that separate words appear, and insert underscores.\n    result = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Convert whole resulting string to lowercase.\n    return result.lower()", "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regular expression to find boundaries in camel-cased words\n    # Insert underscores before uppercase letters that follow lowercase letters or digits,\n    # or uppercase letters followed by lowercase letters (to split acronyms and words)\n    out = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    return out.lower()"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the pre-compiled regex _CAMEL_TO_UNDERSCORE_RE to find camel case boundaries,\n    # and insert underscore before uppercase letters where needed.\n    # Then lower-case the entire string.\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regex _CAMEL_TO_UNDERSCORE_RE to find boundaries between lowercase/number and uppercase letters\n    # or uppercase letters followed by lowercase letters not at string start,\n    # then replace them with underscores preceding the matched upper case character.\n    underscored = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Return the lowercase version of the modified string.\n    return underscored.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regex to find positions where an uppercase letter\n    # should be preceded by an underscore (except at the start)\n    underscored = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Return the string lowercased\n    return underscored.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the pre-compiled regex _CAMEL_TO_UNDERSCORE_RE to find the positions\n    # where uppercase letters that separate words appear, and insert underscores.\n    result = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Convert whole resulting string to lowercase.\n    return result.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use the precompiled regular expression to find boundaries in camel-cased words\n    # Insert underscores before uppercase letters that follow lowercase letters or digits,\n    # or uppercase letters followed by lowercase letters (to split acronyms and words)\n    out = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    return out.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n"]}
{"task_id": 135, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Pattern to match \\x.., \\u...., \\U........\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_escape(match):\n        s = match.group(0)\n        # Remove the leading backslash and get hex number\n        hex_part = s[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n\n    return pattern.sub(replace_escape, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # This regex matches any of these patterns: \\xHH, \\uHHHH, \\UHHHHHHHH (H = hex digit)\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def _replace(match):\n        esc_seq = match.group(0)\n        # Remove the leading backslash and prefix (\\x, \\u, or \\U)\n        prefix = esc_seq[1]\n        hex_part = esc_seq[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n\n    return pattern.sub(_replace, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Pattern to match \\xHH, \\uHHHH, \\UHHHHHHHH escape sequences\n    pattern = re.compile(r'''\n        (\\\\x([0-9a-fA-F]{2}))        |   # \\xHH\n        (\\\\u([0-9a-fA-F]{4}))        |   # \\uHHHH\n        (\\\\U([0-9a-fA-F]{8}))            # \\UHHHHHHHH\n        ''', re.VERBOSE)\n\n    def replace_match(m):\n        if m.group(1):  # \\xHH\n            hex_str = m.group(2)\n            codepoint = int(hex_str, 16)\n            return chr(codepoint)\n        elif m.group(3):  # \\uHHHH\n            hex_str = m.group(4)\n            codepoint = int(hex_str, 16)\n            return chr(codepoint)\n        elif m.group(5):  # \\UHHHHHHHH\n            hex_str = m.group(6)\n            codepoint = int(hex_str, 16)\n            return chr(codepoint)\n        # Should not reach here\n        return m.group(0)\n\n    # Replace all occurrences of escaped unicode literals\n    return pattern.sub(replace_match, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n    \"\"\"\n    # Regex matching any of the three patterns \\xHH, \\uHHHH, \\UHHHHHHHH\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n    \n    def decode_match(m: re.Match) -> str:\n        s = m.group(0)\n        # Remove leading backslash and identifier char\n        hex_part = s[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n    \n    return pattern.sub(decode_match, text)", "import re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Regex pattern to match \\x.., \\u...., or \\U........ escapes\n    # Matches case sensitive \\x, \\u, \\U followed by hex digits of length 2,4,8 respectively\n    pattern = re.compile(r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})')\n\n    def replace_match(m: re.Match) -> str:\n        escape_seq = m.group(0)\n        # Determine type of escape sequence:\n        if escape_seq.startswith('\\\\x'):\n            hex_str = escape_seq[2:]\n            codepoint = int(hex_str, 16)\n        elif escape_seq.startswith('\\\\u'):\n            hex_str = escape_seq[2:]\n            codepoint = int(hex_str, 16)\n        else:  # \\U\n            hex_str = escape_seq[2:]\n            codepoint = int(hex_str, 16)\n        return chr(codepoint)\n\n    return pattern.sub(replace_match, text)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Pattern to match \\x.., \\u...., \\U........\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def replace_escape(match):\n        s = match.group(0)\n        # Remove the leading backslash and get hex number\n        hex_part = s[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n\n    return pattern.sub(replace_escape, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # This regex matches any of these patterns: \\xHH, \\uHHHH, \\UHHHHHHHH (H = hex digit)\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n\n    def _replace(match):\n        esc_seq = match.group(0)\n        # Remove the leading backslash and prefix (\\x, \\u, or \\U)\n        prefix = esc_seq[1]\n        hex_part = esc_seq[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n\n    return pattern.sub(_replace, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Pattern to match \\xHH, \\uHHHH, \\UHHHHHHHH escape sequences\n    pattern = re.compile(r'''\n        (\\\\x([0-9a-fA-F]{2}))        |   # \\xHH\n        (\\\\u([0-9a-fA-F]{4}))        |   # \\uHHHH\n        (\\\\U([0-9a-fA-F]{8}))            # \\UHHHHHHHH\n        ''', re.VERBOSE)\n\n    def replace_match(m):\n        if m.group(1):  # \\xHH\n            hex_str = m.group(2)\n            codepoint = int(hex_str, 16)\n            return chr(codepoint)\n        elif m.group(3):  # \\uHHHH\n            hex_str = m.group(4)\n            codepoint = int(hex_str, 16)\n            return chr(codepoint)\n        elif m.group(5):  # \\UHHHHHHHH\n            hex_str = m.group(6)\n            codepoint = int(hex_str, 16)\n            return chr(codepoint)\n        # Should not reach here\n        return m.group(0)\n\n    # Replace all occurrences of escaped unicode literals\n    return pattern.sub(replace_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n    \"\"\"\n    # Regex matching any of the three patterns \\xHH, \\uHHHH, \\UHHHHHHHH\n    pattern = re.compile(\n        r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})'\n    )\n    \n    def decode_match(m: re.Match) -> str:\n        s = m.group(0)\n        # Remove leading backslash and identifier char\n        hex_part = s[2:]\n        codepoint = int(hex_part, 16)\n        return chr(codepoint)\n    \n    return pattern.sub(decode_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Regex pattern to match \\x.., \\u...., or \\U........ escapes\n    # Matches case sensitive \\x, \\u, \\U followed by hex digits of length 2,4,8 respectively\n    pattern = re.compile(r'(\\\\x[0-9a-fA-F]{2}|\\\\u[0-9a-fA-F]{4}|\\\\U[0-9a-fA-F]{8})')\n\n    def replace_match(m: re.Match) -> str:\n        escape_seq = m.group(0)\n        # Determine type of escape sequence:\n        if escape_seq.startswith('\\\\x'):\n            hex_str = escape_seq[2:]\n            codepoint = int(hex_str, 16)\n        elif escape_seq.startswith('\\\\u'):\n            hex_str = escape_seq[2:]\n            codepoint = int(hex_str, 16)\n        else:  # \\U\n            hex_str = escape_seq[2:]\n            codepoint = int(hex_str, 16)\n        return chr(codepoint)\n\n    return pattern.sub(replace_match, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n"]}
{"task_id": 136, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Convert the escaped UTF-8 hex bytes to the actual bytes, then decode as utf8\n    # The input string contains sequences like '\\\\xc2\\\\xa9' (literal backslashes),\n    # which represent encoded utf8 bytes.\n    # We encode to bytes (latin1 to keep bytes unchanged), then decode using unicode_escape\n    # to get the bytes represented by the escaped sequences,\n    # then decode those bytes as utf-8.\n    bytes_decoded = text.encode('latin1').decode('unicode_escape').encode('latin1')\n    return bytes_decoded.decode('utf-8')", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The 'raw_utf8_escape' codec is registered by the register_codecs() function as per context.\n    # We can decode the escaped UTF-8 bytes by using this codec.\n    # But since there is no direct info that register_codecs() is called here or will be called elsewhere,\n    # normally we'd call register_codecs here or trust the user to call it.\n    # The problem states not to import from file content, but the context function suggests this codec.\n    # Since we can't import or call register_codecs here, we use a Python standard approach:\n    #\n    # Use standard 'unicode_escape' followed by UTF-8 decoding:\n    # 1. Decode the string using 'unicode_escape' to convert \\x escapes into bytes in a string.\n    # 2. Encode that intermediate string back to bytes using latin1 to preserve bytes as-is.\n    # 3. Decode bytes using UTF-8 to get the final string.\n\n    # Step 1: decode unicode_escape to convert \\xNN sequences into actual chars\n    intermediate = text.encode('utf-8').decode('unicode_escape')\n\n    # Step 2: encode intermediate string with latin1 to get original byte values (no change)\n    byte_seq = intermediate.encode('latin1')\n\n    # Step 3: decode bytes using utf-8 to get proper unicode string\n    return byte_seq.decode('utf-8')", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n        A string with each escaped UTF8 hexadecimal character converted\n        into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n        >>> from flutils.strutils import convert_raw_utf8_escape\n        >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n        >>> convert_escaped_utf8_literal(a)\n        'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n        $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n        $ python\n\n        ::\n\n        >>> import os\n        >>> from flutils.strutils import convert_raw_utf8_escape\n        >>> a = os.getenv('TEST')\n        >>> a\n        'test\\\\\\\\xc2\\\\\\\\xa9'\n        >>> convert_escaped_utf8_literal(a)\n        'test©'\n    \"\"\"\n    # The escaped UTF-8 literals have the form '\\x..' within the string,\n    # and we want to decode them into the proper UTF-8 characters.\n    # Python 'unicode_escape' decodes \\x escapes but produces unicode codepoints,\n    # here we want to decode bytes escaped with \\x into bytes and then decode\n    # that bytes sequence with UTF-8.\n    #\n    # So first, decode 'unicode_escape' to get bytes string with real bytes,\n    # then decode that bytes string as UTF-8.\n\n    # Step 1: decode backslash escapes to raw bytes\n    bytes_raw = text.encode('utf-8').decode('unicode_escape').encode('latin1')\n\n    # Step 2: decode bytes with utf-8 to proper unicode string\n    return bytes_raw.decode('utf-8')", "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # We can use the same approach as convert_escaped_unicode_literal but decoding\n    # with 'unicode_escape' only converts unicode escapes, not raw utf8 bytes.\n    #\n    # From context, there is a special codec 'raw_utf8_escape' which can decode text\n    # like 'test\\\\xc2\\\\xa9' into 'test©'.\n    #\n    # We must assume the user has registered codecs (or we register them now).\n    # Since register_codecs is in context (not from this file), just call register_codecs first.\n    #\n    # Then decode the input text using 'raw_utf8_escape' codec.\n    #\n    # This will raise UnicodeDecodeError if the bytes are invalid UTF8 sequences.\n\n    from flutils.codecs import register_codecs\n\n    register_codecs()\n    # decode from string with escaped hex bytes to bytes, then decode bytes to str via raw_utf8_escape\n    # Actually, the 'raw_utf8_escape' codec provided in context supports decoding str with escaped UTF8 bytes directly.\n\n    return text.encode('latin1').decode('raw_utf8_escape')", "from flutils.codecs import register_codecs\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    register_codecs()\n    # Decode the string using the 'raw_utf8_escape' codec, which will interpret\n    # escaped UTF-8 hex sequences like '\\\\xc2\\\\xa9' into their proper UTF-8 bytes\n    # and then decode them into the proper string characters.\n    return text.encode('latin1').decode('raw_utf8_escape')"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # Convert the escaped UTF-8 hex bytes to the actual bytes, then decode as utf8\n    # The input string contains sequences like '\\\\xc2\\\\xa9' (literal backslashes),\n    # which represent encoded utf8 bytes.\n    # We encode to bytes (latin1 to keep bytes unchanged), then decode using unicode_escape\n    # to get the bytes represented by the escaped sequences,\n    # then decode those bytes as utf-8.\n    bytes_decoded = text.encode('latin1').decode('unicode_escape').encode('latin1')\n    return bytes_decoded.decode('utf-8')\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The 'raw_utf8_escape' codec is registered by the register_codecs() function as per context.\n    # We can decode the escaped UTF-8 bytes by using this codec.\n    # But since there is no direct info that register_codecs() is called here or will be called elsewhere,\n    # normally we'd call register_codecs here or trust the user to call it.\n    # The problem states not to import from file content, but the context function suggests this codec.\n    # Since we can't import or call register_codecs here, we use a Python standard approach:\n    #\n    # Use standard 'unicode_escape' followed by UTF-8 decoding:\n    # 1. Decode the string using 'unicode_escape' to convert \\x escapes into bytes in a string.\n    # 2. Encode that intermediate string back to bytes using latin1 to preserve bytes as-is.\n    # 3. Decode bytes using UTF-8 to get the final string.\n\n    # Step 1: decode unicode_escape to convert \\xNN sequences into actual chars\n    intermediate = text.encode('utf-8').decode('unicode_escape')\n\n    # Step 2: encode intermediate string with latin1 to get original byte values (no change)\n    byte_seq = intermediate.encode('latin1')\n\n    # Step 3: decode bytes using utf-8 to get proper unicode string\n    return byte_seq.decode('utf-8')\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n        UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n        A string with each escaped UTF8 hexadecimal character converted\n        into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n        >>> from flutils.strutils import convert_raw_utf8_escape\n        >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n        >>> convert_escaped_utf8_literal(a)\n        'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n        $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n        $ python\n\n        ::\n\n        >>> import os\n        >>> from flutils.strutils import convert_raw_utf8_escape\n        >>> a = os.getenv('TEST')\n        >>> a\n        'test\\\\\\\\xc2\\\\\\\\xa9'\n        >>> convert_escaped_utf8_literal(a)\n        'test©'\n    \"\"\"\n    # The escaped UTF-8 literals have the form '\\x..' within the string,\n    # and we want to decode them into the proper UTF-8 characters.\n    # Python 'unicode_escape' decodes \\x escapes but produces unicode codepoints,\n    # here we want to decode bytes escaped with \\x into bytes and then decode\n    # that bytes sequence with UTF-8.\n    #\n    # So first, decode 'unicode_escape' to get bytes string with real bytes,\n    # then decode that bytes string as UTF-8.\n\n    # Step 1: decode backslash escapes to raw bytes\n    bytes_raw = text.encode('utf-8').decode('unicode_escape').encode('latin1')\n\n    # Step 2: decode bytes with utf-8 to proper unicode string\n    return bytes_raw.decode('utf-8')\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # We can use the same approach as convert_escaped_unicode_literal but decoding\n    # with 'unicode_escape' only converts unicode escapes, not raw utf8 bytes.\n    #\n    # From context, there is a special codec 'raw_utf8_escape' which can decode text\n    # like 'test\\\\xc2\\\\xa9' into 'test©'.\n    #\n    # We must assume the user has registered codecs (or we register them now).\n    # Since register_codecs is in context (not from this file), just call register_codecs first.\n    #\n    # Then decode the input text using 'raw_utf8_escape' codec.\n    #\n    # This will raise UnicodeDecodeError if the bytes are invalid UTF8 sequences.\n\n    from flutils.codecs import register_codecs\n\n    register_codecs()\n    # decode from string with escaped hex bytes to bytes, then decode bytes to str via raw_utf8_escape\n    # Actually, the 'raw_utf8_escape' codec provided in context supports decoding str with escaped UTF8 bytes directly.\n\n    return text.encode('latin1').decode('raw_utf8_escape')\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs import register_codecs\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    register_codecs()\n    # Decode the string using the 'raw_utf8_escape' codec, which will interpret\n    # escaped UTF-8 hex sequences like '\\\\xc2\\\\xa9' into their proper UTF-8 bytes\n    # and then decode them into the proper string characters.\n    return text.encode('latin1').decode('raw_utf8_escape')\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n"]}
{"task_id": 137, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, ignore empty parts (which represent extra underscores)\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        # If no parts found (e.g. empty or only underscores), return empty string\n        return ''\n\n    # Capitalize the first letter of each part\n    capitalized_parts = [p.capitalize() for p in parts]\n\n    if lower_first:\n        # Lowercase the first character of the first part\n        capitalized_parts[0] = capitalized_parts[0][0].lower() + capitalized_parts[0][1:] if capitalized_parts[0] else ''\n\n    # Join all parts without any separator to form camelCase or PascalCase\n    return ''.join(capitalized_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores and filter out empty strings\n    parts = [p for p in text.split('_') if p]\n    if not parts:\n        return ''  # Return empty string if no valid parts\n\n    # Capitalize each part except possibly the first\n    camel_parts = [part.capitalize() for part in parts]\n\n    if lower_first:\n        # Make the first part lowercase (first character)\n        camel_parts[0] = camel_parts[0][0].lower() + camel_parts[0][1:] if camel_parts[0] else ''\n    # Join all parts\n    return ''.join(camel_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, filtering out empty strings (from multiple underscores)\n    parts = [part for part in text.split('_') if part]\n\n    if not parts:\n        # If there are no parts, return an empty string\n        return ''\n\n    # Capitalize the first character of each word except possibly the first one\n    camel_parts = [parts[0].capitalize() if not lower_first else parts[0].lower()]\n    camel_parts.extend(part.capitalize() for part in parts[1:])\n\n    # Join and return the camel-cased string\n    return ''.join(camel_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split by underscore and filter out empty parts\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize all parts\n    parts = [p.capitalize() for p in parts]\n\n    # Lowercase the first character of the first part if required\n    if lower_first:\n        first_part = parts[0]\n        parts[0] = first_part[0].lower() + first_part[1:] if first_part else ''\n\n    return ''.join(parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the input on underscores and filter out empty strings\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize all parts\n    parts = [p.capitalize() for p in parts]\n\n    if lower_first:\n        # Lowercase first character of the first part\n        first_part = parts[0]\n        parts[0] = first_part[0].lower() + first_part[1:] if first_part else ''\n\n    return ''.join(parts)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, ignore empty parts (which represent extra underscores)\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        # If no parts found (e.g. empty or only underscores), return empty string\n        return ''\n\n    # Capitalize the first letter of each part\n    capitalized_parts = [p.capitalize() for p in parts]\n\n    if lower_first:\n        # Lowercase the first character of the first part\n        capitalized_parts[0] = capitalized_parts[0][0].lower() + capitalized_parts[0][1:] if capitalized_parts[0] else ''\n\n    # Join all parts without any separator to form camelCase or PascalCase\n    return ''.join(capitalized_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores and filter out empty strings\n    parts = [p for p in text.split('_') if p]\n    if not parts:\n        return ''  # Return empty string if no valid parts\n\n    # Capitalize each part except possibly the first\n    camel_parts = [part.capitalize() for part in parts]\n\n    if lower_first:\n        # Make the first part lowercase (first character)\n        camel_parts[0] = camel_parts[0][0].lower() + camel_parts[0][1:] if camel_parts[0] else ''\n    # Join all parts\n    return ''.join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscores, filtering out empty strings (from multiple underscores)\n    parts = [part for part in text.split('_') if part]\n\n    if not parts:\n        # If there are no parts, return an empty string\n        return ''\n\n    # Capitalize the first character of each word except possibly the first one\n    camel_parts = [parts[0].capitalize() if not lower_first else parts[0].lower()]\n    camel_parts.extend(part.capitalize() for part in parts[1:])\n\n    # Join and return the camel-cased string\n    return ''.join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split by underscore and filter out empty parts\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize all parts\n    parts = [p.capitalize() for p in parts]\n\n    # Lowercase the first character of the first part if required\n    if lower_first:\n        first_part = parts[0]\n        parts[0] = first_part[0].lower() + first_part[1:] if first_part else ''\n\n    return ''.join(parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the input on underscores and filter out empty strings\n    parts = [p for p in text.split('_') if p]\n\n    if not parts:\n        return ''\n\n    # Capitalize all parts\n    parts = [p.capitalize() for p in parts]\n\n    if lower_first:\n        # Lowercase first character of the first part\n        first_part = parts[0]\n        parts[0] = first_part[0].lower() + first_part[1:] if first_part else ''\n\n    return ''.join(parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n"]}
{"task_id": 138, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["import grp\nimport getpass\nfrom typing import Union, Optional\n\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default to current user's primary group\n        user_name = getpass.getuser()\n        try:\n            user_info = pwd.getpwnam(user_name)\n        except KeyError:\n            raise OSError(\n                f'The current user {user_name!r} does not exist on this system.'\n            )\n        gid = user_info.pw_gid\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f'The group id {gid!r} of current user does not exist on this system.'\n            )\n\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f'The given gid: {name!r} is not a valid gid for this operating system.'\n            )\n\n    # Otherwise name is str - group name\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            f'The given name: {name!r} is not a valid \"group name\" for this operating system.'\n        )", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default: get current user's primary group\n        try:\n            # Get current user's group id from their passwd entry\n            import pwd\n            user_name = getpass.getuser()\n            pw_entry = pwd.getpwnam(user_name)\n            gid = pw_entry.pw_gid\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f\"The current user's group id does not exist on this system.\"\n            )\n    elif isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given gid: {name!r} is not a valid gid for this operating system.\"\n            )\n    else:\n        # str name\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid group name for this operating system.\"\n            )", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default to current user's group\n        current_gid = getpass.getuser()\n        # Try to get current user's group via pwd then grp\n        # Importing pwd here but keep minimal\n        import pwd\n        try:\n            pw = pwd.getpwnam(current_gid)\n            gid = pw.pw_gid\n        except KeyError:\n            # Fallback: get current user's numeric uid\n            uid = os.getuid() if hasattr(os, 'getuid') else None\n            if uid is not None:\n                try:\n                    pw = pwd.getpwuid(uid)\n                    gid = pw.pw_gid\n                except KeyError:\n                    raise OSError(\n                        'Could not determine the current user gid.'\n                    )\n            else:\n                raise OSError(\n                    'Could not determine the current user gid.'\n                )\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f'The gid: {gid} does not exist as a group on this system.'\n            )\n\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f'The given gid: {name}, is not a valid gid for this operating system.'\n            )\n    if isinstance(name, str):\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name}, is not a valid \"group name\" for this operating system.'\n            )\n    raise TypeError(\n        f'The given name: {name} must be of type str, int, or None.'\n    )", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default to the current user's primary group\n        user_name = getpass.getuser()\n        try:\n            import pwd\n            pw_entry = pwd.getpwnam(user_name)\n        except KeyError:\n            raise OSError(\n                f\"The current user '{user_name}' does not exist on this system.\"\n            )\n        gid = pw_entry.pw_gid\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f\"The current user's primary gid '{gid}' does not exist on this system.\"\n            )\n\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given gid: {name!r} is not a valid gid for this operating system.\"\n            )\n    else:\n        # name is a str\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r} is not a valid group name for this operating system.\"\n            )", "import grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group\n        current_user = getpass.getuser()\n        try:\n            user_info = pwd.getpwnam(current_user)\n        except KeyError:\n            raise OSError(\n                f'The current user: {current_user!r} does not exist on this operating system.'\n            )\n        gid = user_info.pw_gid\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f'The group id: {gid!r} for the current user does not exist on this operating system.'\n            )\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f'The given gid: {name!r} is not a valid gid for this operating system.'\n            )\n    # name is str\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            f'The given name: {name!r} is not a valid group name for this operating system.'\n        )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default to current user's primary group\n        user_name = getpass.getuser()\n        try:\n            user_info = pwd.getpwnam(user_name)\n        except KeyError:\n            raise OSError(\n                f'The current user {user_name!r} does not exist on this system.'\n            )\n        gid = user_info.pw_gid\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f'The group id {gid!r} of current user does not exist on this system.'\n            )\n\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f'The given gid: {name!r} is not a valid gid for this operating system.'\n            )\n\n    # Otherwise name is str - group name\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            f'The given name: {name!r} is not a valid \"group name\" for this operating system.'\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default: get current user's primary group\n        try:\n            # Get current user's group id from their passwd entry\n            import pwd\n            user_name = getpass.getuser()\n            pw_entry = pwd.getpwnam(user_name)\n            gid = pw_entry.pw_gid\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f\"The current user's group id does not exist on this system.\"\n            )\n    elif isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given gid: {name!r} is not a valid gid for this operating system.\"\n            )\n    else:\n        # str name\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid group name for this operating system.\"\n            )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default to current user's group\n        current_gid = getpass.getuser()\n        # Try to get current user's group via pwd then grp\n        # Importing pwd here but keep minimal\n        import pwd\n        try:\n            pw = pwd.getpwnam(current_gid)\n            gid = pw.pw_gid\n        except KeyError:\n            # Fallback: get current user's numeric uid\n            uid = os.getuid() if hasattr(os, 'getuid') else None\n            if uid is not None:\n                try:\n                    pw = pwd.getpwuid(uid)\n                    gid = pw.pw_gid\n                except KeyError:\n                    raise OSError(\n                        'Could not determine the current user gid.'\n                    )\n            else:\n                raise OSError(\n                    'Could not determine the current user gid.'\n                )\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f'The gid: {gid} does not exist as a group on this system.'\n            )\n\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f'The given gid: {name}, is not a valid gid for this operating system.'\n            )\n    if isinstance(name, str):\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name}, is not a valid \"group name\" for this operating system.'\n            )\n    raise TypeError(\n        f'The given name: {name} must be of type str, int, or None.'\n    )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Default to the current user's primary group\n        user_name = getpass.getuser()\n        try:\n            import pwd\n            pw_entry = pwd.getpwnam(user_name)\n        except KeyError:\n            raise OSError(\n                f\"The current user '{user_name}' does not exist on this system.\"\n            )\n        gid = pw_entry.pw_gid\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f\"The current user's primary gid '{gid}' does not exist on this system.\"\n            )\n\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given gid: {name!r} is not a valid gid for this operating system.\"\n            )\n    else:\n        # name is a str\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r} is not a valid group name for this operating system.\"\n            )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        # Get current user's primary group\n        current_user = getpass.getuser()\n        try:\n            user_info = pwd.getpwnam(current_user)\n        except KeyError:\n            raise OSError(\n                f'The current user: {current_user!r} does not exist on this operating system.'\n            )\n        gid = user_info.pw_gid\n        try:\n            return grp.getgrgid(gid)\n        except KeyError:\n            raise OSError(\n                f'The group id: {gid!r} for the current user does not exist on this operating system.'\n            )\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                f'The given gid: {name!r} is not a valid gid for this operating system.'\n            )\n    # name is str\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            f'The given name: {name!r} is not a valid group name for this operating system.'\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()"]}
{"task_id": 139, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default to current user's login name\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r} is not a valid login name for this operating system.\"\n            )", "import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Use current user's login name if no name provided\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f'The given uid: {name!r}, is not a valid uid for this operating system.'\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name!r}, is not a valid \"login name\" for this operating system.'\n            )", "import getpass\nimport pwd\nfrom typing import Union, Optional, cast\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default: current logged user\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f'The given uid: {name!r} is not a valid uid for this operating system.'\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name!r} is not a valid \"login name\" for this operating system.'\n            )", "import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r}, is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid 'login name' for this operating system.\"\n            )", "import getpass\nimport pwd\nfrom typing import Union, Optional, cast\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r} is not a valid 'login name' for this operating system.\"\n            )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default to current user's login name\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r} is not a valid login name for this operating system.\"\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Use current user's login name if no name provided\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f'The given uid: {name!r}, is not a valid uid for this operating system.'\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name!r}, is not a valid \"login name\" for this operating system.'\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional, cast\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Default: current logged user\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f'The given uid: {name!r} is not a valid uid for this operating system.'\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name!r} is not a valid \"login name\" for this operating system.'\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r}, is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r}, is not a valid 'login name' for this operating system.\"\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional, cast\n\n_STR_OR_INT_OR_NONE = Union[str, int, None]\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f\"The given uid: {name!r} is not a valid uid for this operating system.\"\n            )\n    else:\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f\"The given name: {name!r} is not a valid 'login name' for this operating system.\"\n            )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()"]}
{"task_id": 140, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["import codecs\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # The input text may contain escaped UTF-8 hex sequences like \\xx.\n    # We need to \"decode\" these sequences into bytes, validating that they form valid UTF-8.\n    # After decoding, we return the bytes and the number of characters consumed from the input.\n\n    input_str = str(text)\n    length = len(input_str)\n    bytes_out = bytearray()\n\n    i = 0\n    while i < length:\n        c = input_str[i]\n        if c != '\\\\':  # normal character, add its UTF-8 bytes\n            # encode this character in UTF-8 and append to output\n            try:\n                encoded_bytes = c.encode('utf8', errors)\n            except UnicodeEncodeError as e:\n                # Re-raise with the same semantics\n                raise e\n            bytes_out.extend(encoded_bytes)\n            i += 1\n        else:\n            # Possible escaped hex sequence \\xx\n            # We expect exactly two hex digits after the backslash\n            if i + 2 >= length:\n                # Backslash at the end or incomplete sequence\n                # Handle errors according to 'errors' policy\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+1,\n                        \"trailing \\\\ at end of string\"\n                    )\n                elif errors == 'ignore':\n                    # Skip backslash\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    bytes_out.extend(b'?')\n                    i += 1\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+1,\n                        f\"unknown error handler '{errors}'\"\n                    )\n\n            hex_part = input_str[i+1:i+3]\n            try:\n                byte_val = int(hex_part, 16)\n            except ValueError:\n                # Not valid hex digits after backslash\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+3,\n                        \"invalid escape sequence\"\n                    )\n                elif errors == 'ignore':\n                    i += 3\n                    continue\n                elif errors == 'replace':\n                    bytes_out.extend(b'?')\n                    i += 3\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+3,\n                        f\"unknown error handler '{errors}'\"\n                    )\n\n            # Append this byte to a temporary bytes buffer to later validate UTF-8\n            # But we need to build full byte sequence before validating\n            # So let's collect bytes until next char is non-escaped or end reached,\n            # then validate all bytes in one go.\n\n            # But since the function is to convert the entire string to escaped utf8 bytes,\n            # and the presence of \\xx means byte values, presumably the bytes_out should be raw bytes,\n            # however docstring states \"bytes of escaped utf8 hexadecimal\".\n            #\n            # On close read: \"Convert a str, that may contain escaped utf8 hexadecimal, to bytes of escaped utf8 hexadecimal.\"\n            #\n            # But the output is bytes: the given \"text\" converted into escaped utf8 bytes.\n            # This is ambiguous but likely means the output bytes represent the bytes of the encoded string,\n            # where any escaped hex is converted into byte values.\n            #\n            # So we should decode \\xx sequences into the bytes they represent,\n            # and the other characters into their UTF-8 encoded bytes.\n            #\n            # Here we append byte_val as a byte.\n            bytes_out.append(byte_val)\n            i += 3\n\n    # Now validate that the entire bytes_out is valid UTF-8\n    try:\n        bytes_out.decode('utf8')\n    except UnicodeDecodeError as e:\n        # The given text contains escaped utf8 hexadecimal that references invalid utf8 bytes\n        # Raise UnicodeEncodeError as required by spec\n        raise UnicodeEncodeError(\n            \"utf8\",\n            bytes_out,\n            e.start,\n            e.end,\n            \"invalid UTF-8 byte sequence\"\n        ) from None\n\n    # Return bytes_out and number of characters consumed from input_str (all)\n    return bytes(bytes_out), length", "from typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Since the function's docstring says the input text may contain escaped\n    # utf8 hexadecimal, and that it must be converted into escaped utf8 bytes,\n    # we must interpret existing escapes and verify they form valid utf8 bytes.\n    #\n    # The function should:\n    # - Parse the input text to handle escaped hex bytes like '\\xx'\n    # - Validate that the resulting bytes decode as valid UTF-8 (to ensure valid sequences)\n    # - Return those bytes as a bytes object\n    # - Return the number of characters consumed (whole length of text)\n    #\n    # Implementation plan:\n    # 1. Scan the text left to right.\n    # 2. When backslash encountered, try to parse an escaped hex byte (e.g. \\xhh or \\hh)\n    #    but docstring says \"escaped utf8 hexadecimal\" - it seems the style is '\\xx',\n    #    where xx is hex without the 'x'. From _each_utf8_hex we see it outputs '\\'+hex digits.\n    #    For example, '\\e4' for byte 0xe4.\n    #    So escape sequences are backslash + 1 or 2 hex digits possibly?\n    #\n    #    _each_utf8_hex produces escapes like '\\%s' % hex(byte)[1:], where hex(byte) is e.g. '0xe4',\n    #    [1:] drops the '0' => 'xe4', so the escape is '\\xe4', i.e. backslash + 'x' + 2 hex digits,\n    #    the normal Python hex escape format.\n    #\n    #    Wait no, hex(byte) gives '0xe4', [1:] is 'xe4', so '\\xe4' as string.\n    #    So interpret '\\xe4' as bytes 0xe4.\n    #\n    # 3. So escapes look like '\\xHH' (where H is hex digit). We must parse these into bytes.\n    # 4. For other chars, interpret them as ASCII bytes.\n    # 5. Accumulate bytes accordingly.\n    #\n    # After building bytes from text, try to decode bytes with 'utf8' to verify validity.\n    # If invalid, raise UnicodeEncodeError.\n    #\n    # errors param can be 'strict' or others (not specified in detail), so follow standard behavior.\n    #\n    # Return the bytes and len(text).\n    #\n    # Edge cases:\n    # - Partial/backslash at end without enough hex digits (error)\n    # - Non-hex char after backslash (error)\n    # - Normal printable ASCII preserved as is (their byte value)\n    #\n    # We treat all escaped sequences strictly as '\\xHH'\n\n    b_array = bytearray()\n    i = 0\n    text_len = len(text)\n\n    while i < text_len:\n        c = text[i]\n\n        if c == '\\\\':\n            # Try to parse escaped byte '\\xHH'\n            # Check if there are at least 3 chars left for \\xHH\n            # Pattern expected is: \\xHH (4 chars total)\n            # But from _each_utf8_hex, escape format is '\\xe4' (length 4)\n            # So if next char is 'x' and then two hex digits\n\n            if i + 3 < text_len and text[i + 1] == 'x':\n                hex_part = text[i + 2:i + 4]\n                # Validate hex digits\n                if all(ch in '0123456789abcdefABCDEF' for ch in hex_part):\n                    byte_val = int(hex_part, 16)\n                    b_array.append(byte_val)\n                    i += 4\n                    continue\n                else:\n                    # Invalid hex digits in escape\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"encode\", text, i, i + 4,\n                            \"invalid escaped utf8 hex bytes\"\n                        )\n                    elif errors == 'replace':\n                        b_array.append(ord('?'))\n                        i += 4\n                        continue\n                    elif errors == 'ignore':\n                        i += 4\n                        continue\n                    else:\n                        # fallback raise\n                        raise UnicodeEncodeError(\n                            \"encode\", text, i, i + 4,\n                            \"invalid escaped utf8 hex bytes\"\n                        )\n            else:\n                # Backslash not followed by 'x' and two hex digits,\n                # treat backslash as literal byte?\n                # The docstring does not specify this case clearly.\n                # We can treat it as error or literal backslash byte.\n                # For strict, raise error.\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"encode\", text, i, i + 1,\n                        \"invalid escape sequence\"\n                    )\n                elif errors == 'replace':\n                    b_array.append(ord('?'))\n                    i += 1\n                    continue\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"encode\", text, i, i + 1,\n                        \"invalid escape sequence\"\n                    )\n        else:\n            # Regular char: if printable ASCII < 128, encode as byte value\n            # else error?\n            # The docstring allows input text to contain characters beyond ASCII if escaped.\n            # So anything other than ASCII not escaped is invalid for encoding?\n            # Not explicitly stated.\n            # The safe way is to encode all printable ASCII chars as bytes.\n            o = ord(c)\n            if o < 128:\n                b_array.append(o)\n                i += 1\n                continue\n            else:\n                # Non ASCII char not escaped - invalid or encode using UTF8?\n                # The docstring says input \"that may contain escaped utf8 hexadecimal\"\n                # but does not forbid unescaped unicode.\n                # We can encode this char as UTF-8 bytes as fallback.\n                # The _each_utf8_hex context function encodes such chars to escapes\n                # but here we decode, so we accept them as UTF-8 bytes.\n\n                # Encode character to UTF-8 bytes\n                try:\n                    utf8_bytes = c.encode('utf8')\n                except UnicodeEncodeError as e:\n                    if errors == 'strict':\n                        raise e\n                    elif errors == 'replace':\n                        b_array.append(ord('?'))\n                        i += 1\n                        continue\n                    elif errors == 'ignore':\n                        i += 1\n                        continue\n                    else:\n                        raise e\n                b_array.extend(utf8_bytes)\n                i += 1\n                continue\n\n    # Validate bytes are valid utf8, else UnicodeEncodeError\n    try:\n        b_array.decode('utf8')\n    except UnicodeDecodeError as e:\n        # Raise as UnicodeEncodeError as per docstring\n        raise UnicodeEncodeError(\n            \"encode\", text, e.start, e.end,\n            \"input contains invalid escaped utf8 hex bytes\"\n        ) from e\n\n    return bytes(b_array), text_len", "from typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # The goal of this function:\n    # - The input is a string that MAY contain escaped utf8 hex bytes, i.e. sequences like \\xx where xx is hex.\n    # - We need to decode those escaped hex sequences into the actual bytes they represent.\n    # - Any other characters are converted to their UTF-8 escaped hex form (like \\xx sequences).\n    #\n    # Steps:\n    # 1. Parse the input string left-to-right.\n    # 2. When we see a backslash followed by two hex digits, try to interpret it as a byte.\n    #    Validate that the bytes we accumulate form valid UTF-8 sequences.\n    # 3. If validation fails and errors='strict', raise UnicodeEncodeError.\n    # 4. For other characters, encode them using _each_utf8_hex to produce the escaped hex sequences.\n    #\n    # Note: The output is bytes, but the bytes contained are actually ascii codes of characters like '\\', 'a', 'b', etc.\n    # Because the escaped hex is like literal \\xx sequences (backslash is single byte 0x5c).\n    #\n    # Implementation detail:\n    # We will build a bytearray to hold the escaped hex representation of the entire text.\n    #\n    # For those parts already escaped, we decode the \\xx sequences into bytes, validate UTF8, \n    # then re-escape those bytes (so that the output is escaped hex form of all decoded bytes).\n    #\n    # Wait, the doc says \"Convert a str, that may contain escaped utf8 hexadecimal, to bytes of escaped utf8 hexadecimal\".\n    # So the output is bytes representing the escaped utf8 hex, i.e. something like b'\\x5c\\x61' for '\\a' (but likely \\61 = 'a').\n    #\n    # But let's confirm by example:\n    # Input: \"abc\" should become b'abc' where a,b,c are escaped hex or as is because they are printable ASCII.\n    # Input: \"a\\\\e1\" (where \\e1 is an escaped byte e1 hex) means the e1 byte (UTF-8) is decoded from \\e1, output escaped.\n    # So the function interprets backslash escapes, decodes them into bytes, checks valid utf8, then re-encodes everything into escaped utf8 hex bytes.\n    #\n    # So indeed, we need:\n    # - Parse input text, convert any \\xx sequences to bytes.\n    # - Validate that the bytes form valid UTF-8 sequences.\n    # - Then re-escape those bytes into \\xx sequences as bytes and return with the count of consumed characters.\n    #\n    # The number of consumed characters is the length of the input text (since all characters are consumed).\n    #\n    # If invalid hex or invalid UTF-8 in the escaped hex sequences, raise UnicodeEncodeError if errors == 'strict'.\n    #\n    # The _each_utf8_hex function yields a generator of characters already escaped as needed, but here we need to parse escaped sequences to bytes first and validate.\n\n\n    def is_hex_digit(c: str) -> bool:\n        return c in \"0123456789abcdefABCDEF\"\n\n    # Step 1: Parse the input and decode escaped hex sequences to bytes\n    byte_buffer = bytearray()\n    i = 0\n    length = len(text)\n\n    while i < length:\n        c = text[i]\n        if c == '\\\\':\n            # Possible start of escaped sequence \\xx\n            if i + 2 < length and is_hex_digit(text[i+1]) and is_hex_digit(text[i+2]):\n                hex_part = text[i+1:i+3]\n                try:\n                    byte_val = int(hex_part, 16)\n                except ValueError:\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"raw_unicode_escape\", text, i, i+3,\n                            f\"invalid escaped hex value \\\\{hex_part}\"\n                        )\n                    else:\n                        # If errors is not strict, treat literally\n                        byte_buffer.extend(c.encode('ascii'))\n                        i += 1\n                        continue\n                byte_buffer.append(byte_val)\n                i += 3\n            else:\n                # Invalid escape sequence, but since the function is about escaped hex bytes,\n                # treat '\\' literally or error based on errors parameter\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\", text, i, i+1,\n                        \"trailing '\\\\' or invalid escape sequence\"\n                    )\n                else:\n                    # Non-strict: treat '\\' literally\n                    byte_buffer.extend(c.encode('ascii'))\n                    i += 1\n        else:\n            # Regular character: encode it to utf8 bytes and append\n            # To be consistent, encode character to UTF8 bytes and append\n            # Because the input text can be mixed escaped bytes and normal characters\n            byte_buffer.extend(c.encode('utf8'))\n            i += 1\n\n    # Step 2: Validate bytes as valid utf8 sequence\n    try:\n        byte_buffer.decode('utf8')\n    except UnicodeDecodeError as e:\n        if errors == 'strict':\n            raise UnicodeEncodeError(\n                \"raw_unicode_escape\", text, e.start, e.end,\n                \"bytes refer to invalid utf8 sequence\"\n            ) from e\n        else:\n            # if not strict, fallback to something reasonable\n            pass\n\n    # Step 3: Re-escape bytes into '\\xx' escaped utf8 hexadecimal bytes\n    # We want to produce a bytes object containing ASCII characters with backslash-escaped hex bytes for non-printables.\n\n    # Use a helper here: for each byte in byte_buffer:\n    #   if byte is printable ASCII and not backslash: output as is\n    #   else: output b'\\\\' + hex representation (2 lowercase hex digits)\n\n    result_bytes = bytearray()\n    for b in byte_buffer:\n        # ASCII printable range: 32-126 inclusive, excluding backslash (92)\n        if 32 <= b <= 126 and b != 92:\n            result_bytes.append(b)\n        else:\n            # escaped form: b'\\\\xx'\n            result_bytes.append(92)  # '\\\\'\n            hex_str = hex(b)[2:].rjust(2, '0').lower()\n            result_bytes.extend(hex_str.encode('ascii'))\n\n    return bytes(result_bytes), length", "from typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Strategy:\n    # 1. The input text may contain normal printable characters and escaped utf8 hex sequences\n    #    like \\xx where xx is two hex digits.\n    # 2. We must interpret these escaped sequences as bytes, validate they're valid UTF-8 bytes,\n    #    and then output the entire text as a bytes object representing the escaped utf8 hex bytes.\n    # 3. For normal printable ASCII characters (except backslash?), we output them as-is (as bytes).\n    # 4. For backslash, we check if it's followed by two hex digits; if yes, decode them as a byte.\n    #    If no, error according to errors.\n    # 5. We must validate that the bytes decoded from escaped sequences form valid utf8. The docstring\n    #    says raise UnicodeEncodeError if the escaped hex references invalid UTF-8 bytes.\n    # 6. The returned bytes will represent the escaped sequence of bytes (each byte to b'\\xx').\n    #    But the docstring: \"Convert a str that may contain escaped utf8 hex to bytes of escaped utf8 hex\".\n    #\n    # After re-reading: It seems the primary job is to decode the escaped hex sequences into their bytes,\n    # ensure those bytes are valid UTF-8 sequences, then output those bytes. But the docstring says \"bytes of escaped utf8 hexadecimal\".\n    #\n    # From the example of _each_utf8_hex, it converts a str containing unicode characters to the escaped hex form.\n    # Here we are going the opposite way: the input string may contain escaped hex (like \\xx) representing UTF-8 bytes.\n    # We decode those into bytes, check validity, and return those bytes along with the count of consumed chars.\n    #\n    # So the output bytes is the actual raw bytes decoded from text's escaped sequences and normal chars.\n    #\n    # Implementation plan:\n    # - Iterate through text by index.\n    # - When a backslash '\\' is found, look ahead for two hex digits.\n    #   If found, decode that byte.\n    #   If not a correct sequence:\n    #     - If errors='strict', raise UnicodeEncodeError.\n    #     - Else (ignore or replace), handle accordingly.\n    # - For normal chars (printable ASCII), convert to their utf8 byte (which for ASCII is same as ord(char)).\n    # - Collect all bytes in a bytes array.\n    # - After full decoding, validate the decoded bytes with bytes.decode('utf8'); if invalid raise UnicodeEncodeError.\n    #\n    # Return the bytes and the number of characters consumed (should be len(text)).\n\n    import re\n\n    i = 0\n    n = len(text)\n    result_bytes = bytearray()\n\n    def _raise_encode_error(encoded_text, position):\n        raise UnicodeEncodeError(\n            \"utf-8\",  # encoding\n            encoded_text,\n            position,\n            position + 1,\n            \"invalid escaped byte sequence\"\n        )\n\n    hex_digit = \"0123456789abcdefABCDEF\"\n    while i < n:\n        c = text[i]\n        if c == '\\\\':  # possible escaped hex sequence\n            if i + 2 < n:\n                h1 = text[i + 1]\n                h2 = text[i + 2]\n                if h1 in hex_digit and h2 in hex_digit:\n                    byte_val = int(h1 + h2, 16)\n                    result_bytes.append(byte_val)\n                    i += 3\n                    continue\n                else:\n                    if errors == 'strict':\n                        _raise_encode_error(text, i)\n                    elif errors == 'ignore':\n                        # skip the backslash only\n                        i += 1\n                        continue\n                    elif errors == 'replace':\n                        # replace invalid escape with 0x3f '?'\n                        result_bytes.append(0x3f)\n                        i += 3  # still skip 3 chars\n                        continue\n                    else:\n                        # Unknown errors mode\n                        _raise_encode_error(text, i)\n            else:\n                # backslash at end or incomplete escape\n                if errors == 'strict':\n                    _raise_encode_error(text, i)\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(0x3f)\n                    i = n\n                    continue\n                else:\n                    _raise_encode_error(text, i)\n        else:\n            # Normal char\n            # Encode char in utf8 bytes (should be ASCII char)\n            # For safety, encode it and append bytes\n            try:\n                b = c.encode(\"utf-8\")\n            except UnicodeEncodeError as e:\n                if errors == 'strict':\n                    raise e\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    b = b'?'\n                else:\n                    raise e\n            result_bytes.extend(b)\n            i += 1\n\n    # Validate that decoded bytes form valid utf8 sequence\n    try:\n        result_bytes.decode('utf-8')\n    except UnicodeDecodeError as e:\n        # Raise as UnicodeEncodeError per docstring\n        raise UnicodeEncodeError(\n            \"utf-8\",\n            result_bytes,\n            e.start,\n            e.end,\n            \"escaped utf8 hexadecimal referencing invalid utf8 bytes\"\n        ) from e\n\n    # Return the bytes and number of characters consumed (all)\n    return bytes(result_bytes), n", "from typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # We need to parse the text which may contain escaped utf8 hexadecimal sequences like '\\xx'\n    # and decode them into bytes. Non-escaped characters should be interpreted as single bytes if ASCII,\n    # or as utf8 encoded bytes if non-ASCII.\n    #\n    # The function returns a bytes object that is the binary representation of all those bytes,\n    # as well as the count of characters consumed from the input string (always full length).\n    #\n    # If any invalid escape sequence or invalid UTF-8 bytes appears, raise UnicodeEncodeError.\n    #\n    # The 'errors' arg is the error handling scheme for decode errors in reading escaped hex bytes.\n    # We support the same 'strict', 'ignore', 'replace' mechanisms like standard codecs usually.\n\n    result_bytes = bytearray()\n    i = 0\n    length = len(text)\n\n    while i < length:\n        ch = text[i]\n        if ch == '\\\\':\n            # We expect an escaped hex sequence: backslash + 2 hex digits\n            # Validate that i+2 exists\n            if i + 2 >= length:\n                # Incomplete escape sequence\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\", text, i, i + 1,\n                        \"truncated \\\\xXX escape sequence\"\n                    )\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(ord('?'))\n                    i += 1\n                    continue\n                else:\n                    raise ValueError(f\"Unsupported error handler: {errors}\")\n\n            hex_part = text[i+1:i+3]\n\n            # hex_part should be exactly 2 hex digits\n            try:\n                byte_val = int(hex_part, 16)\n            except ValueError:\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\", text, i, i + 3,\n                        f\"invalid hexadecimal escape sequence \\\\{hex_part}\"\n                    )\n                elif errors == 'ignore':\n                    i += 3\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(ord('?'))\n                    i += 3\n                    continue\n                else:\n                    raise ValueError(f\"Unsupported error handler: {errors}\")\n\n            # Append this byte\n            result_bytes.append(byte_val)\n            i += 3\n        else:\n            # Non-escaped character:\n            # Convert the char to bytes using UTF-8 encoding\n            # Append those bytes\n            try:\n                encoded_bytes = ch.encode('utf8')\n            except UnicodeEncodeError as e:\n                if errors == 'strict':\n                    raise e\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(ord('?'))\n                    i += 1\n                    continue\n                else:\n                    raise ValueError(f\"Unsupported error handler: {errors}\")\n\n            result_bytes.extend(encoded_bytes)\n            i += 1\n\n    # Validate that result_bytes is valid utf8?\n    # The docstring says we raise UnicodeEncodeError if the given text contains escaped utf8 hexadecimal \n    # that references invalid utf8 bytes.\n    # So we need to check that the assembled bytes are valid UTF-8.\n\n    try:\n        result_bytes.decode('utf8')\n    except UnicodeDecodeError as e:\n        # Raise UnicodeEncodeError here with similar info\n        raise UnicodeEncodeError(\n            \"raw_unicode_escape\", text, e.start, e.end,\n            \"invalid UTF-8 sequence after decoding escaped utf8 hex\"\n        ) from e\n\n    # Return the bytes and number of characters consumed (all)\n    return bytes(result_bytes), length"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nimport codecs\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # The input text may contain escaped UTF-8 hex sequences like \\xx.\n    # We need to \"decode\" these sequences into bytes, validating that they form valid UTF-8.\n    # After decoding, we return the bytes and the number of characters consumed from the input.\n\n    input_str = str(text)\n    length = len(input_str)\n    bytes_out = bytearray()\n\n    i = 0\n    while i < length:\n        c = input_str[i]\n        if c != '\\\\':  # normal character, add its UTF-8 bytes\n            # encode this character in UTF-8 and append to output\n            try:\n                encoded_bytes = c.encode('utf8', errors)\n            except UnicodeEncodeError as e:\n                # Re-raise with the same semantics\n                raise e\n            bytes_out.extend(encoded_bytes)\n            i += 1\n        else:\n            # Possible escaped hex sequence \\xx\n            # We expect exactly two hex digits after the backslash\n            if i + 2 >= length:\n                # Backslash at the end or incomplete sequence\n                # Handle errors according to 'errors' policy\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+1,\n                        \"trailing \\\\ at end of string\"\n                    )\n                elif errors == 'ignore':\n                    # Skip backslash\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    bytes_out.extend(b'?')\n                    i += 1\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+1,\n                        f\"unknown error handler '{errors}'\"\n                    )\n\n            hex_part = input_str[i+1:i+3]\n            try:\n                byte_val = int(hex_part, 16)\n            except ValueError:\n                # Not valid hex digits after backslash\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+3,\n                        \"invalid escape sequence\"\n                    )\n                elif errors == 'ignore':\n                    i += 3\n                    continue\n                elif errors == 'replace':\n                    bytes_out.extend(b'?')\n                    i += 3\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\",\n                        input_str, i, i+3,\n                        f\"unknown error handler '{errors}'\"\n                    )\n\n            # Append this byte to a temporary bytes buffer to later validate UTF-8\n            # But we need to build full byte sequence before validating\n            # So let's collect bytes until next char is non-escaped or end reached,\n            # then validate all bytes in one go.\n\n            # But since the function is to convert the entire string to escaped utf8 bytes,\n            # and the presence of \\xx means byte values, presumably the bytes_out should be raw bytes,\n            # however docstring states \"bytes of escaped utf8 hexadecimal\".\n            #\n            # On close read: \"Convert a str, that may contain escaped utf8 hexadecimal, to bytes of escaped utf8 hexadecimal.\"\n            #\n            # But the output is bytes: the given \"text\" converted into escaped utf8 bytes.\n            # This is ambiguous but likely means the output bytes represent the bytes of the encoded string,\n            # where any escaped hex is converted into byte values.\n            #\n            # So we should decode \\xx sequences into the bytes they represent,\n            # and the other characters into their UTF-8 encoded bytes.\n            #\n            # Here we append byte_val as a byte.\n            bytes_out.append(byte_val)\n            i += 3\n\n    # Now validate that the entire bytes_out is valid UTF-8\n    try:\n        bytes_out.decode('utf8')\n    except UnicodeDecodeError as e:\n        # The given text contains escaped utf8 hexadecimal that references invalid utf8 bytes\n        # Raise UnicodeEncodeError as required by spec\n        raise UnicodeEncodeError(\n            \"utf8\",\n            bytes_out,\n            e.start,\n            e.end,\n            \"invalid UTF-8 byte sequence\"\n        ) from None\n\n    # Return bytes_out and number of characters consumed from input_str (all)\n    return bytes(bytes_out), length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Since the function's docstring says the input text may contain escaped\n    # utf8 hexadecimal, and that it must be converted into escaped utf8 bytes,\n    # we must interpret existing escapes and verify they form valid utf8 bytes.\n    #\n    # The function should:\n    # - Parse the input text to handle escaped hex bytes like '\\xx'\n    # - Validate that the resulting bytes decode as valid UTF-8 (to ensure valid sequences)\n    # - Return those bytes as a bytes object\n    # - Return the number of characters consumed (whole length of text)\n    #\n    # Implementation plan:\n    # 1. Scan the text left to right.\n    # 2. When backslash encountered, try to parse an escaped hex byte (e.g. \\xhh or \\hh)\n    #    but docstring says \"escaped utf8 hexadecimal\" - it seems the style is '\\xx',\n    #    where xx is hex without the 'x'. From _each_utf8_hex we see it outputs '\\'+hex digits.\n    #    For example, '\\e4' for byte 0xe4.\n    #    So escape sequences are backslash + 1 or 2 hex digits possibly?\n    #\n    #    _each_utf8_hex produces escapes like '\\%s' % hex(byte)[1:], where hex(byte) is e.g. '0xe4',\n    #    [1:] drops the '0' => 'xe4', so the escape is '\\xe4', i.e. backslash + 'x' + 2 hex digits,\n    #    the normal Python hex escape format.\n    #\n    #    Wait no, hex(byte) gives '0xe4', [1:] is 'xe4', so '\\xe4' as string.\n    #    So interpret '\\xe4' as bytes 0xe4.\n    #\n    # 3. So escapes look like '\\xHH' (where H is hex digit). We must parse these into bytes.\n    # 4. For other chars, interpret them as ASCII bytes.\n    # 5. Accumulate bytes accordingly.\n    #\n    # After building bytes from text, try to decode bytes with 'utf8' to verify validity.\n    # If invalid, raise UnicodeEncodeError.\n    #\n    # errors param can be 'strict' or others (not specified in detail), so follow standard behavior.\n    #\n    # Return the bytes and len(text).\n    #\n    # Edge cases:\n    # - Partial/backslash at end without enough hex digits (error)\n    # - Non-hex char after backslash (error)\n    # - Normal printable ASCII preserved as is (their byte value)\n    #\n    # We treat all escaped sequences strictly as '\\xHH'\n\n    b_array = bytearray()\n    i = 0\n    text_len = len(text)\n\n    while i < text_len:\n        c = text[i]\n\n        if c == '\\\\':\n            # Try to parse escaped byte '\\xHH'\n            # Check if there are at least 3 chars left for \\xHH\n            # Pattern expected is: \\xHH (4 chars total)\n            # But from _each_utf8_hex, escape format is '\\xe4' (length 4)\n            # So if next char is 'x' and then two hex digits\n\n            if i + 3 < text_len and text[i + 1] == 'x':\n                hex_part = text[i + 2:i + 4]\n                # Validate hex digits\n                if all(ch in '0123456789abcdefABCDEF' for ch in hex_part):\n                    byte_val = int(hex_part, 16)\n                    b_array.append(byte_val)\n                    i += 4\n                    continue\n                else:\n                    # Invalid hex digits in escape\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"encode\", text, i, i + 4,\n                            \"invalid escaped utf8 hex bytes\"\n                        )\n                    elif errors == 'replace':\n                        b_array.append(ord('?'))\n                        i += 4\n                        continue\n                    elif errors == 'ignore':\n                        i += 4\n                        continue\n                    else:\n                        # fallback raise\n                        raise UnicodeEncodeError(\n                            \"encode\", text, i, i + 4,\n                            \"invalid escaped utf8 hex bytes\"\n                        )\n            else:\n                # Backslash not followed by 'x' and two hex digits,\n                # treat backslash as literal byte?\n                # The docstring does not specify this case clearly.\n                # We can treat it as error or literal backslash byte.\n                # For strict, raise error.\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"encode\", text, i, i + 1,\n                        \"invalid escape sequence\"\n                    )\n                elif errors == 'replace':\n                    b_array.append(ord('?'))\n                    i += 1\n                    continue\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                else:\n                    raise UnicodeEncodeError(\n                        \"encode\", text, i, i + 1,\n                        \"invalid escape sequence\"\n                    )\n        else:\n            # Regular char: if printable ASCII < 128, encode as byte value\n            # else error?\n            # The docstring allows input text to contain characters beyond ASCII if escaped.\n            # So anything other than ASCII not escaped is invalid for encoding?\n            # Not explicitly stated.\n            # The safe way is to encode all printable ASCII chars as bytes.\n            o = ord(c)\n            if o < 128:\n                b_array.append(o)\n                i += 1\n                continue\n            else:\n                # Non ASCII char not escaped - invalid or encode using UTF8?\n                # The docstring says input \"that may contain escaped utf8 hexadecimal\"\n                # but does not forbid unescaped unicode.\n                # We can encode this char as UTF-8 bytes as fallback.\n                # The _each_utf8_hex context function encodes such chars to escapes\n                # but here we decode, so we accept them as UTF-8 bytes.\n\n                # Encode character to UTF-8 bytes\n                try:\n                    utf8_bytes = c.encode('utf8')\n                except UnicodeEncodeError as e:\n                    if errors == 'strict':\n                        raise e\n                    elif errors == 'replace':\n                        b_array.append(ord('?'))\n                        i += 1\n                        continue\n                    elif errors == 'ignore':\n                        i += 1\n                        continue\n                    else:\n                        raise e\n                b_array.extend(utf8_bytes)\n                i += 1\n                continue\n\n    # Validate bytes are valid utf8, else UnicodeEncodeError\n    try:\n        b_array.decode('utf8')\n    except UnicodeDecodeError as e:\n        # Raise as UnicodeEncodeError as per docstring\n        raise UnicodeEncodeError(\n            \"encode\", text, e.start, e.end,\n            \"input contains invalid escaped utf8 hex bytes\"\n        ) from e\n\n    return bytes(b_array), text_len\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # The goal of this function:\n    # - The input is a string that MAY contain escaped utf8 hex bytes, i.e. sequences like \\xx where xx is hex.\n    # - We need to decode those escaped hex sequences into the actual bytes they represent.\n    # - Any other characters are converted to their UTF-8 escaped hex form (like \\xx sequences).\n    #\n    # Steps:\n    # 1. Parse the input string left-to-right.\n    # 2. When we see a backslash followed by two hex digits, try to interpret it as a byte.\n    #    Validate that the bytes we accumulate form valid UTF-8 sequences.\n    # 3. If validation fails and errors='strict', raise UnicodeEncodeError.\n    # 4. For other characters, encode them using _each_utf8_hex to produce the escaped hex sequences.\n    #\n    # Note: The output is bytes, but the bytes contained are actually ascii codes of characters like '\\', 'a', 'b', etc.\n    # Because the escaped hex is like literal \\xx sequences (backslash is single byte 0x5c).\n    #\n    # Implementation detail:\n    # We will build a bytearray to hold the escaped hex representation of the entire text.\n    #\n    # For those parts already escaped, we decode the \\xx sequences into bytes, validate UTF8, \n    # then re-escape those bytes (so that the output is escaped hex form of all decoded bytes).\n    #\n    # Wait, the doc says \"Convert a str, that may contain escaped utf8 hexadecimal, to bytes of escaped utf8 hexadecimal\".\n    # So the output is bytes representing the escaped utf8 hex, i.e. something like b'\\x5c\\x61' for '\\a' (but likely \\61 = 'a').\n    #\n    # But let's confirm by example:\n    # Input: \"abc\" should become b'abc' where a,b,c are escaped hex or as is because they are printable ASCII.\n    # Input: \"a\\\\e1\" (where \\e1 is an escaped byte e1 hex) means the e1 byte (UTF-8) is decoded from \\e1, output escaped.\n    # So the function interprets backslash escapes, decodes them into bytes, checks valid utf8, then re-encodes everything into escaped utf8 hex bytes.\n    #\n    # So indeed, we need:\n    # - Parse input text, convert any \\xx sequences to bytes.\n    # - Validate that the bytes form valid UTF-8 sequences.\n    # - Then re-escape those bytes into \\xx sequences as bytes and return with the count of consumed characters.\n    #\n    # The number of consumed characters is the length of the input text (since all characters are consumed).\n    #\n    # If invalid hex or invalid UTF-8 in the escaped hex sequences, raise UnicodeEncodeError if errors == 'strict'.\n    #\n    # The _each_utf8_hex function yields a generator of characters already escaped as needed, but here we need to parse escaped sequences to bytes first and validate.\n\n\n    def is_hex_digit(c: str) -> bool:\n        return c in \"0123456789abcdefABCDEF\"\n\n    # Step 1: Parse the input and decode escaped hex sequences to bytes\n    byte_buffer = bytearray()\n    i = 0\n    length = len(text)\n\n    while i < length:\n        c = text[i]\n        if c == '\\\\':\n            # Possible start of escaped sequence \\xx\n            if i + 2 < length and is_hex_digit(text[i+1]) and is_hex_digit(text[i+2]):\n                hex_part = text[i+1:i+3]\n                try:\n                    byte_val = int(hex_part, 16)\n                except ValueError:\n                    if errors == 'strict':\n                        raise UnicodeEncodeError(\n                            \"raw_unicode_escape\", text, i, i+3,\n                            f\"invalid escaped hex value \\\\{hex_part}\"\n                        )\n                    else:\n                        # If errors is not strict, treat literally\n                        byte_buffer.extend(c.encode('ascii'))\n                        i += 1\n                        continue\n                byte_buffer.append(byte_val)\n                i += 3\n            else:\n                # Invalid escape sequence, but since the function is about escaped hex bytes,\n                # treat '\\' literally or error based on errors parameter\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\", text, i, i+1,\n                        \"trailing '\\\\' or invalid escape sequence\"\n                    )\n                else:\n                    # Non-strict: treat '\\' literally\n                    byte_buffer.extend(c.encode('ascii'))\n                    i += 1\n        else:\n            # Regular character: encode it to utf8 bytes and append\n            # To be consistent, encode character to UTF8 bytes and append\n            # Because the input text can be mixed escaped bytes and normal characters\n            byte_buffer.extend(c.encode('utf8'))\n            i += 1\n\n    # Step 2: Validate bytes as valid utf8 sequence\n    try:\n        byte_buffer.decode('utf8')\n    except UnicodeDecodeError as e:\n        if errors == 'strict':\n            raise UnicodeEncodeError(\n                \"raw_unicode_escape\", text, e.start, e.end,\n                \"bytes refer to invalid utf8 sequence\"\n            ) from e\n        else:\n            # if not strict, fallback to something reasonable\n            pass\n\n    # Step 3: Re-escape bytes into '\\xx' escaped utf8 hexadecimal bytes\n    # We want to produce a bytes object containing ASCII characters with backslash-escaped hex bytes for non-printables.\n\n    # Use a helper here: for each byte in byte_buffer:\n    #   if byte is printable ASCII and not backslash: output as is\n    #   else: output b'\\\\' + hex representation (2 lowercase hex digits)\n\n    result_bytes = bytearray()\n    for b in byte_buffer:\n        # ASCII printable range: 32-126 inclusive, excluding backslash (92)\n        if 32 <= b <= 126 and b != 92:\n            result_bytes.append(b)\n        else:\n            # escaped form: b'\\\\xx'\n            result_bytes.append(92)  # '\\\\'\n            hex_str = hex(b)[2:].rjust(2, '0').lower()\n            result_bytes.extend(hex_str.encode('ascii'))\n\n    return bytes(result_bytes), length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Strategy:\n    # 1. The input text may contain normal printable characters and escaped utf8 hex sequences\n    #    like \\xx where xx is two hex digits.\n    # 2. We must interpret these escaped sequences as bytes, validate they're valid UTF-8 bytes,\n    #    and then output the entire text as a bytes object representing the escaped utf8 hex bytes.\n    # 3. For normal printable ASCII characters (except backslash?), we output them as-is (as bytes).\n    # 4. For backslash, we check if it's followed by two hex digits; if yes, decode them as a byte.\n    #    If no, error according to errors.\n    # 5. We must validate that the bytes decoded from escaped sequences form valid utf8. The docstring\n    #    says raise UnicodeEncodeError if the escaped hex references invalid UTF-8 bytes.\n    # 6. The returned bytes will represent the escaped sequence of bytes (each byte to b'\\xx').\n    #    But the docstring: \"Convert a str that may contain escaped utf8 hex to bytes of escaped utf8 hex\".\n    #\n    # After re-reading: It seems the primary job is to decode the escaped hex sequences into their bytes,\n    # ensure those bytes are valid UTF-8 sequences, then output those bytes. But the docstring says \"bytes of escaped utf8 hexadecimal\".\n    #\n    # From the example of _each_utf8_hex, it converts a str containing unicode characters to the escaped hex form.\n    # Here we are going the opposite way: the input string may contain escaped hex (like \\xx) representing UTF-8 bytes.\n    # We decode those into bytes, check validity, and return those bytes along with the count of consumed chars.\n    #\n    # So the output bytes is the actual raw bytes decoded from text's escaped sequences and normal chars.\n    #\n    # Implementation plan:\n    # - Iterate through text by index.\n    # - When a backslash '\\' is found, look ahead for two hex digits.\n    #   If found, decode that byte.\n    #   If not a correct sequence:\n    #     - If errors='strict', raise UnicodeEncodeError.\n    #     - Else (ignore or replace), handle accordingly.\n    # - For normal chars (printable ASCII), convert to their utf8 byte (which for ASCII is same as ord(char)).\n    # - Collect all bytes in a bytes array.\n    # - After full decoding, validate the decoded bytes with bytes.decode('utf8'); if invalid raise UnicodeEncodeError.\n    #\n    # Return the bytes and the number of characters consumed (should be len(text)).\n\n    import re\n\n    i = 0\n    n = len(text)\n    result_bytes = bytearray()\n\n    def _raise_encode_error(encoded_text, position):\n        raise UnicodeEncodeError(\n            \"utf-8\",  # encoding\n            encoded_text,\n            position,\n            position + 1,\n            \"invalid escaped byte sequence\"\n        )\n\n    hex_digit = \"0123456789abcdefABCDEF\"\n    while i < n:\n        c = text[i]\n        if c == '\\\\':  # possible escaped hex sequence\n            if i + 2 < n:\n                h1 = text[i + 1]\n                h2 = text[i + 2]\n                if h1 in hex_digit and h2 in hex_digit:\n                    byte_val = int(h1 + h2, 16)\n                    result_bytes.append(byte_val)\n                    i += 3\n                    continue\n                else:\n                    if errors == 'strict':\n                        _raise_encode_error(text, i)\n                    elif errors == 'ignore':\n                        # skip the backslash only\n                        i += 1\n                        continue\n                    elif errors == 'replace':\n                        # replace invalid escape with 0x3f '?'\n                        result_bytes.append(0x3f)\n                        i += 3  # still skip 3 chars\n                        continue\n                    else:\n                        # Unknown errors mode\n                        _raise_encode_error(text, i)\n            else:\n                # backslash at end or incomplete escape\n                if errors == 'strict':\n                    _raise_encode_error(text, i)\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(0x3f)\n                    i = n\n                    continue\n                else:\n                    _raise_encode_error(text, i)\n        else:\n            # Normal char\n            # Encode char in utf8 bytes (should be ASCII char)\n            # For safety, encode it and append bytes\n            try:\n                b = c.encode(\"utf-8\")\n            except UnicodeEncodeError as e:\n                if errors == 'strict':\n                    raise e\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    b = b'?'\n                else:\n                    raise e\n            result_bytes.extend(b)\n            i += 1\n\n    # Validate that decoded bytes form valid utf8 sequence\n    try:\n        result_bytes.decode('utf-8')\n    except UnicodeDecodeError as e:\n        # Raise as UnicodeEncodeError per docstring\n        raise UnicodeEncodeError(\n            \"utf-8\",\n            result_bytes,\n            e.start,\n            e.end,\n            \"escaped utf8 hexadecimal referencing invalid utf8 bytes\"\n        ) from e\n\n    # Return the bytes and number of characters consumed (all)\n    return bytes(result_bytes), n\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # We need to parse the text which may contain escaped utf8 hexadecimal sequences like '\\xx'\n    # and decode them into bytes. Non-escaped characters should be interpreted as single bytes if ASCII,\n    # or as utf8 encoded bytes if non-ASCII.\n    #\n    # The function returns a bytes object that is the binary representation of all those bytes,\n    # as well as the count of characters consumed from the input string (always full length).\n    #\n    # If any invalid escape sequence or invalid UTF-8 bytes appears, raise UnicodeEncodeError.\n    #\n    # The 'errors' arg is the error handling scheme for decode errors in reading escaped hex bytes.\n    # We support the same 'strict', 'ignore', 'replace' mechanisms like standard codecs usually.\n\n    result_bytes = bytearray()\n    i = 0\n    length = len(text)\n\n    while i < length:\n        ch = text[i]\n        if ch == '\\\\':\n            # We expect an escaped hex sequence: backslash + 2 hex digits\n            # Validate that i+2 exists\n            if i + 2 >= length:\n                # Incomplete escape sequence\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\", text, i, i + 1,\n                        \"truncated \\\\xXX escape sequence\"\n                    )\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(ord('?'))\n                    i += 1\n                    continue\n                else:\n                    raise ValueError(f\"Unsupported error handler: {errors}\")\n\n            hex_part = text[i+1:i+3]\n\n            # hex_part should be exactly 2 hex digits\n            try:\n                byte_val = int(hex_part, 16)\n            except ValueError:\n                if errors == 'strict':\n                    raise UnicodeEncodeError(\n                        \"raw_unicode_escape\", text, i, i + 3,\n                        f\"invalid hexadecimal escape sequence \\\\{hex_part}\"\n                    )\n                elif errors == 'ignore':\n                    i += 3\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(ord('?'))\n                    i += 3\n                    continue\n                else:\n                    raise ValueError(f\"Unsupported error handler: {errors}\")\n\n            # Append this byte\n            result_bytes.append(byte_val)\n            i += 3\n        else:\n            # Non-escaped character:\n            # Convert the char to bytes using UTF-8 encoding\n            # Append those bytes\n            try:\n                encoded_bytes = ch.encode('utf8')\n            except UnicodeEncodeError as e:\n                if errors == 'strict':\n                    raise e\n                elif errors == 'ignore':\n                    i += 1\n                    continue\n                elif errors == 'replace':\n                    result_bytes.append(ord('?'))\n                    i += 1\n                    continue\n                else:\n                    raise ValueError(f\"Unsupported error handler: {errors}\")\n\n            result_bytes.extend(encoded_bytes)\n            i += 1\n\n    # Validate that result_bytes is valid utf8?\n    # The docstring says we raise UnicodeEncodeError if the given text contains escaped utf8 hexadecimal \n    # that references invalid utf8 bytes.\n    # So we need to check that the assembled bytes are valid UTF-8.\n\n    try:\n        result_bytes.decode('utf8')\n    except UnicodeDecodeError as e:\n        # Raise UnicodeEncodeError here with similar info\n        raise UnicodeEncodeError(\n            \"raw_unicode_escape\", text, e.start, e.end,\n            \"invalid UTF-8 sequence after decoding escaped utf8 hex\"\n        ) from e\n\n    # Return the bytes and number of characters consumed (all)\n    return bytes(result_bytes), length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()"]}
{"task_id": 141, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["from typing import Tuple, Union, ByteString, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n    \"\"\"\n    # Convert 'errors' to str if it is UserString\n    errors_input = str(errors)\n\n    # Convert the input data (bytes/bytearray/memoryview) to bytes\n    raw_bytes = bytes(data)\n\n    # Step 1:\n    # Decode the bytes as latin-1 to get equivalent characters which map\n    # directly to 0-255 byte values. This is critical because the input bytes\n    # are escaped utf8 hex bytes, represented as ASCII characters.\n    try:\n        text_str_latin1 = raw_bytes.decode('latin1')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            \"eutf8h\",  # error codec name same as encode\n            raw_bytes,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Step 2:\n    # Apply unicode_escape decoding which interprets all escape sequences\n    # e.g. '\\xHH' sequences in the string will be converted into corresponding bytes.\n    # The result is a bytes object encoded in utf8 because original was escaped utf8 hex bytes.\n    try:\n        unescaped_bytes = codecs.decode(text_str_latin1, 'unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            \"eutf8h\",\n            raw_bytes,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Step 3:\n    # Now decode these bytes as utf-8 using the requested error handling.\n    try:\n        decoded_str = unescaped_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Convert decode error to encode error like in the encode function\n        # Actually here we keep UnicodeDecodeError since it's a decode operation.\n        raise UnicodeDecodeError(\n            \"eutf8h\",\n            raw_bytes,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Return the decoded string and length of input bytes consumed (all)\n    return decoded_str, len(raw_bytes)", "from typing import Tuple, Union, ByteString, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n    \"\"\"\n    errors_input = str(errors)\n\n    # Convert the input bytes to a UTF-8 string. This string will have escaped sequences like \\xHH literally.\n    try:\n        data_str_utf8 = data.decode('utf-8')\n    except UnicodeDecodeError as e:\n        # If input bytes can't be decoded to UTF-8, raise a UnicodeDecodeError\n        raise UnicodeDecodeError(\n            'eutf8h',\n            bytes(data),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now decode the unicode escape sequences (\\xHH) so that they become the corresponding bytes in a str\n    # Result is a str where bytes values (0-255) are represented as latin1 codepoints\n    try:\n        data_str_latin1 = data_str_utf8.encode('utf-8').decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            bytes(data),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now encode this string (that effectively holds bytes as latin1 codepoints) as latin1 to get original bytes\n    data_bytes = data_str_latin1.encode('latin1')\n\n    # Decode these bytes as UTF-8 with the requested error handler to get the final decoded string\n    try:\n        decoded_str = data_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            bytes(data),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return decoded_str, len(data)", "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert errors input to string in case it is UserString\n    errors_input = str(errors)\n\n    # Convert bytes input into a string decoding as utf-8.\n    try:\n        data_str = data.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise\n\n    # The data_str contains escaped utf8 hexadecimal (like \\xHH)\n    # Decode unicode escapes to bytes, which converts \\xHH into the byte\n    # Then decode from utf-8 to get the original string\n    try:\n        bytes_decoded = data_str.encode('latin1').decode('unicode_escape').encode('latin1')\n        decoded_str = bytes_decoded.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Raise a UnicodeDecodeError with proper message (no change needed)\n        raise\n\n    # Return the decoded string and the number of bytes consumed\n    return decoded_str, len(data)", "from typing import Tuple, Union\nfrom typing import ByteString as _ByteString\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n\n    errors_input = str(errors)\n\n    # Step 1: Convert data (bytes) to a string using UTF-8 decoding\n    # Because data is escaped UTF8 hexadecimal bytes, decode with UTF-8 first.\n    str_data = data.decode('utf-8')\n\n    # Step 2: From this string, decode unicode escapes (\\xHH sequences)\n    # This converts escaped hex sequences back to actual bytes represented as latin1 chars.\n    # Using 'unicode_escape' decoding on a str decodes \\x sequences.\n    try:\n        decoded_latin1 = str_data.encode('latin1').decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        # Raise UnicodeDecodeError explicitly in case of failure\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Step 3: We now have a string with latin1 characters representing UTF-8 bytes.\n    # Encode to bytes using latin1 to get the original UTF-8 bytes.\n    utf8_bytes = decoded_latin1.encode('latin1')\n\n    # Step 4: Decode these UTF-8 bytes to a string with the specified error handling.\n    try:\n        text = utf8_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Raise UnicodeDecodeError with proper context\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return text, len(data)", "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    errors_input = str(errors)\n\n    # Convert data from bytes to string, decoding as UTF-8.\n    data_str = data.decode('utf-8')\n\n    # Encode string as latin1 to map bytes exactly as latin1 codepoints.\n    data_bytes = data_str.encode('latin1')\n\n    # Decode bytes with unicode_escape to convert escaped hex sequences (e.g. \\xHH) into actual bytes.\n    try:\n        decoded_str = data_bytes.decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Finally decode the result as utf-8 using the given errors parameter.\n    try:\n        out_str = decoded_str.encode('latin1').decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return out_str, len(data)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import Tuple, Union, ByteString, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n    \"\"\"\n    # Convert 'errors' to str if it is UserString\n    errors_input = str(errors)\n\n    # Convert the input data (bytes/bytearray/memoryview) to bytes\n    raw_bytes = bytes(data)\n\n    # Step 1:\n    # Decode the bytes as latin-1 to get equivalent characters which map\n    # directly to 0-255 byte values. This is critical because the input bytes\n    # are escaped utf8 hex bytes, represented as ASCII characters.\n    try:\n        text_str_latin1 = raw_bytes.decode('latin1')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            \"eutf8h\",  # error codec name same as encode\n            raw_bytes,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Step 2:\n    # Apply unicode_escape decoding which interprets all escape sequences\n    # e.g. '\\xHH' sequences in the string will be converted into corresponding bytes.\n    # The result is a bytes object encoded in utf8 because original was escaped utf8 hex bytes.\n    try:\n        unescaped_bytes = codecs.decode(text_str_latin1, 'unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            \"eutf8h\",\n            raw_bytes,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Step 3:\n    # Now decode these bytes as utf-8 using the requested error handling.\n    try:\n        decoded_str = unescaped_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Convert decode error to encode error like in the encode function\n        # Actually here we keep UnicodeDecodeError since it's a decode operation.\n        raise UnicodeDecodeError(\n            \"eutf8h\",\n            raw_bytes,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Return the decoded string and length of input bytes consumed (all)\n    return decoded_str, len(raw_bytes)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import Tuple, Union, ByteString, cast\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n    \"\"\"\n    errors_input = str(errors)\n\n    # Convert the input bytes to a UTF-8 string. This string will have escaped sequences like \\xHH literally.\n    try:\n        data_str_utf8 = data.decode('utf-8')\n    except UnicodeDecodeError as e:\n        # If input bytes can't be decoded to UTF-8, raise a UnicodeDecodeError\n        raise UnicodeDecodeError(\n            'eutf8h',\n            bytes(data),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now decode the unicode escape sequences (\\xHH) so that they become the corresponding bytes in a str\n    # Result is a str where bytes values (0-255) are represented as latin1 codepoints\n    try:\n        data_str_latin1 = data_str_utf8.encode('utf-8').decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            bytes(data),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now encode this string (that effectively holds bytes as latin1 codepoints) as latin1 to get original bytes\n    data_bytes = data_str_latin1.encode('latin1')\n\n    # Decode these bytes as UTF-8 with the requested error handler to get the final decoded string\n    try:\n        decoded_str = data_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            bytes(data),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Convert errors input to string in case it is UserString\n    errors_input = str(errors)\n\n    # Convert bytes input into a string decoding as utf-8.\n    try:\n        data_str = data.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise\n\n    # The data_str contains escaped utf8 hexadecimal (like \\xHH)\n    # Decode unicode escapes to bytes, which converts \\xHH into the byte\n    # Then decode from utf-8 to get the original string\n    try:\n        bytes_decoded = data_str.encode('latin1').decode('unicode_escape').encode('latin1')\n        decoded_str = bytes_decoded.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Raise a UnicodeDecodeError with proper message (no change needed)\n        raise\n\n    # Return the decoded string and the number of bytes consumed\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nfrom typing import Tuple, Union\nfrom typing import ByteString as _ByteString\nfrom collections import UserString\n\n_Str = Union[str, UserString]\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n\n    errors_input = str(errors)\n\n    # Step 1: Convert data (bytes) to a string using UTF-8 decoding\n    # Because data is escaped UTF8 hexadecimal bytes, decode with UTF-8 first.\n    str_data = data.decode('utf-8')\n\n    # Step 2: From this string, decode unicode escapes (\\xHH sequences)\n    # This converts escaped hex sequences back to actual bytes represented as latin1 chars.\n    # Using 'unicode_escape' decoding on a str decodes \\x sequences.\n    try:\n        decoded_latin1 = str_data.encode('latin1').decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        # Raise UnicodeDecodeError explicitly in case of failure\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Step 3: We now have a string with latin1 characters representing UTF-8 bytes.\n    # Encode to bytes using latin1 to get the original UTF-8 bytes.\n    utf8_bytes = decoded_latin1.encode('latin1')\n\n    # Step 4: Decode these UTF-8 bytes to a string with the specified error handling.\n    try:\n        text = utf8_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Raise UnicodeDecodeError with proper context\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return text, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    errors_input = str(errors)\n\n    # Convert data from bytes to string, decoding as UTF-8.\n    data_str = data.decode('utf-8')\n\n    # Encode string as latin1 to map bytes exactly as latin1 codepoints.\n    data_bytes = data_str.encode('latin1')\n\n    # Decode bytes with unicode_escape to convert escaped hex sequences (e.g. \\xHH) into actual bytes.\n    try:\n        decoded_str = data_bytes.decode('unicode_escape')\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Finally decode the result as utf-8 using the given errors parameter.\n    try:\n        out_str = decoded_str.encode('latin1').decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data,\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    return out_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()"]}
{"task_id": 142, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)", "from typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    return any(hasattr(obj, attr) for attr in attrs)\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n"]}
{"task_id": 143, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) and callable(getattr(obj, attr)):\n            return True\n    return False", "from typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        attr_value = getattr(obj, attr, None)\n        if callable(attr_value):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            val = getattr(obj, attr)\n            if callable(val):\n                return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            val = getattr(obj, attr)\n            if callable(val):\n                return True\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            if callable(getattr(obj, attr)):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) and callable(getattr(obj, attr)):\n            return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        attr_value = getattr(obj, attr, None)\n        if callable(attr_value):\n            return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            val = getattr(obj, attr)\n            if callable(val):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            val = getattr(obj, attr)\n            if callable(val):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n"]}
{"task_id": 144, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from collections.abc import Iterator, KeysView, ValuesView\nfrom collections import UserList, deque, frozenset, list, set, tuple\n\ndef is_list_like(\n        obj: object\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like;\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    \n    # Using the predefined tuple of acceptable list-like types\n    # The _LIST_LIKE tuple is available in file content but we are not to import it from there\n    # So we redefine a similar tuple here for usage\n    \n    # Import is_subclass_of_any helper from context\n    from flutils.objutils import is_subclass_of_any\n    \n    _LIST_LIKE = (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        ValuesView,\n        KeysView,\n        UserList\n    )\n    \n    # Explicitly exclude types that are not list-like\n    # Checking common non list-like types here as per docstring\n    _not_list_like_types = (\n        type(None),\n        bool,\n        bytes,\n        # collections types that are not list-like\n        # these are imports like ChainMap, Counter, OrderedDict, UserDict, UserString, defaultdict\n        # Decimal from decimal module,\n        # dict, float, int, str\n    )\n    \n    # For the non-list-like collections, import them precisely\n    from collections import ChainMap, Counter, OrderedDict, UserDict, UserString, defaultdict\n    from decimal import Decimal\n    \n    _not_list_like_types += (\n        ChainMap,\n        Counter,\n        OrderedDict,\n        UserDict,\n        UserString,\n        defaultdict,\n        Decimal,\n        dict,\n        float,\n        int,\n        str,\n    )\n    \n    # If the obj is instance of any of _not_list_like_types, return False immediately\n    if isinstance(obj, _not_list_like_types):\n        return False\n    \n    # Otherwise check if obj's class is subclass of any of the list-like classes\n    return is_subclass_of_any(obj, *_LIST_LIKE)", "from typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Exclude None explicitly\n    if obj is None:\n        return False\n\n    # Exclude explicitly these non-list-like types:\n    # bool, bytes, str, dict, float, int\n    # (Their checking by type avoids issues in isinstance that can be subclasses)\n    if isinstance(obj, (bool, bytes, str, dict, float, int)):\n        return False\n\n    return is_subclass_of_any(\n        obj,\n        UserList,\n        Iterator,\n        KeysView,\n        ValuesView,\n        deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )", "from typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Immediate exclusion of explicit non-list-like types:\n    # None, bool, bytes, str, float, int and dict-like types should return False.\n    if obj is None:\n        return False\n\n    # Exclude explicit types known not to be list-like\n    if isinstance(obj, (bool, bytes, str, float, int, dict)):\n        return False\n\n    # Use is_subclass_of_any to check inclusion in list-like classes\n    list_like_classes = (\n        UserList,\n        Iterator,\n        KeysView,\n        ValuesView,\n        deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    if is_subclass_of_any(obj, *list_like_classes):\n        return True\n\n    # Additionally, check if iterable (excluding strings and bytes handled above)\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    # If it passed iteration, but isn't known list_like class, could disallow some types:\n    # To respect docstring exclusions, double check it's not dict-like or other excluded types\n    # Already excluded dict and known types above, so safe to accept iterable now\n    return True", "from typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Reject None explicitly\n    if obj is None:\n        return False\n\n    # Reject explicit non-list-like types\n    if isinstance(obj, (bool, bytes, str, dict, float, int)):\n        return False\n\n    # Check if obj is instance of any list-like classes\n    if is_subclass_of_any(\n            obj,\n            UserList,\n            Iterator,\n            KeysView,\n            ValuesView,\n            deque,\n            frozenset,\n            list,\n            set,\n            tuple,\n    ):\n        return True\n\n    # Additionally, check if obj is iterable and not one of the rejected types above.\n    # But since the docstring examples show that sorted('hello') (which returns a list)\n    # returns True, and 'hello' (str) returns False,\n    # Any object that behaves like a list-like instance should be one of the above\n    # or at least iterable but not a str/bytes/bool etc.\n\n    # Check for iterable protocol to catch some edge cases:\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    # Reject strings, bytes, bool again just in case (to cover subclasses too)\n    if isinstance(obj, (str, bytes, bool)):\n        return False\n\n    # Since obj is iterable and passed above checks, treat it as list-like\n    return True", "from typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # First rule out None explicitly\n    if obj is None:\n        return False\n\n    # Exclude bool explicitly (since bool is subclass of int)\n    if isinstance(obj, bool):\n        return False\n\n    # The accepted list-like classes\n    accepted_classes = (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        ValuesView,\n        KeysView,\n        UserList,\n    )\n\n    return is_subclass_of_any(obj, *accepted_classes)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections.abc import Iterator, KeysView, ValuesView\nfrom collections import UserList, deque, frozenset, list, set, tuple\n\ndef is_list_like(\n        obj: object\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like;\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    \n    # Using the predefined tuple of acceptable list-like types\n    # The _LIST_LIKE tuple is available in file content but we are not to import it from there\n    # So we redefine a similar tuple here for usage\n    \n    # Import is_subclass_of_any helper from context\n    from flutils.objutils import is_subclass_of_any\n    \n    _LIST_LIKE = (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        ValuesView,\n        KeysView,\n        UserList\n    )\n    \n    # Explicitly exclude types that are not list-like\n    # Checking common non list-like types here as per docstring\n    _not_list_like_types = (\n        type(None),\n        bool,\n        bytes,\n        # collections types that are not list-like\n        # these are imports like ChainMap, Counter, OrderedDict, UserDict, UserString, defaultdict\n        # Decimal from decimal module,\n        # dict, float, int, str\n    )\n    \n    # For the non-list-like collections, import them precisely\n    from collections import ChainMap, Counter, OrderedDict, UserDict, UserString, defaultdict\n    from decimal import Decimal\n    \n    _not_list_like_types += (\n        ChainMap,\n        Counter,\n        OrderedDict,\n        UserDict,\n        UserString,\n        defaultdict,\n        Decimal,\n        dict,\n        float,\n        int,\n        str,\n    )\n    \n    # If the obj is instance of any of _not_list_like_types, return False immediately\n    if isinstance(obj, _not_list_like_types):\n        return False\n    \n    # Otherwise check if obj's class is subclass of any of the list-like classes\n    return is_subclass_of_any(obj, *_LIST_LIKE)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Exclude None explicitly\n    if obj is None:\n        return False\n\n    # Exclude explicitly these non-list-like types:\n    # bool, bytes, str, dict, float, int\n    # (Their checking by type avoids issues in isinstance that can be subclasses)\n    if isinstance(obj, (bool, bytes, str, dict, float, int)):\n        return False\n\n    return is_subclass_of_any(\n        obj,\n        UserList,\n        Iterator,\n        KeysView,\n        ValuesView,\n        deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Immediate exclusion of explicit non-list-like types:\n    # None, bool, bytes, str, float, int and dict-like types should return False.\n    if obj is None:\n        return False\n\n    # Exclude explicit types known not to be list-like\n    if isinstance(obj, (bool, bytes, str, float, int, dict)):\n        return False\n\n    # Use is_subclass_of_any to check inclusion in list-like classes\n    list_like_classes = (\n        UserList,\n        Iterator,\n        KeysView,\n        ValuesView,\n        deque,\n        frozenset,\n        list,\n        set,\n        tuple,\n    )\n\n    if is_subclass_of_any(obj, *list_like_classes):\n        return True\n\n    # Additionally, check if iterable (excluding strings and bytes handled above)\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    # If it passed iteration, but isn't known list_like class, could disallow some types:\n    # To respect docstring exclusions, double check it's not dict-like or other excluded types\n    # Already excluded dict and known types above, so safe to accept iterable now\n    return True\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Reject None explicitly\n    if obj is None:\n        return False\n\n    # Reject explicit non-list-like types\n    if isinstance(obj, (bool, bytes, str, dict, float, int)):\n        return False\n\n    # Check if obj is instance of any list-like classes\n    if is_subclass_of_any(\n            obj,\n            UserList,\n            Iterator,\n            KeysView,\n            ValuesView,\n            deque,\n            frozenset,\n            list,\n            set,\n            tuple,\n    ):\n        return True\n\n    # Additionally, check if obj is iterable and not one of the rejected types above.\n    # But since the docstring examples show that sorted('hello') (which returns a list)\n    # returns True, and 'hello' (str) returns False,\n    # Any object that behaves like a list-like instance should be one of the above\n    # or at least iterable but not a str/bytes/bool etc.\n\n    # Check for iterable protocol to catch some edge cases:\n    try:\n        iter(obj)\n    except TypeError:\n        return False\n\n    # Reject strings, bytes, bool again just in case (to cover subclasses too)\n    if isinstance(obj, (str, bytes, bool)):\n        return False\n\n    # Since obj is iterable and passed above checks, treat it as list-like\n    return True\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom typing import Any as _Any\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom flutils.objutils import is_subclass_of_any\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # First rule out None explicitly\n    if obj is None:\n        return False\n\n    # Exclude bool explicitly (since bool is subclass of int)\n    if isinstance(obj, bool):\n        return False\n\n    # The accepted list-like classes\n    accepted_classes = (\n        list,\n        set,\n        frozenset,\n        tuple,\n        deque,\n        Iterator,\n        ValuesView,\n        KeysView,\n        UserList,\n    )\n\n    return is_subclass_of_any(obj, *accepted_classes)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n"]}
{"task_id": 145, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(), ValuesView, KeysView, UserList)\n        True\n    \"\"\"\n    cls = obj if isinstance(obj, type) else getattr(obj, '__class__', None)\n    if cls is None:\n        return False\n    for class_ in classes:\n        # Catch TypeError if class_ is not a class type\n        try:\n            if issubclass(cls, class_):\n                return True\n        except TypeError:\n            continue\n    return False", "from typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        return isinstance(obj, classes)\n    except TypeError:\n        # If classes argument(s) contain non-class items, or obj is a class\n        # we try issubclass if obj is a class\n        if isinstance(obj, type):\n            for cls in classes:\n                try:\n                    if issubclass(obj, cls):\n                        return True\n                except TypeError:\n                    # cls is not a class\n                    continue\n        return False", "from typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    try:\n        # If obj is a class itself\n        if isinstance(obj, type):\n            for cls in classes:\n                if isinstance(cls, type) and issubclass(obj, cls):\n                    return True\n            return False\n        else:\n            # obj is an instance, check if its class is subclass of any provided classes\n            obj_cls = obj.__class__\n            for cls in classes:\n                if isinstance(cls, type) and issubclass(obj_cls, cls):\n                    return True\n            return False\n    except TypeError:\n        # In case issubclass or isinstance is called with non-class arguments\n        return False", "from typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # We check if obj is an instance of ANY of the provided classes.\n    for cls in classes:\n        try:\n            if isinstance(obj, cls):\n                return True\n        except TypeError:\n            # In case cls is not a valid type for isinstance (unlikely, but safe)\n            continue\n    return False", "from typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # Defensive check: If no classes are provided, return False immediately\n    if not classes:\n        return False\n\n    # Try to get the type (class) of the object\n    obj_type = type(obj)\n\n    # Check if obj (which may itself be a class) is subclass of any class in classes\n    # If obj is a class, we can use issubclass directly\n    try:\n        if isinstance(obj, type):\n            for cls in classes:\n                # Defensive: cls must be a class type for issubclass to work\n                if isinstance(cls, type) and issubclass(obj, cls):\n                    return True\n            return False\n    except TypeError:\n        # obj is not a class, fallback to instance check below\n        pass\n\n    # Otherwise, check if obj is instance of any of the given classes\n    for cls in classes:\n        try:\n            if isinstance(obj, cls):\n                return True\n        except TypeError:\n            # If cls is not a valid class/type, skip it\n            continue\n\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(), ValuesView, KeysView, UserList)\n        True\n    \"\"\"\n    cls = obj if isinstance(obj, type) else getattr(obj, '__class__', None)\n    if cls is None:\n        return False\n    for class_ in classes:\n        # Catch TypeError if class_ is not a class type\n        try:\n            if issubclass(cls, class_):\n                return True\n        except TypeError:\n            continue\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    try:\n        return isinstance(obj, classes)\n    except TypeError:\n        # If classes argument(s) contain non-class items, or obj is a class\n        # we try issubclass if obj is a class\n        if isinstance(obj, type):\n            for cls in classes:\n                try:\n                    if issubclass(obj, cls):\n                        return True\n                except TypeError:\n                    # cls is not a class\n                    continue\n        return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    try:\n        # If obj is a class itself\n        if isinstance(obj, type):\n            for cls in classes:\n                if isinstance(cls, type) and issubclass(obj, cls):\n                    return True\n            return False\n        else:\n            # obj is an instance, check if its class is subclass of any provided classes\n            obj_cls = obj.__class__\n            for cls in classes:\n                if isinstance(cls, type) and issubclass(obj_cls, cls):\n                    return True\n            return False\n    except TypeError:\n        # In case issubclass or isinstance is called with non-class arguments\n        return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # We check if obj is an instance of ANY of the provided classes.\n    for cls in classes:\n        try:\n            if isinstance(obj, cls):\n                return True\n        except TypeError:\n            # In case cls is not a valid type for isinstance (unlikely, but safe)\n            continue\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # Defensive check: If no classes are provided, return False immediately\n    if not classes:\n        return False\n\n    # Try to get the type (class) of the object\n    obj_type = type(obj)\n\n    # Check if obj (which may itself be a class) is subclass of any class in classes\n    # If obj is a class, we can use issubclass directly\n    try:\n        if isinstance(obj, type):\n            for cls in classes:\n                # Defensive: cls must be a class type for issubclass to work\n                if isinstance(cls, type) and issubclass(obj, cls):\n                    return True\n            return False\n    except TypeError:\n        # obj is not a class, fallback to instance check below\n        pass\n\n    # Otherwise, check if obj is instance of any of the given classes\n    for cls in classes:\n        try:\n            if isinstance(obj, cls):\n                return True\n        except TypeError:\n            # If cls is not a valid class/type, skip it\n            continue\n\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n"]}
