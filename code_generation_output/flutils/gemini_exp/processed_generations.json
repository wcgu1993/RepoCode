{"task_id": 125, "project": "test-apps/flutils", "module": "flutils.packages", "predictions": ["def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # 1. Validate 'position' and get normalized positive index\n    pos = _build_version_bump_position(position)\n\n    # 2. Determine the specific bump type (e.g., major, minor-alpha)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # 3. Parse the input version string into a structured object\n    # This will raise ValueError if 'version' is invalid\n    ver_info = _build_version_info(version)\n\n    # Create a mutable representation of the version parts for modification\n    # _VersionPart has pos, txt, num, pre_txt, pre_num, name\n    # We will only modify num, pre_txt, pre_num\n    current_parts: List[Dict[str, Any]] = [\n        {'pos': p.pos, 'num': p.num, 'pre_txt': p.pre_txt, 'pre_num': p.pre_num}\n        for p in [ver_info.major, ver_info.minor, ver_info.patch]\n    ]\n\n    # Get the target part that will be affected by the bump\n    target_part = current_parts[pos]\n\n    # --- Core Logic: Apply the bump based on bump_type ---\n\n    # Case 1: No pre-release specified in bump_version call (pre_release is None or empty string)\n    if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_PATCH):\n        should_increment_num = True\n\n        # If an existing pre-release is being removed due to no pre_release arg being given\n        if ver_info.pre_pos != -1:\n            # Clear all pre-release information from the original version components.\n            # This handles cases like '1.2.4a1' -> '1.2.4' AND '1.2b0' -> '1.2.1'\n            for part_data in current_parts:\n                part_data['pre_txt'] = ''\n                part_data['pre_num'] = -1\n\n            # If the current bump position is the same as where the pre-release was,\n            # then we only remove the pre-release and do NOT increment the number.\n            if ver_info.pre_pos == pos:\n                should_increment_num = False\n            # If the pre-release was on an earlier part (e.g., 1.2b0, bumping patch),\n            # we *do* increment the number of the targeted part.\n            # 'should_increment_num' remains True.\n\n        if should_increment_num:\n            target_part['num'] += 1\n\n        # Zero out subsequent parts' numbers and clear their pre-releases\n        for i in range(pos + 1, 3):\n            current_parts[i]['num'] = 0\n            current_parts[i]['pre_txt'] = ''\n            current_parts[i]['pre_num'] = -1\n\n    # Case 2: Pre-release specified (bump_type indicates alpha/beta)\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n                        _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        new_pre_txt = 'a' if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA) else 'b'\n\n        # If the target part already has a pre-release of the *same* type, increment pre_num.\n        if target_part['pre_txt'] == new_pre_txt:\n            target_part['pre_num'] += 1\n        else:\n            # If target part has no pre-release, or a different pre-release type,\n            # increment the main number and set new pre-release to 0.\n            # If switching pre-release types (e.g., a to b), the main number is NOT incremented.\n            # (e.g., '1.2.4a1' -> '1.2.4b0')\n            if target_part['pre_txt'] == '':\n                target_part['num'] += 1\n\n            target_part['pre_txt'] = new_pre_txt\n            target_part['pre_num'] = 0\n\n        # Zero out subsequent parts' numbers and clear their pre-releases\n        for i in range(pos + 1, 3):\n            current_parts[i]['num'] = 0\n            current_parts[i]['pre_txt'] = ''\n            current_parts[i]['pre_num'] = -1\n    else:\n        # This case should ideally not be reached if _build_version_bump_type is exhaustive\n        raise RuntimeError(f\"Internal error: Unknown bump type '{bump_type}'\")\n\n    # --- Reconstruct the new version string ---\n    reconstructed_version_texts: List[str] = []\n    for i, part_data in enumerate(current_parts):\n        txt_segment = str(part_data['num'])\n        \n        # Apply special handling for patch=0 (like _each_version_part does)\n        # If it's the patch part (pos 2), its number is 0, and has no pre-release,\n        # then its string representation should be empty.\n        if i == 2 and part_data['num'] == 0 and part_data['pre_txt'] == '':\n            txt_segment = ''\n\n        # Append pre-release if it exists for this part\n        if part_data['pre_txt']:\n            txt_segment += part_data['pre_txt'] + str(part_data['pre_num'])\n        \n        reconstructed_version_texts.append(txt_segment)\n\n    # Remove trailing empty segments (e.g., '1', '2', '' -> '1.2')\n    while reconstructed_version_texts and reconstructed_version_texts[-1] == '':\n        reconstructed_version_texts.pop()\n\n    # Join the segments with dots to form the final version string\n    return \".\".join(reconstructed_version_texts)", "from typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n# The following constants and NamedTuples are available from the file content:\n# _BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_PATCH\n# _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA\n# _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA\n# _VersionPart, _VersionInfo\n\n# The following context functions are available from the file content:\n# _build_version_bump_position\n# _build_version_bump_type\n# _build_version_info\n# _each_version_part\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # 1. Validate and normalize the 'position' argument.\n    # This function ensures 'position' is a valid 0, 1, or 2 (for major, minor, patch).\n    pos_positive = _build_version_bump_position(position)\n\n    # 2. Parse the input 'version' string into a structured object.\n    # This step uses StrictVersion internally and will raise ValueError if 'version' is invalid.\n    version_info = _build_version_info(version)\n\n    # 3. Determine the specific type of bump (e.g., major, minor, patch, minor-alpha, etc.).\n    # This function also validates the 'pre_release' argument and raises ValueError for invalid combinations.\n    bump_type = _build_version_bump_type(pos_positive, pre_release)\n\n    # Initialize a mutable list of version numbers [major, minor, patch] from the parsed version.\n    # These are the base numeric parts of the version string.\n    nums = [version_info.major.num, version_info.minor.num, version_info.patch.num]\n\n    # Initialize variables for the new pre-release components.\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    # Check if the existing version has a pre-release specifically on the target position.\n    has_current_pre_on_target_pos = (version_info.pre_pos == pos_positive)\n    current_target_pre_txt = ''\n    current_target_pre_num = -1\n\n    # If there's an existing pre-release at the target position, extract its details.\n    if has_current_pre_on_target_pos:\n        if pos_positive == _BUMP_VERSION_MINOR:\n            current_target_pre_txt = version_info.minor.pre_txt\n            current_target_pre_num = version_info.minor.pre_num\n        elif pos_positive == _BUMP_VERSION_PATCH:\n            current_target_pre_txt = version_info.patch.pre_txt\n            current_target_pre_num = version_info.patch.pre_num\n\n    # --- Apply the bumping logic based on whether 'pre_release' was specified and the 'bump_type' ---\n\n    # Scenario 1: 'pre_release' is None.\n    # This implies either removing an existing pre-release or performing a standard major/minor/patch bump.\n    if pre_release is None:\n        # If there's an existing pre-release AND the 'position' is the default (patch, 2),\n        # this is the special case where the intent is ONLY to remove the pre-release.\n        # Example: `bump_version('1.2.4a1')` -> `'1.2.4'`\n        if version_info.pre_pos != -1 and position == _BUMP_VERSION_PATCH:\n            # The base `nums` (major, minor, patch) are already correct for the post-pre-release state.\n            # `new_pre_txt` and `new_pre_num` remain their initialized empty/negative values,\n            # effectively removing any pre-release during string construction. No increment to base needed.\n            pass\n        else:\n            # This handles:\n            #   - Standard major/minor/patch bumps (e.g., `1.2.2` -> `1.2.3`, `1.2.3` (pos=1) -> `1.3`).\n            #   - Removing an existing pre-release *followed by* a specific bump\n            #     (e.g., `1.2b0` (pos=2) -> `1.2.1`).\n            # In these cases, increment the numeric part at 'pos_positive' and reset subsequent parts to 0.\n            nums[pos_positive] += 1\n            for i in range(pos_positive + 1, 3):  # Reset subsequent parts (minor/patch) to 0\n                nums[i] = 0\n            # `new_pre_txt` and `new_pre_num` remain empty/negative, as no pre-release is desired.\n\n    # Scenario 2: 'pre_release' is not None.\n    # This implies creating a new pre-release or incrementing an existing one.\n    else:\n        # Set the 'new_pre_txt' (e.g., 'a' or 'b') based on the determined 'bump_type'.\n        if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA):\n            new_pre_txt = 'a'\n        elif bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA):\n            new_pre_txt = 'b'\n\n        # If a pre-release currently exists at the target position AND its type matches the new type:\n        if has_current_pre_on_target_pos and current_target_pre_txt == new_pre_txt:\n            # Example: `bump_version('1.2.4a0', pre_release='a')` -> `'1.2.4a1'`\n            # Increment only the pre-release number; the base numbers remain unchanged.\n            new_pre_num = current_target_pre_num + 1\n        else:\n            # This handles cases where:\n            #   - No pre-release existed for this part (e.g., `1.2.3` -> `1.2.4a0`).\n            #   - A pre-release existed, but its type is changing (e.g., `1.2.4a1` -> `1.2.4b0`).\n            #   - A pre-release existed on a different part.\n            # In these cases, increment the base number at 'pos_positive', reset subsequent parts to 0,\n            # and start the new pre-release number at 0.\n            nums[pos_positive] += 1\n            for i in range(pos_positive + 1, 3):\n                nums[i] = 0\n            new_pre_num = 0\n\n    # --- Construct the final version string ---\n    # Build the base version string (e.g., \"1.2.3\") from the calculated numbers.\n    version_parts = [str(nums[0]), str(nums[1]), str(nums[2])]\n    version_str_base = \".\".join(version_parts)\n\n    # Append the pre-release part if it's defined.\n    if new_pre_txt:\n        version_str_base += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Use StrictVersion to parse the constructed string and then convert it back to a string.\n    # This ensures the output is in the canonical normalized format (e.g., '1.2.0' becomes '1.2').\n    try:\n        return str(StrictVersion(version_str_base))\n    except ValueError as e:\n        # This is a safeguard; ideally, our logic should produce a valid version string.\n        raise ValueError(\n            f\"Failed to generate a valid version string: '{version_str_base}'. Error: {e}\"\n        ) from e", "import distutils.version\nfrom typing import Optional, cast\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # 1. Validate and normalize position. This will raise ValueError if invalid.\n    pos_positive = _build_version_bump_position(position)\n\n    # 2. Determine the bump type. This will also raise ValueError for invalid pre_release or major pre-release bump.\n    bump_type = _build_version_bump_type(pos_positive, pre_release)\n\n    # 3. Parse the version string into structured info. This will raise ValueError if version is invalid.\n    info = _build_version_info(version)\n\n    # 4. Initialize new version parts based on current version\n    new_major_num = info.major.num\n    new_minor_num = info.minor.num\n    new_patch_num = info.patch.num\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    if pre_release is None:\n        # Case A: No pre_release specified. Either a core bump or removing an existing pre_release.\n        if info.pre_pos == pos_positive:\n            # If a pre-release existed at the target position, remove it.\n            # The core version numbers remain as they are, effectively \"finalizing\" it.\n            pass\n        else:\n            # No pre-release at target position, perform a standard core bump.\n            if bump_type == _BUMP_VERSION_MAJOR:\n                new_major_num += 1\n                new_minor_num = 0\n                new_patch_num = 0\n            elif bump_type == _BUMP_VERSION_MINOR:\n                new_minor_num += 1\n                new_patch_num = 0\n            elif bump_type == _BUMP_VERSION_PATCH:\n                new_patch_num += 1\n    else:\n        # Case B: pre_release is specified. Perform a pre-release bump.\n        canonical_pre_txt = pre_release.strip().lower()[0] # 'a' or 'b'\n\n        if info.pre_pos == pos_positive:\n            # A pre-release already exists at this position.\n            current_part = info.minor if pos_positive == _BUMP_VERSION_MINOR else info.patch\n            if current_part.pre_txt == canonical_pre_txt:\n                # Same pre-release type (e.g., 'a' to 'a'), increment the pre-release number.\n                new_pre_txt = current_part.pre_txt\n                new_pre_num = current_part.pre_num + 1\n            else:\n                # Different pre-release type (e.g., 'a' to 'b'), reset pre-release number to 0.\n                new_pre_txt = canonical_pre_txt\n                new_pre_num = 0\n            # Core parts (major, minor, patch) remain unchanged in this specific scenario.\n        else:\n            # No pre-release at this position, create a new one.\n            if bump_type in _BUMP_VERSION_MINORS: # Minor pre-release bump\n                new_minor_num += 1\n                new_patch_num = 0\n            elif bump_type in _BUMP_VERSION_PATCHES: # Patch pre-release bump\n                new_patch_num += 1\n\n            new_pre_txt = canonical_pre_txt\n            new_pre_num = 0\n\n    # 5. Assemble the new version string and use StrictVersion for proper formatting.\n    new_version_str = f\"{new_major_num}.{new_minor_num}.{new_patch_num}\"\n    if new_pre_txt and new_pre_num != -1:\n        new_version_str += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Use StrictVersion to handle implicit trailing zero removal (e.g., 1.2.0 -> 1.2)\n    return str(distutils.version.StrictVersion(new_version_str))", "from typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n# The following constants and helper functions are provided in the file content\n# and are thus available in the scope of the `bump_version` function:\n# _BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_PATCH,\n# _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n# _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA,\n# _BUMP_VERSION_POSITION_NAMES, _VersionPart, _VersionInfo,\n# _each_version_part, _build_version_info, _build_version_bump_position,\n# _build_version_bump_type.\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Step 1: Parse the input version string into a structured _VersionInfo object.\n    # This call implicitly handles ValueError for invalid version strings.\n    version_info = _build_version_info(version)\n\n    # Step 2: Validate and normalize the 'position' argument into a positive index (0, 1, or 2).\n    # This call implicitly handles ValueError for invalid position values.\n    pos_positive = _build_version_bump_position(position)\n\n    # Step 3: Determine the effective pre_release string and if it implies a pre-release operation.\n    effective_pre_release = pre_release.strip().lower() if pre_release else ''\n    is_prerelease_op = effective_pre_release in ('a', 'alpha', 'b', 'beta')\n\n    # Determine the single character for the target pre-release type ('a' or 'b')\n    target_prerelease_char = ''\n    if effective_pre_release in ('a', 'alpha'):\n        target_prerelease_char = 'a'\n    elif effective_pre_release in ('b', 'beta'):\n        target_prerelease_char = 'b'\n\n    # Explicitly check for invalid pre_release values not handled by _build_version_bump_type\n    # (The _build_version_bump_type will raise ValueError if prerelease is invalid,\n    # but the docstring implies handling for None, which is not an error here)\n    if pre_release is not None and not is_prerelease_op and effective_pre_release != '':\n        raise ValueError(\n            \"The given value for 'pre_release', %r, can only be one of: \"\n            \"'a', 'alpha', 'b', 'beta', None.\" % pre_release\n        )\n\n    # Validate that pre-release bumps cannot be applied to the 'major' part (position 0).\n    # This check is also performed by _build_version_bump_type, but having it here\n    # ensures consistent error messaging if we were to deviate.\n    if is_prerelease_op and pos_positive == 0:\n        raise ValueError(\n            \"Only the 'minor' or 'patch' parts of the version number \"\n            \"can get a prerelease bump.\"\n        )\n\n    # Initialize the new version parts with the current numerical values from the input version.\n    res_major = version_info.major.num\n    res_minor = version_info.minor.num\n    res_patch = version_info.patch.num\n    res_pre_txt = ''  # New pre-release text (e.g., 'a' or 'b')\n    res_pre_num = -1  # New pre-release number (e.g., 0, 1, 2)\n\n    # Get the current pre-release details if one exists at the target position.\n    current_pre_txt_at_pos = ''\n    current_pre_num_at_pos = -1\n    if version_info.pre_pos != -1 and version_info.pre_pos == pos_positive:\n        if pos_positive == 1:  # Pre-release is on the minor part\n            current_pre_txt_at_pos = version_info.minor.pre_txt\n            current_pre_num_at_pos = version_info.minor.pre_num\n        elif pos_positive == 2:  # Pre-release is on the patch part\n            current_pre_txt_at_pos = version_info.patch.pre_txt\n            current_pre_num_at_pos = version_info.patch.pre_num\n\n    # Step 4: Apply the bumping logic based on whether a pre-release is requested.\n    if is_prerelease_op:\n        # User explicitly requested to add or increment a pre-release.\n        if pos_positive == version_info.pre_pos:\n            # The target position already has an existing pre-release.\n            if target_prerelease_char == current_pre_txt_at_pos:\n                # Same pre-release type: Increment the pre-release number.\n                # Base numbers (major, minor, patch) remain unchanged.\n                res_pre_txt = target_prerelease_char\n                res_pre_num = current_pre_num_at_pos + 1\n            else:\n                # Different pre-release type (e.g., 'a' to 'b'): Reset pre-release number to 0.\n                # Base numbers (major, minor, patch) also remain unchanged.\n                # Example: '1.2.4a1' -> '1.2.4b0'\n                res_pre_txt = target_prerelease_char\n                res_pre_num = 0\n        else:\n            # The target position does NOT have an existing pre-release, or it's at a different position.\n            # This implies creating a NEW pre-release series on the target part,\n            # after incrementing that part (and resetting subsequent parts).\n            if pos_positive == 1:  # Target is minor\n                res_minor += 1\n                res_patch = 0  # Reset patch when minor is bumped\n            elif pos_positive == 2:  # Target is patch\n                # If original patch was 0 and hidden (e.g. '1.2' is '1.2.0'), it remains 0.\n                # Otherwise, it increments. Example: '1.2' -> '1.2.0a0', '1.2.3' -> '1.2.4a0'.\n                if version_info.patch.txt == '':\n                    res_patch = 0\n                else:\n                    res_patch += 1\n            res_pre_txt = target_prerelease_char\n            res_pre_num = 0\n    else:\n        # User did not request a pre-release (pre_release is None or empty string).\n        # This implies either stripping an existing pre-release or a standard bump.\n        if version_info.pre_pos != -1 and pos_positive == version_info.pre_pos:\n            # If an existing pre-release is found at the target position and no\n            # new pre-release is specified, simply remove the pre-release.\n            # Base numbers (major, minor, patch) remain unchanged.\n            # Example: '1.2.4a1' -> '1.2.4'\n            pass  # res_major, res_minor, res_patch already hold original values\n        else:\n            # Standard major/minor/patch bump without any pre-release involvement.\n            # Any existing pre-release not at the 'pos_positive' will be removed.\n            # Example: '1.2b0' with position=2 -> '1.2.1'\n            if pos_positive == 0:  # Target is major\n                res_major += 1\n                res_minor = 0  # Reset minor and patch\n                res_patch = 0\n            elif pos_positive == 1:  # Target is minor\n                res_minor += 1\n                res_patch = 0  # Reset patch\n            elif pos_positive == 2:  # Target is patch\n                res_patch += 1\n\n    # Step 5: Construct the new version string from the calculated parts.\n    version_parts_str: List[str] = [str(res_major), str(res_minor)]\n\n    # Include the patch part in the string if it's non-zero, OR if a pre-release is being added.\n    # A pre-release forces the patch part to be explicitly '0' if it was implicitly so (e.g., '1.2' -> '1.2.0a0').\n    if res_patch != 0 or res_pre_txt != '':\n        version_parts_str.append(str(res_patch))\n\n    new_version_str = \".\".join(version_parts_str)\n\n    # Append the pre-release string and number if applicable.\n    if res_pre_txt != '':\n        new_version_str += f\"{res_pre_txt}{res_pre_num}\"\n\n    return new_version_str", "from typing import Optional, List\n\n# The following constants and helper functions are defined in the file context\n# and are implicitly available, so no explicit import is needed within the function:\n# _BUMP_VERSION_MAJOR\n# _BUMP_VERSION_MINOR\n# _BUMP_VERSION_PATCH\n# _BUMP_VERSION_MINORS\n# _BUMP_VERSION_PATCHES\n# _build_version_info\n# _build_version_bump_position\n# _build_version_bump_type\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    pos_norm = _build_version_bump_position(position)\n    vinfo = _build_version_info(version)\n\n    new_major_num = vinfo.major.num\n    new_minor_num = vinfo.minor.num\n    new_patch_num = vinfo.patch.num\n\n    # Get current pre-release info for comparison\n    current_pre_txt = ''\n    current_pre_num = -1\n    current_pre_pos = -1\n\n    if vinfo.pre_pos != -1:\n        if vinfo.pre_pos == _BUMP_VERSION_MINOR:\n            current_pre_txt = vinfo.minor.pre_txt\n            current_pre_num = vinfo.minor.pre_num\n            current_pre_pos = _BUMP_VERSION_MINOR\n        elif vinfo.pre_pos == _BUMP_VERSION_PATCH:\n            current_pre_txt = vinfo.patch.pre_txt\n            current_pre_num = vinfo.patch.pre_num\n            current_pre_pos = _BUMP_VERSION_PATCH\n\n    final_pre_txt = ''\n    final_pre_num = -1\n\n    if pre_release is None:\n        # Scenario: No pre-release requested (remove existing or simple bump)\n        # Apply standard increment to the selected position and reset subsequent parts.\n        # If there was an existing pre-release, it's now dropped.\n        if pos_norm == _BUMP_VERSION_MAJOR:\n            new_major_num += 1\n            new_minor_num = 0\n            new_patch_num = 0\n        elif pos_norm == _BUMP_VERSION_MINOR:\n            new_minor_num += 1\n            new_patch_num = 0\n        elif pos_norm == _BUMP_VERSION_PATCH:\n            new_patch_num += 1\n        # final_pre_txt and final_pre_num remain default, effectively removing pre-release.\n    else:\n        # Scenario: Pre-release requested (add new or increment/switch existing)\n        # Validate pre_release string and position first (will raise ValueError if invalid).\n        _build_version_bump_type(pos_norm, pre_release)\n        target_pre_char = 'a' if pre_release.strip().lower() in ('a', 'alpha') else 'b'\n\n        if pos_norm == current_pre_pos and current_pre_txt == target_pre_char:\n            # Bumping an existing pre-release of the same type at the same position.\n            # Base major/minor/patch numbers do not change. Only pre-release number increments.\n            final_pre_num = current_pre_num + 1\n        else:\n            # Adding a new pre-release, or switching type/position of pre-release.\n            # Apply standard increment to the selected position and reset subsequent parts.\n            if pos_norm == _BUMP_VERSION_MAJOR:\n                # _build_version_bump_type prevents pre-release on major, so this branch won't be hit for pre_release is not None\n                pass\n            elif pos_norm == _BUMP_VERSION_MINOR:\n                new_minor_num += 1\n                new_patch_num = 0\n            elif pos_norm == _BUMP_VERSION_PATCH:\n                new_patch_num += 1\n            final_pre_num = 0  # New pre-release starts from 0.\n\n        final_pre_txt = target_pre_char\n\n    # --- Assemble the final version string ---\n    version_parts_to_join: List[str] = [str(new_major_num)]\n\n    s_minor_component = str(new_minor_num)\n    s_patch_component = str(new_patch_num)\n\n    if final_pre_txt:\n        # Pre-release attachment logic from _each_version_part:\n        # If patch number is 0, attach to minor. Otherwise, attach to patch.\n        if new_patch_num == 0:\n            s_minor_component += f\"{final_pre_txt}{final_pre_num}\"\n        else:\n            s_patch_component += f\"{final_pre_txt}{final_pre_num}\"\n\n    version_parts_to_join.append(s_minor_component)\n\n    # Append the patch component only if it's non-zero, or if it carries a pre-release.\n    # Note: If new_patch_num is 0 and pre-release is attached to minor, s_patch_component will be \"0\"\n    # and should NOT be appended.\n    if new_patch_num != 0 or (final_pre_txt and not s_minor_component.endswith(f\"{final_pre_txt}{final_pre_num}\")):\n        version_parts_to_join.append(s_patch_component)\n\n    return \".\".join(version_parts_to_join)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # 1. Validate 'position' and get normalized positive index\n    pos = _build_version_bump_position(position)\n\n    # 2. Determine the specific bump type (e.g., major, minor-alpha)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # 3. Parse the input version string into a structured object\n    # This will raise ValueError if 'version' is invalid\n    ver_info = _build_version_info(version)\n\n    # Create a mutable representation of the version parts for modification\n    # _VersionPart has pos, txt, num, pre_txt, pre_num, name\n    # We will only modify num, pre_txt, pre_num\n    current_parts: List[Dict[str, Any]] = [\n        {'pos': p.pos, 'num': p.num, 'pre_txt': p.pre_txt, 'pre_num': p.pre_num}\n        for p in [ver_info.major, ver_info.minor, ver_info.patch]\n    ]\n\n    # Get the target part that will be affected by the bump\n    target_part = current_parts[pos]\n\n    # --- Core Logic: Apply the bump based on bump_type ---\n\n    # Case 1: No pre-release specified in bump_version call (pre_release is None or empty string)\n    if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_PATCH):\n        should_increment_num = True\n\n        # If an existing pre-release is being removed due to no pre_release arg being given\n        if ver_info.pre_pos != -1:\n            # Clear all pre-release information from the original version components.\n            # This handles cases like '1.2.4a1' -> '1.2.4' AND '1.2b0' -> '1.2.1'\n            for part_data in current_parts:\n                part_data['pre_txt'] = ''\n                part_data['pre_num'] = -1\n\n            # If the current bump position is the same as where the pre-release was,\n            # then we only remove the pre-release and do NOT increment the number.\n            if ver_info.pre_pos == pos:\n                should_increment_num = False\n            # If the pre-release was on an earlier part (e.g., 1.2b0, bumping patch),\n            # we *do* increment the number of the targeted part.\n            # 'should_increment_num' remains True.\n\n        if should_increment_num:\n            target_part['num'] += 1\n\n        # Zero out subsequent parts' numbers and clear their pre-releases\n        for i in range(pos + 1, 3):\n            current_parts[i]['num'] = 0\n            current_parts[i]['pre_txt'] = ''\n            current_parts[i]['pre_num'] = -1\n\n    # Case 2: Pre-release specified (bump_type indicates alpha/beta)\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n                        _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        new_pre_txt = 'a' if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA) else 'b'\n\n        # If the target part already has a pre-release of the *same* type, increment pre_num.\n        if target_part['pre_txt'] == new_pre_txt:\n            target_part['pre_num'] += 1\n        else:\n            # If target part has no pre-release, or a different pre-release type,\n            # increment the main number and set new pre-release to 0.\n            # If switching pre-release types (e.g., a to b), the main number is NOT incremented.\n            # (e.g., '1.2.4a1' -> '1.2.4b0')\n            if target_part['pre_txt'] == '':\n                target_part['num'] += 1\n\n            target_part['pre_txt'] = new_pre_txt\n            target_part['pre_num'] = 0\n\n        # Zero out subsequent parts' numbers and clear their pre-releases\n        for i in range(pos + 1, 3):\n            current_parts[i]['num'] = 0\n            current_parts[i]['pre_txt'] = ''\n            current_parts[i]['pre_num'] = -1\n    else:\n        # This case should ideally not be reached if _build_version_bump_type is exhaustive\n        raise RuntimeError(f\"Internal error: Unknown bump type '{bump_type}'\")\n\n    # --- Reconstruct the new version string ---\n    reconstructed_version_texts: List[str] = []\n    for i, part_data in enumerate(current_parts):\n        txt_segment = str(part_data['num'])\n        \n        # Apply special handling for patch=0 (like _each_version_part does)\n        # If it's the patch part (pos 2), its number is 0, and has no pre-release,\n        # then its string representation should be empty.\n        if i == 2 and part_data['num'] == 0 and part_data['pre_txt'] == '':\n            txt_segment = ''\n\n        # Append pre-release if it exists for this part\n        if part_data['pre_txt']:\n            txt_segment += part_data['pre_txt'] + str(part_data['pre_num'])\n        \n        reconstructed_version_texts.append(txt_segment)\n\n    # Remove trailing empty segments (e.g., '1', '2', '' -> '1.2')\n    while reconstructed_version_texts and reconstructed_version_texts[-1] == '':\n        reconstructed_version_texts.pop()\n\n    # Join the segments with dots to form the final version string\n    return \".\".join(reconstructed_version_texts)\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n# The following constants and NamedTuples are available from the file content:\n# _BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_PATCH\n# _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA\n# _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA\n# _VersionPart, _VersionInfo\n\n# The following context functions are available from the file content:\n# _build_version_bump_position\n# _build_version_bump_type\n# _build_version_info\n# _each_version_part\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # 1. Validate and normalize the 'position' argument.\n    # This function ensures 'position' is a valid 0, 1, or 2 (for major, minor, patch).\n    pos_positive = _build_version_bump_position(position)\n\n    # 2. Parse the input 'version' string into a structured object.\n    # This step uses StrictVersion internally and will raise ValueError if 'version' is invalid.\n    version_info = _build_version_info(version)\n\n    # 3. Determine the specific type of bump (e.g., major, minor, patch, minor-alpha, etc.).\n    # This function also validates the 'pre_release' argument and raises ValueError for invalid combinations.\n    bump_type = _build_version_bump_type(pos_positive, pre_release)\n\n    # Initialize a mutable list of version numbers [major, minor, patch] from the parsed version.\n    # These are the base numeric parts of the version string.\n    nums = [version_info.major.num, version_info.minor.num, version_info.patch.num]\n\n    # Initialize variables for the new pre-release components.\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    # Check if the existing version has a pre-release specifically on the target position.\n    has_current_pre_on_target_pos = (version_info.pre_pos == pos_positive)\n    current_target_pre_txt = ''\n    current_target_pre_num = -1\n\n    # If there's an existing pre-release at the target position, extract its details.\n    if has_current_pre_on_target_pos:\n        if pos_positive == _BUMP_VERSION_MINOR:\n            current_target_pre_txt = version_info.minor.pre_txt\n            current_target_pre_num = version_info.minor.pre_num\n        elif pos_positive == _BUMP_VERSION_PATCH:\n            current_target_pre_txt = version_info.patch.pre_txt\n            current_target_pre_num = version_info.patch.pre_num\n\n    # --- Apply the bumping logic based on whether 'pre_release' was specified and the 'bump_type' ---\n\n    # Scenario 1: 'pre_release' is None.\n    # This implies either removing an existing pre-release or performing a standard major/minor/patch bump.\n    if pre_release is None:\n        # If there's an existing pre-release AND the 'position' is the default (patch, 2),\n        # this is the special case where the intent is ONLY to remove the pre-release.\n        # Example: `bump_version('1.2.4a1')` -> `'1.2.4'`\n        if version_info.pre_pos != -1 and position == _BUMP_VERSION_PATCH:\n            # The base `nums` (major, minor, patch) are already correct for the post-pre-release state.\n            # `new_pre_txt` and `new_pre_num` remain their initialized empty/negative values,\n            # effectively removing any pre-release during string construction. No increment to base needed.\n            pass\n        else:\n            # This handles:\n            #   - Standard major/minor/patch bumps (e.g., `1.2.2` -> `1.2.3`, `1.2.3` (pos=1) -> `1.3`).\n            #   - Removing an existing pre-release *followed by* a specific bump\n            #     (e.g., `1.2b0` (pos=2) -> `1.2.1`).\n            # In these cases, increment the numeric part at 'pos_positive' and reset subsequent parts to 0.\n            nums[pos_positive] += 1\n            for i in range(pos_positive + 1, 3):  # Reset subsequent parts (minor/patch) to 0\n                nums[i] = 0\n            # `new_pre_txt` and `new_pre_num` remain empty/negative, as no pre-release is desired.\n\n    # Scenario 2: 'pre_release' is not None.\n    # This implies creating a new pre-release or incrementing an existing one.\n    else:\n        # Set the 'new_pre_txt' (e.g., 'a' or 'b') based on the determined 'bump_type'.\n        if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA):\n            new_pre_txt = 'a'\n        elif bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA):\n            new_pre_txt = 'b'\n\n        # If a pre-release currently exists at the target position AND its type matches the new type:\n        if has_current_pre_on_target_pos and current_target_pre_txt == new_pre_txt:\n            # Example: `bump_version('1.2.4a0', pre_release='a')` -> `'1.2.4a1'`\n            # Increment only the pre-release number; the base numbers remain unchanged.\n            new_pre_num = current_target_pre_num + 1\n        else:\n            # This handles cases where:\n            #   - No pre-release existed for this part (e.g., `1.2.3` -> `1.2.4a0`).\n            #   - A pre-release existed, but its type is changing (e.g., `1.2.4a1` -> `1.2.4b0`).\n            #   - A pre-release existed on a different part.\n            # In these cases, increment the base number at 'pos_positive', reset subsequent parts to 0,\n            # and start the new pre-release number at 0.\n            nums[pos_positive] += 1\n            for i in range(pos_positive + 1, 3):\n                nums[i] = 0\n            new_pre_num = 0\n\n    # --- Construct the final version string ---\n    # Build the base version string (e.g., \"1.2.3\") from the calculated numbers.\n    version_parts = [str(nums[0]), str(nums[1]), str(nums[2])]\n    version_str_base = \".\".join(version_parts)\n\n    # Append the pre-release part if it's defined.\n    if new_pre_txt:\n        version_str_base += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Use StrictVersion to parse the constructed string and then convert it back to a string.\n    # This ensures the output is in the canonical normalized format (e.g., '1.2.0' becomes '1.2').\n    try:\n        return str(StrictVersion(version_str_base))\n    except ValueError as e:\n        # This is a safeguard; ideally, our logic should produce a valid version string.\n        raise ValueError(\n            f\"Failed to generate a valid version string: '{version_str_base}'. Error: {e}\"\n        ) from e\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nimport distutils.version\nfrom typing import Optional, cast\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # 1. Validate and normalize position. This will raise ValueError if invalid.\n    pos_positive = _build_version_bump_position(position)\n\n    # 2. Determine the bump type. This will also raise ValueError for invalid pre_release or major pre-release bump.\n    bump_type = _build_version_bump_type(pos_positive, pre_release)\n\n    # 3. Parse the version string into structured info. This will raise ValueError if version is invalid.\n    info = _build_version_info(version)\n\n    # 4. Initialize new version parts based on current version\n    new_major_num = info.major.num\n    new_minor_num = info.minor.num\n    new_patch_num = info.patch.num\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    if pre_release is None:\n        # Case A: No pre_release specified. Either a core bump or removing an existing pre_release.\n        if info.pre_pos == pos_positive:\n            # If a pre-release existed at the target position, remove it.\n            # The core version numbers remain as they are, effectively \"finalizing\" it.\n            pass\n        else:\n            # No pre-release at target position, perform a standard core bump.\n            if bump_type == _BUMP_VERSION_MAJOR:\n                new_major_num += 1\n                new_minor_num = 0\n                new_patch_num = 0\n            elif bump_type == _BUMP_VERSION_MINOR:\n                new_minor_num += 1\n                new_patch_num = 0\n            elif bump_type == _BUMP_VERSION_PATCH:\n                new_patch_num += 1\n    else:\n        # Case B: pre_release is specified. Perform a pre-release bump.\n        canonical_pre_txt = pre_release.strip().lower()[0] # 'a' or 'b'\n\n        if info.pre_pos == pos_positive:\n            # A pre-release already exists at this position.\n            current_part = info.minor if pos_positive == _BUMP_VERSION_MINOR else info.patch\n            if current_part.pre_txt == canonical_pre_txt:\n                # Same pre-release type (e.g., 'a' to 'a'), increment the pre-release number.\n                new_pre_txt = current_part.pre_txt\n                new_pre_num = current_part.pre_num + 1\n            else:\n                # Different pre-release type (e.g., 'a' to 'b'), reset pre-release number to 0.\n                new_pre_txt = canonical_pre_txt\n                new_pre_num = 0\n            # Core parts (major, minor, patch) remain unchanged in this specific scenario.\n        else:\n            # No pre-release at this position, create a new one.\n            if bump_type in _BUMP_VERSION_MINORS: # Minor pre-release bump\n                new_minor_num += 1\n                new_patch_num = 0\n            elif bump_type in _BUMP_VERSION_PATCHES: # Patch pre-release bump\n                new_patch_num += 1\n\n            new_pre_txt = canonical_pre_txt\n            new_pre_num = 0\n\n    # 5. Assemble the new version string and use StrictVersion for proper formatting.\n    new_version_str = f\"{new_major_num}.{new_minor_num}.{new_patch_num}\"\n    if new_pre_txt and new_pre_num != -1:\n        new_version_str += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Use StrictVersion to handle implicit trailing zero removal (e.g., 1.2.0 -> 1.2)\n    return str(distutils.version.StrictVersion(new_version_str))\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n# The following constants and helper functions are provided in the file content\n# and are thus available in the scope of the `bump_version` function:\n# _BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_PATCH,\n# _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n# _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA,\n# _BUMP_VERSION_POSITION_NAMES, _VersionPart, _VersionInfo,\n# _each_version_part, _build_version_info, _build_version_bump_position,\n# _build_version_bump_type.\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Step 1: Parse the input version string into a structured _VersionInfo object.\n    # This call implicitly handles ValueError for invalid version strings.\n    version_info = _build_version_info(version)\n\n    # Step 2: Validate and normalize the 'position' argument into a positive index (0, 1, or 2).\n    # This call implicitly handles ValueError for invalid position values.\n    pos_positive = _build_version_bump_position(position)\n\n    # Step 3: Determine the effective pre_release string and if it implies a pre-release operation.\n    effective_pre_release = pre_release.strip().lower() if pre_release else ''\n    is_prerelease_op = effective_pre_release in ('a', 'alpha', 'b', 'beta')\n\n    # Determine the single character for the target pre-release type ('a' or 'b')\n    target_prerelease_char = ''\n    if effective_pre_release in ('a', 'alpha'):\n        target_prerelease_char = 'a'\n    elif effective_pre_release in ('b', 'beta'):\n        target_prerelease_char = 'b'\n\n    # Explicitly check for invalid pre_release values not handled by _build_version_bump_type\n    # (The _build_version_bump_type will raise ValueError if prerelease is invalid,\n    # but the docstring implies handling for None, which is not an error here)\n    if pre_release is not None and not is_prerelease_op and effective_pre_release != '':\n        raise ValueError(\n            \"The given value for 'pre_release', %r, can only be one of: \"\n            \"'a', 'alpha', 'b', 'beta', None.\" % pre_release\n        )\n\n    # Validate that pre-release bumps cannot be applied to the 'major' part (position 0).\n    # This check is also performed by _build_version_bump_type, but having it here\n    # ensures consistent error messaging if we were to deviate.\n    if is_prerelease_op and pos_positive == 0:\n        raise ValueError(\n            \"Only the 'minor' or 'patch' parts of the version number \"\n            \"can get a prerelease bump.\"\n        )\n\n    # Initialize the new version parts with the current numerical values from the input version.\n    res_major = version_info.major.num\n    res_minor = version_info.minor.num\n    res_patch = version_info.patch.num\n    res_pre_txt = ''  # New pre-release text (e.g., 'a' or 'b')\n    res_pre_num = -1  # New pre-release number (e.g., 0, 1, 2)\n\n    # Get the current pre-release details if one exists at the target position.\n    current_pre_txt_at_pos = ''\n    current_pre_num_at_pos = -1\n    if version_info.pre_pos != -1 and version_info.pre_pos == pos_positive:\n        if pos_positive == 1:  # Pre-release is on the minor part\n            current_pre_txt_at_pos = version_info.minor.pre_txt\n            current_pre_num_at_pos = version_info.minor.pre_num\n        elif pos_positive == 2:  # Pre-release is on the patch part\n            current_pre_txt_at_pos = version_info.patch.pre_txt\n            current_pre_num_at_pos = version_info.patch.pre_num\n\n    # Step 4: Apply the bumping logic based on whether a pre-release is requested.\n    if is_prerelease_op:\n        # User explicitly requested to add or increment a pre-release.\n        if pos_positive == version_info.pre_pos:\n            # The target position already has an existing pre-release.\n            if target_prerelease_char == current_pre_txt_at_pos:\n                # Same pre-release type: Increment the pre-release number.\n                # Base numbers (major, minor, patch) remain unchanged.\n                res_pre_txt = target_prerelease_char\n                res_pre_num = current_pre_num_at_pos + 1\n            else:\n                # Different pre-release type (e.g., 'a' to 'b'): Reset pre-release number to 0.\n                # Base numbers (major, minor, patch) also remain unchanged.\n                # Example: '1.2.4a1' -> '1.2.4b0'\n                res_pre_txt = target_prerelease_char\n                res_pre_num = 0\n        else:\n            # The target position does NOT have an existing pre-release, or it's at a different position.\n            # This implies creating a NEW pre-release series on the target part,\n            # after incrementing that part (and resetting subsequent parts).\n            if pos_positive == 1:  # Target is minor\n                res_minor += 1\n                res_patch = 0  # Reset patch when minor is bumped\n            elif pos_positive == 2:  # Target is patch\n                # If original patch was 0 and hidden (e.g. '1.2' is '1.2.0'), it remains 0.\n                # Otherwise, it increments. Example: '1.2' -> '1.2.0a0', '1.2.3' -> '1.2.4a0'.\n                if version_info.patch.txt == '':\n                    res_patch = 0\n                else:\n                    res_patch += 1\n            res_pre_txt = target_prerelease_char\n            res_pre_num = 0\n    else:\n        # User did not request a pre-release (pre_release is None or empty string).\n        # This implies either stripping an existing pre-release or a standard bump.\n        if version_info.pre_pos != -1 and pos_positive == version_info.pre_pos:\n            # If an existing pre-release is found at the target position and no\n            # new pre-release is specified, simply remove the pre-release.\n            # Base numbers (major, minor, patch) remain unchanged.\n            # Example: '1.2.4a1' -> '1.2.4'\n            pass  # res_major, res_minor, res_patch already hold original values\n        else:\n            # Standard major/minor/patch bump without any pre-release involvement.\n            # Any existing pre-release not at the 'pos_positive' will be removed.\n            # Example: '1.2b0' with position=2 -> '1.2.1'\n            if pos_positive == 0:  # Target is major\n                res_major += 1\n                res_minor = 0  # Reset minor and patch\n                res_patch = 0\n            elif pos_positive == 1:  # Target is minor\n                res_minor += 1\n                res_patch = 0  # Reset patch\n            elif pos_positive == 2:  # Target is patch\n                res_patch += 1\n\n    # Step 5: Construct the new version string from the calculated parts.\n    version_parts_str: List[str] = [str(res_major), str(res_minor)]\n\n    # Include the patch part in the string if it's non-zero, OR if a pre-release is being added.\n    # A pre-release forces the patch part to be explicitly '0' if it was implicitly so (e.g., '1.2' -> '1.2.0a0').\n    if res_patch != 0 or res_pre_txt != '':\n        version_parts_str.append(str(res_patch))\n\n    new_version_str = \".\".join(version_parts_str)\n\n    # Append the pre-release string and number if applicable.\n    if res_pre_txt != '':\n        new_version_str += f\"{res_pre_txt}{res_pre_num}\"\n\n    return new_version_str\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom distutils.version import StrictVersion\n\n\n__all__ = ['bump_version']\n\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: Tuple[int, ...] = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: Tuple[int, ...] = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES: Dict[int, str] = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart(NamedTuple):\n    pos: int\n    txt: str\n    num: int\n    pre_txt: str\n    pre_num: int\n    name: str\n\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\nclass _VersionInfo(NamedTuple):\n    version: str\n    major: _VersionPart\n    minor: _VersionPart\n    patch: _VersionPart\n    pre_pos: int  # The pre-release position. -1 means no pre-release\n\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\nfrom typing import Optional, List\n\n# The following constants and helper functions are defined in the file context\n# and are implicitly available, so no explicit import is needed within the function:\n# _BUMP_VERSION_MAJOR\n# _BUMP_VERSION_MINOR\n# _BUMP_VERSION_PATCH\n# _BUMP_VERSION_MINORS\n# _BUMP_VERSION_PATCHES\n# _build_version_info\n# _build_version_bump_position\n# _build_version_bump_type\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    pos_norm = _build_version_bump_position(position)\n    vinfo = _build_version_info(version)\n\n    new_major_num = vinfo.major.num\n    new_minor_num = vinfo.minor.num\n    new_patch_num = vinfo.patch.num\n\n    # Get current pre-release info for comparison\n    current_pre_txt = ''\n    current_pre_num = -1\n    current_pre_pos = -1\n\n    if vinfo.pre_pos != -1:\n        if vinfo.pre_pos == _BUMP_VERSION_MINOR:\n            current_pre_txt = vinfo.minor.pre_txt\n            current_pre_num = vinfo.minor.pre_num\n            current_pre_pos = _BUMP_VERSION_MINOR\n        elif vinfo.pre_pos == _BUMP_VERSION_PATCH:\n            current_pre_txt = vinfo.patch.pre_txt\n            current_pre_num = vinfo.patch.pre_num\n            current_pre_pos = _BUMP_VERSION_PATCH\n\n    final_pre_txt = ''\n    final_pre_num = -1\n\n    if pre_release is None:\n        # Scenario: No pre-release requested (remove existing or simple bump)\n        # Apply standard increment to the selected position and reset subsequent parts.\n        # If there was an existing pre-release, it's now dropped.\n        if pos_norm == _BUMP_VERSION_MAJOR:\n            new_major_num += 1\n            new_minor_num = 0\n            new_patch_num = 0\n        elif pos_norm == _BUMP_VERSION_MINOR:\n            new_minor_num += 1\n            new_patch_num = 0\n        elif pos_norm == _BUMP_VERSION_PATCH:\n            new_patch_num += 1\n        # final_pre_txt and final_pre_num remain default, effectively removing pre-release.\n    else:\n        # Scenario: Pre-release requested (add new or increment/switch existing)\n        # Validate pre_release string and position first (will raise ValueError if invalid).\n        _build_version_bump_type(pos_norm, pre_release)\n        target_pre_char = 'a' if pre_release.strip().lower() in ('a', 'alpha') else 'b'\n\n        if pos_norm == current_pre_pos and current_pre_txt == target_pre_char:\n            # Bumping an existing pre-release of the same type at the same position.\n            # Base major/minor/patch numbers do not change. Only pre-release number increments.\n            final_pre_num = current_pre_num + 1\n        else:\n            # Adding a new pre-release, or switching type/position of pre-release.\n            # Apply standard increment to the selected position and reset subsequent parts.\n            if pos_norm == _BUMP_VERSION_MAJOR:\n                # _build_version_bump_type prevents pre-release on major, so this branch won't be hit for pre_release is not None\n                pass\n            elif pos_norm == _BUMP_VERSION_MINOR:\n                new_minor_num += 1\n                new_patch_num = 0\n            elif pos_norm == _BUMP_VERSION_PATCH:\n                new_patch_num += 1\n            final_pre_num = 0  # New pre-release starts from 0.\n\n        final_pre_txt = target_pre_char\n\n    # --- Assemble the final version string ---\n    version_parts_to_join: List[str] = [str(new_major_num)]\n\n    s_minor_component = str(new_minor_num)\n    s_patch_component = str(new_patch_num)\n\n    if final_pre_txt:\n        # Pre-release attachment logic from _each_version_part:\n        # If patch number is 0, attach to minor. Otherwise, attach to patch.\n        if new_patch_num == 0:\n            s_minor_component += f\"{final_pre_txt}{final_pre_num}\"\n        else:\n            s_patch_component += f\"{final_pre_txt}{final_pre_num}\"\n\n    version_parts_to_join.append(s_minor_component)\n\n    # Append the patch component only if it's non-zero, or if it carries a pre-release.\n    # Note: If new_patch_num is 0 and pre-release is attached to minor, s_patch_component will be \"0\"\n    # and should NOT be appended.\n    if new_patch_num != 0 or (final_pre_txt and not s_minor_component.endswith(f\"{final_pre_txt}{final_pre_num}\")):\n        version_parts_to_join.append(s_patch_component)\n\n    return \".\".join(version_parts_to_join)\n\n\nimport pickle\ndef test_5():\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == '1.2.4a0'\ntest_5()\n\ndef test_18():\n    assert bump_version('1.0.0b0', position=2) == '1.0.1'\ntest_18()\n\ndef test_20():\n    assert bump_version('1.2.3', 2, 'b') == '1.2.4b0'\ntest_20()\n\ndef test_21():\n    assert bump_version(\"1.2.3b0\") == '1.2.3'\ntest_21()\n\ndef test_24():\n    assert bump_version('1.2.4a2') == '1.2.4'\ntest_24()\n\ndef test_45():\n    assert bump_version('1.2.4b1') == '1.2.4'\ntest_45()\n\ndef test_49():\n    assert bump_version('1.0.2')   == '1.0.3'\ntest_49()\n\ndef test_51():\n    assert bump_version('2.1.3', position=1, pre_release='a') == '2.2a0'\ntest_51()\n\ndef test_56():\n    assert bump_version(\"2.1.3\", position=1, pre_release='a') == \"2.2a0\"\ntest_56()\n\ndef test_61():\n    assert bump_version('1.0.0a1', position=2) == '1.0.1'\ntest_61()\n\ndef test_62():\n    assert bump_version('1.0.0', pre_release='a')         == '1.0.1a0'\ntest_62()\n\ndef test_65():\n    assert bump_version(\"1.2.3\") == '1.2.4'\ntest_65()\n\ndef test_68():\n    assert bump_version('1.2.3', pre_release='a') == '1.2.4a0'\ntest_68()\n\ndef test_72():\n    assert bump_version('1.2.3', 2, pre_release='b') == '1.2.4b0'\ntest_72()\n\ndef test_77():\n    assert bump_version('1.2.4', pre_release='a') == '1.2.5a0'\ntest_77()\n\ndef test_89():\n    assert bump_version('1.2.3a0', pre_release='b') == '1.2.3b0'\ntest_89()\n\ndef test_99():\n    assert bump_version('1.2.0') == '1.2.1'\ntest_99()\n\ndef test_101():\n    assert bump_version('1.0.0', position=2, pre_release='a') == '1.0.1a0'\ntest_101()\n\ndef test_102():\n    assert bump_version(\"1.2b0\", position=2) == \"1.2.1\"\ntest_102()\n\ndef test_104():\n    assert bump_version('1.2.4a0', 2) == '1.2.4'\ntest_104()\n\ndef test_108():\n    assert bump_version('0.2.4a1') == '0.2.4'\ntest_108()\n\ndef test_112():\n    assert bump_version(\"2.1.3\") == \"2.1.4\"\ntest_112()\n\ndef test_117():\n    assert bump_version('1.0.0', pre_release='a') == '1.0.1a0'\ntest_117()\n\ndef test_121():\n    assert bump_version('1.0.0', pre_release='b') == '1.0.1b0'\ntest_121()\n\ndef test_123():\n    assert bump_version('1.2.4a0', position=2) == '1.2.4'\ntest_123()\n\ndef test_143():\n    assert bump_version('1.2.4', position=1, pre_release='b') == '1.3b0'\ntest_143()\n\ndef test_145():\n    assert bump_version('1.2.3', position=1, pre_release='a') == '1.3a0'\ntest_145()\n\ndef test_147():\n    assert '1.2.4' == bump_version('1.2.3')\ntest_147()\n\ndef test_149():\n    assert bump_version('1.2.4b0') == '1.2.4'\ntest_149()\n\ndef test_150():\n    assert bump_version('1.2.3', 2, 'a') == '1.2.4a0'\ntest_150()\n\ndef test_160():\n    assert bump_version('1.2.4a1', 2, 'b') == '1.2.4b0'\ntest_160()\n\ndef test_161():\n    assert bump_version('1.2.4', 2) == '1.2.5'\ntest_161()\n\ndef test_169():\n    assert bump_version('1.2.3', 1, 'a') == '1.3a0'\ntest_169()\n\ndef test_170():\n    assert bump_version('1.2.4', position=2, pre_release='b') == '1.2.5b0'\ntest_170()\n\ndef test_172():\n    assert bump_version('1.0.0b1', position=2) == '1.0.1'\ntest_172()\n\ndef test_178():\n    assert bump_version('2.1.3', 1, pre_release='a') == '2.2a0'\ntest_178()\n\ndef test_184():\n    assert bump_version('1.2.3', position=2, pre_release='a') == '1.2.4a0'\ntest_184()\n\ndef test_186():\n    assert bump_version('1.2.3', position=2) == '1.2.4'\ntest_186()\n\ndef test_189():\n    assert bump_version('1.2.4', position=2) == '1.2.5'\ntest_189()\n\ndef test_192():\n    assert bump_version('2.1.3', pre_release='a') == '2.1.4a0'\ntest_192()\n\ndef test_196():\n    assert bump_version('1.2.4a1', 2, 'a') == '1.2.4a2'\ntest_196()\n\ndef test_204():\n    assert bump_version('1.2.4a1', 2) == '1.2.4'\ntest_204()\n\ndef test_206():\n    assert bump_version(\"1.2.3b1\") == '1.2.3'\ntest_206()\n\ndef test_232():\n    assert bump_version('1.0.0') == '1.0.1'\ntest_232()\n\ndef test_233():\n    assert bump_version('1.2.3', 2, pre_release='a') == '1.2.4a0'\ntest_233()\n\ndef test_237():\n    assert bump_version('1.2.4b2') == '1.2.4'\ntest_237()\n\ndef test_243():\n    assert bump_version(\"1.2.4a1\") == \"1.2.4\"\ntest_243()\n\ndef test_244():\n    assert bump_version('2.1.3', position=2, pre_release='b') == '2.1.4b0'\ntest_244()\n\ndef test_245():\n    assert bump_version('1.0.0')   == '1.0.1'\ntest_245()\n\ndef test_248():\n    assert bump_version('0.2.4b0') == '0.2.4'\ntest_248()\n\ndef test_254():\n    assert bump_version('1.2.4', position=1, pre_release='a') == '1.3a0'\ntest_254()\n\ndef test_258():\n    assert bump_version('1.0.0', position=2) == '1.0.1'\ntest_258()\n\ndef test_259():\n    assert bump_version('1.2.3b0', position=1, pre_release='a') == '1.3a0'\ntest_259()\n\ndef test_265():\n    assert bump_version('0.2.3') == '0.2.4'\ntest_265()\n\ndef test_266():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"b\") == '1.3b0'\ntest_266()\n\ndef test_273():\n    assert bump_version('0.0.0', position=2) == '0.0.1'\ntest_273()\n\ndef test_278():\n    assert bump_version('2.1.3') == '2.1.4'\ntest_278()\n\ndef test_280():\n    assert bump_version('1.2.4a1') == '1.2.4'\ntest_280()\n\ndef test_281():\n    assert bump_version('1.2.3') == '1.2.4'\ntest_281()\n\ndef test_290():\n    assert bump_version('0.0.1', position=1, pre_release='a') == '0.1a0'\ntest_290()\n\ndef test_297():\n    assert bump_version(\"1.2.4b1\", position=1, pre_release=\"a\") == '1.3a0'\ntest_297()\n\ndef test_305():\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"a\") == '1.2.5a0'\ntest_305()\n\ndef test_309():\n    assert bump_version('1.2.3', position=2, pre_release='b') == '1.2.4b0'\ntest_309()\n\ndef test_311():\n    assert bump_version('1.2.4') == '1.2.5'\ntest_311()\n\ndef test_322():\n    assert bump_version('1.2.3a0') == '1.2.3'\ntest_322()\n\ndef test_324():\n    assert bump_version(\"1.2.4b0\") == \"1.2.4\"\ntest_324()\n\ndef test_327():\n    assert bump_version('1.2b0', position=2) == '1.2.1'\ntest_327()\n\ndef test_329():\n    assert bump_version('1.2.4', position=2, pre_release='a') == '1.2.5a0'\ntest_329()\n\ndef test_340():\n    assert bump_version('1.0.0', position=2, pre_release='b') == '1.0.1b0'\ntest_340()\n\ndef test_341():\n    assert bump_version('1.2.3a1') == '1.2.3'\ntest_341()\n\ndef test_343():\n    assert bump_version('1.2.3', pre_release='b') == '1.2.4b0'\ntest_343()\n\ndef test_346():\n    assert bump_version('1.2.3b1') == '1.2.3'\ntest_346()\n\ndef test_347():\n    assert bump_version('1.2.3', 2) == '1.2.4'\ntest_347()\n\ndef test_353():\n    assert bump_version('1.2.4a0') == '1.2.4'\ntest_353()\n\ndef test_356():\n    assert '1.3.1a0' == bump_version('1.3.0', position=2, pre_release='a')\ntest_356()\n\ndef test_368():\n    assert bump_version('1.0.0a0', position=2) == '1.0.1'\ntest_368()\n\ndef test_369():\n    assert bump_version('1.2.3b1', position=2, pre_release='a') == '1.2.4a0'\ntest_369()\n\ndef test_370():\n    assert bump_version('1.2.4b0', 2) == '1.2.4'\ntest_370()\n\ndef test_374():\n    assert bump_version('1.2.4', position=1) == '1.3'\ntest_374()\n\ndef test_382():\n    assert bump_version('1.0.0')                          == '1.0.1'\ntest_382()\n\ndef test_385():\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == '1.3a0'\ntest_385()\n\ndef test_398():\n    assert bump_version('1.2.5') == '1.2.6'\ntest_398()\n\ndef test_402():\n    assert bump_version('1.2.3', position=1, pre_release='b') == '1.3b0'\ntest_402()\n\ndef test_407():\n    assert bump_version('1.2.3b0') == '1.2.3'\ntest_407()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.16') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='a') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=2) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2a0') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2, pre_release=\"b\") == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0b0', pre_release='a') == output\ntest_10()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_13()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 1) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3') == output\ntest_27()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 1) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=2) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=1) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='b') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 1, pre_release='b') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2, pre_release='a') == output\ntest_34()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', 0) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', 2) == output\ntest_40()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'b') == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=2) == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='b') == output\ntest_44()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.10') == output\ntest_52()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.0a2') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=2) == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 1) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', pre_release='b') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0b0', position=2) == output\ntest_60()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1') == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'a') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1') == output\ntest_67()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_76()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b1', position=1) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, pre_release='a') == output\ntest_79()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.12') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', position=1) == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='b') == output\ntest_90()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 1) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_95()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 0) == output\ntest_98()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_100()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=2) == output\ntest_107()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2) == output\ntest_111()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_114()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b3') == output\ntest_119()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a', position=2) == output\ntest_120()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='b') == output\ntest_124()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', pre_release='b') == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1) == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 1) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', pre_release='b') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=1) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=1) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_137()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_139()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=1) == output\ntest_141()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 0) == output\ntest_148()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 2, 'b') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.19') == output\ntest_157()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 2) == output\ntest_158()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', pre_release='b') == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='a') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=2) == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2, pre_release='b') == output\ntest_167()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=1) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1b0', position=1) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2) == output\ntest_175()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.9') == output\ntest_177()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1', position=2) == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=1) == output\ntest_183()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 2) == output\ntest_185()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b2') == output\ntest_187()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_195()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'a') == output\ntest_197()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"a\") == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2, \"b\") == output\ntest_202()\n\ndef test_205():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_205\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2') == output\ntest_205()\n\ndef test_209():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_209\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_209()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a1') == output\ntest_210()\n\ndef test_214():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_214\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 1) == output\ntest_214()\n\ndef test_216():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_216\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0', position=1) == output\ntest_216()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.4b1\", position=2) == output\ntest_219()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-1) == output\ntest_223()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.1a1', position=2) == output\ntest_225()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', pre_release='b') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b0\", 1) == output\ntest_230()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.2.0a0', pre_release='b') == output\ntest_235()\n\ndef test_236():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_236\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', 2, 'a') == output\ntest_236()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_240()\n\ndef test_241():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_241\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_241()\n\ndef test_242():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_242\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 1, 'b') == output\ntest_242()\n\ndef test_249():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_249\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_249()\n\ndef test_250():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_250\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='b') == output\ntest_250()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a0') == output\ntest_253()\n\ndef test_256():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_256\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_256()\n\ndef test_260():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_260\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\") == output\ntest_260()\n\ndef test_262():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_262\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 1) == output\ntest_262()\n\ndef test_264():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_264\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0', position=1, pre_release='a') == output\ntest_264()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=2) == output\ntest_267()\n\ndef test_268():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_268\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', position=1, pre_release='b') == output\ntest_268()\n\ndef test_271():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_271\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\", 2) == output\ntest_271()\n\ndef test_272():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_272\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', position=2, pre_release='a') == output\ntest_272()\n\ndef test_274():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_274\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0', position=1) == output\ntest_274()\n\ndef test_277():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_277\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_277()\n\ndef test_279():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_279\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=0) == output\ntest_279()\n\ndef test_284():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_284\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2, pre_release='a') == output\ntest_284()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0', position=2, pre_release='b') == output\ntest_287()\n\ndef test_289():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_289\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b1', position=0) == output\ntest_289()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b1') == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a') == output\ntest_295()\n\ndef test_296():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_296\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a0\") == output\ntest_296()\n\ndef test_298():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_298\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='b') == output\ntest_298()\n\ndef test_299():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_299\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a1', 0) == output\ntest_299()\n\ndef test_303():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_303\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.15') == output\ntest_303()\n\ndef test_306():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_306\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a0') == output\ntest_306()\n\ndef test_307():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_307\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0') == output\ntest_307()\n\ndef test_310():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_310\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='b') == output\ntest_310()\n\ndef test_314():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_314\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3a1\", 1) == output\ntest_314()\n\ndef test_316():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_316\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4a2') == output\ntest_316()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4b0', 2, 'a') == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=0) == output\ntest_320()\n\ndef test_321():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_321\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.17') == output\ntest_321()\n\ndef test_323():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_323\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2) == output\ntest_323()\n\ndef test_325():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_325\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1) == output\ntest_325()\n\ndef test_326():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_326\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', pre_release='a') == output\ntest_326()\n\ndef test_330():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_330\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.13') == output\ntest_330()\n\ndef test_331():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_331\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0') == output\ntest_331()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=1, pre_release='a') == output\ntest_334()\n\ndef test_338():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_338\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.11') == output\ntest_338()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=0) == output\ntest_339()\n\ndef test_342():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_342\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('2.1.3', position=2, pre_release='a') == output\ntest_342()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a2', position=1) == output\ntest_344()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.20') == output\ntest_350()\n\ndef test_351():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_351\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 2, 'b') == output\ntest_351()\n\ndef test_352():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_352\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3a0', position=2, pre_release='b') == output\ntest_352()\n\ndef test_358():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_358\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.2b0') == output\ntest_358()\n\ndef test_360():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_360\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', pre_release='a', position=-2) == output\ntest_360()\n\ndef test_363():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_363\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=1) == output\ntest_363()\n\ndef test_365():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_365\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b0', position=1) == output\ntest_365()\n\ndef test_366():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_366\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_366()\n\ndef test_367():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_367\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', 0) == output\ntest_367()\n\ndef test_372():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_372\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.14') == output\ntest_372()\n\ndef test_375():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_375\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1) == output\ntest_375()\n\ndef test_376():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_376\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=2) == output\ntest_376()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('0.0.0') == output\ntest_378()\n\ndef test_379():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_379\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.3.0a0', position=2) == output\ntest_379()\n\ndef test_380():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_380\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1') == output\ntest_380()\n\ndef test_381():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_381\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 1, 'a') == output\ntest_381()\n\ndef test_384():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_384\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', 2, 'a') == output\ntest_384()\n\ndef test_386():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_386\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version(\"1.2.3b1\", 2) == output\ntest_386()\n\ndef test_387():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_387\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.1b0', position=0) == output\ntest_387()\n\ndef test_396():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_396\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0b1', 1, 'b') == output\ntest_396()\n\ndef test_397():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_397\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3', position=1, pre_release='a') == output\ntest_397()\n\ndef test_399():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_399\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.4', 0) == output\ntest_399()\n\ndef test_401():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_401\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='b') == output\ntest_401()\n\ndef test_404():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_404\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0', position=1, pre_release='a') == output\ntest_404()\n\ndef test_405():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_405\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.2.3b0', position=2, pre_release='a') == output\ntest_405()\n\ndef test_406():\n    with open(\"/output/test-apps+flutils/test_output/flutils+packages/bump_version/test_406\", \"rb\") as f:\n        output = pickle.load(f)\n    assert bump_version('1.0.0a1', position=1) == output\ntest_406()\n\n\n"]}
{"task_id": 126, "project": "test-apps/flutils", "module": "flutils.namedtupleutils", "predictions": ["from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n@singledispatch\ndef _to_namedtuple(obj: Any, _started: bool = False) -> Any:\n    \"\"\"Helper for converting objects to namedtuples recursively.\"\"\"\n    return obj\n\n@_to_namedtuple.register(Mapping)\ndef _to_namedtuple_from_mapping(obj: Mapping, _started: bool = False) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                # Validate the key as a proper identifier, disallowing leading underscores\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # If the key is not a valid identifier or starts with an underscore, skip it\n                continue\n            if key.isidentifier(): # Redundant after validate_identifier, but preserves context logic\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))  # Sort keys alphabetically for non-OrderedDicts\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)  # Recursively convert values\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid arguments/keys, return an empty NamedTuple\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n@_to_namedtuple.register(Sequence)\ndef _to_namedtuple_from_sequence(obj: Sequence, _started: bool = False) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        # This branch handles string-like objects.\n        # If it's the initial call (not recursive) and `obj` is a string, it's an invalid top-level type.\n        # Otherwise, if it's a nested string, return it as is.\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict', 'NamedTuple', 'SimpleNamespace' \"\n                \"to a NamedTuple; got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n\n    if hasattr(obj, '_fields'):\n        # This branch handles NamedTuple objects.\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)  # Recursively convert attributes\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        # If the NamedTuple has no fields or no converted arguments, return the original object.\n        return obj\n\n    # This branch handles general sequence types like list and tuple.\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)  # Recursively convert items\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        # If the original object does not have an 'append' method (e.g., tuple),\n        # return a new tuple.\n        return tuple(out)\n    # If the original object has an 'append' method (e.g., list),\n    # return a new list.\n    return out\n\n@_to_namedtuple.register(SimpleNamespace)\ndef _to_namedtuple_from_simplenamespace(obj: SimpleNamespace, _started: bool = False) -> NamedTuple:\n    keys = []\n    # Use vars() to get the instance's own attributes.\n    for key, val in vars(obj).items():\n        try:\n            # Validate the attribute name as a proper identifier, disallowing leading underscores\n            validate_identifier(key, allow_underscore=False)\n            keys.append(key)\n        except SyntaxError:\n            # If the attribute name is not a valid identifier or starts with an underscore, skip it.\n            continue\n    keys.sort()  # Sort attributes alphabetically as per docstring\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)\n        val = _to_namedtuple(val, _started=True)  # Recursively convert attribute values\n        args.append(val)\n    if args:\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid attributes, return an empty NamedTuple\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj, _started=False)", "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\n@singledispatch\ndef _to_namedtuple_recursive(obj: Any, _started: bool = False) -> Any:\n    \"\"\"\n    Internal recursive helper for to_namedtuple.\n\n    This is a singledispatch generic function that dispatches based on the type\n    of `obj`. It handles recursive conversion of elements within collections.\n\n    Args:\n        obj: The object to be processed.\n        _started (bool): Internal flag, True if this is a recursive call.\n                         Used to prevent certain TypeErrors on initial call.\n    Returns:\n        The converted object or the original object if no conversion is needed.\n    \"\"\"\n    return obj\n\n\n@_to_namedtuple_recursive.register(Mapping)\ndef _to_namedtuple_from_mapping(\n    obj: Mapping,\n    _started: bool = False\n) -> NamedTuple:\n    \"\"\"\n    Converts a Mapping object (e.g., dict, OrderedDict) to a NamedTuple.\n\n    Keys that are valid Python identifiers and do not start with an underscore\n    become attributes of the NamedTuple. Keys are sorted alphabetically\n    unless the original object is an OrderedDict.\n    Values are recursively converted.\n    \"\"\"\n    keys = []\n    for key in obj.keys():\n        if isinstance(key, str):\n            try:\n                # Validate identifier as per docstring: no leading underscore, valid Python ID.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # Skip keys that are not valid identifiers or start with an underscore.\n                continue\n            # Redundant check but maintained for consistency with context function logic:\n            if key.isidentifier():\n                keys.append(key)\n\n    if not isinstance(obj, OrderedDict):\n        # Docstring: \"attributes of the returned NamedTuple are sorted alphabetically.\"\n        keys = tuple(sorted(keys))\n    else:\n        # Docstring: \"attributes ... keep the same order as the given OrderedDict keys.\"\n        keys = tuple(keys)\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert values\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create a NamedTuple with 'NamedTuple' as its type name.\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid keys were found.\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\n@_to_namedtuple_recursive.register(Sequence)\ndef _to_namedtuple_from_sequence(\n    obj: Sequence,\n    _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple]:\n    \"\"\"\n    Converts a Sequence object (e.g., list, tuple, NamedTuple) by recursively\n    converting its items. The original container type (list/tuple) is preserved.\n    \"\"\"\n    # Specific handling for strings passed as Sequences.\n    # The public 'to_namedtuple' function's _AllowedTypes excludes 'str',\n    # so this check primarily applies if this internal function is called\n    # directly with a string when _started is False, or to string elements\n    # during recursion.\n    if isinstance(obj, str):\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict', 'NamedTuple', 'SimpleNamespace' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return cast(str, obj)\n\n    # Handling for NamedTuple objects (which are also Sequences).\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                # Recursively convert attribute values\n                val = _to_namedtuple_recursive(val, _started=True)\n                args.append(val)\n            if args:\n                make = namedtuple('NamedTuple', fields)\n                out: NamedTuple = make(*args)\n                return out\n        # If NamedTuple has no fields or values, return it as is.\n        return obj\n\n    # Handling for general Sequences (list, tuple, etc.).\n    out = []\n    for item in obj:\n        # Recursively convert each item in the sequence.\n        val = _to_namedtuple_recursive(item, _started=True)\n        out.append(val)\n\n    # If the original object was a tuple-like (no 'append' method), return a tuple.\n    # Otherwise (e.g., list), return a list.\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple_recursive.register(SimpleNamespace)\ndef _to_namedtuple_from_simplenamespace(\n    obj: SimpleNamespace,\n    _started: bool = False\n) -> NamedTuple:\n    \"\"\"\n    Converts a SimpleNamespace object to a NamedTuple.\n\n    Attributes of the SimpleNamespace are converted to NamedTuple attributes,\n    sorted alphabetically. Only attributes with valid Python identifiers\n    (not starting with an underscore) are included.\n    Values are recursively converted.\n    \"\"\"\n    keys = []\n    # Docstring: \"attributes are sorted alphabetically\" for SimpleNamespace.\n    # Iterate over sorted keys from __dict__.\n    for key in sorted(obj.__dict__.keys()):\n        if isinstance(key, str):\n            try:\n                # Validate identifier.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)  # Access value via getattr for SimpleNamespace.\n        # Recursively convert values.\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    if args:\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid attributes were found.\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple}>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple}>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # The public entry point, calls the internal recursive dispatcher\n    # with _started=False to indicate it's the initial call.\n    return _to_namedtuple_recursive(obj, _started=False)", "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n# The file content already provides these imports and definitions\n# __all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\n@singledispatch\ndef _to_namedtuple_dispatcher(obj: Any, _started: bool = False) -> Any:\n    \"\"\"Internal dispatcher for recursively converting objects to NamedTuple.\"\"\"\n    # This is the default case for types not explicitly registered.\n    # It's primarily used for recursive calls where the value might be\n    # a basic type (int, str, float, etc.) that cannot be converted further\n    # into a NamedTuple. In such cases, the object is returned as is.\n    return obj\n\n\n@_to_namedtuple_dispatcher.register(Mapping)\ndef _convert_mapping_to_namedtuple(\n    obj: Mapping, _started: bool = False\n) -> NamedTuple:\n    \"\"\"Converts a Mapping (like dict or OrderedDict) to a NamedTuple.\"\"\"\n    keys = []\n    for key in obj.keys():\n        # Ensure key is string-like before validation\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                # Validate identifier, disallowing underscores at the start\n                # and filtering out invalid names, keywords, etc.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            # Double-check if it's a valid identifier after validation\n            if key.isidentifier():\n                keys.append(key)\n\n    # Sort keys alphabetically, unless the original object is an OrderedDict\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    else:\n        keys = tuple(keys) # Keep original order for OrderedDict\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert values using the dispatcher\n        val = _to_namedtuple_dispatcher(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create and return the NamedTuple\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid keys are found\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\n@_to_namedtuple_dispatcher.register(Sequence)\ndef _convert_sequence_to_namedtuple(\n    obj: Sequence, _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple]:\n    \"\"\"Converts a Sequence (list, tuple, NamedTuple) to a list or tuple of NamedTuples.\"\"\"\n    # Handle string-like objects specifically. Strings are sequences but\n    # should not be converted to NamedTuples themselves.\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            # If it's an initial call and the object is a string, raise an error\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj  # For recursive calls, return string as is\n\n    # Handle NamedTuple objects: recursively convert their fields\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                # Recursively convert attribute values\n                val = _to_namedtuple_dispatcher(val, _started=True)\n                args.append(val)\n            if args:\n                # Reconstruct the NamedTuple\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj  # Return original NamedTuple if it has no fields\n\n    # Handle other sequence types (list, tuple)\n    out = []\n    for item in obj:\n        # Recursively convert each item in the sequence\n        val = _to_namedtuple_dispatcher(item, _started=True)\n        out.append(val)\n\n    # Return a tuple if the original object was not a list (e.g., tuple)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out  # Return a list if the original object was a list\n\n\n@_to_namedtuple_dispatcher.register(SimpleNamespace)\ndef _convert_simplenamespace_to_namedtuple(\n    obj: SimpleNamespace, _started: bool = False\n) -> NamedTuple:\n    \"\"\"Converts a SimpleNamespace object to a NamedTuple.\"\"\"\n    # Get attributes as a dictionary\n    items = vars(obj)\n\n    keys = []\n    for key in items.keys():\n        # Ensure key is string-like\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                # Validate identifier, disallowing underscores at the start\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            # Double-check if it's a valid identifier after validation\n            if key.isidentifier():\n                keys.append(key)\n\n    # SimpleNamespace attributes are sorted alphabetically\n    keys = tuple(sorted(keys))\n\n    args = []\n    for key in keys:\n        val: Any = items[key]\n        # Recursively convert values\n        val = _to_namedtuple_dispatcher(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create and return the NamedTuple\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid attributes are found\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n            If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n            recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n            provided the items can be converted. Items that cannot be converted\n            will still exist in the returned object.\n\n            If the given type is of :obj:`list` the return value will be a new\n            :obj:`list`.  This means the items are not changed in the given\n            ``obj``.\n\n            If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n            (:obj:`dict`), keys that can be proper identifiers will become attributes\n            on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n            the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n            are sorted alphabetically.\n\n            If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n            the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n            keep the same order as the given\n            :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n            If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n            The attributes are sorted alphabetically in the returned\n            :obj:`NamedTuple <collections.NamedTuple>`.\n\n            Any identifier (key or attribute name) that starts with an underscore\n            cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n            All values are recursively converted.  This means a dictionary that\n            contains another dictionary, as one of it's values, will be converted\n            to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n            value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n        A list with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n        A tuple with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    # This public function simply dispatches to the internal\n    # _to_namedtuple_dispatcher, ensuring that _started is False for the\n    # initial call.\n    return _to_namedtuple_dispatcher(obj, _started=False)", "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n# _AllowedTypes is defined in the provided File Content\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n@singledispatch\ndef _to_namedtuple_recursive(obj: Any, _started: bool = False) -> Any:\n    \"\"\"Internal recursive helper for to_namedtuple.\n\n    This function is decorated with @singledispatch to handle different\n    object types.\n    The '_started' parameter indicates if this is a recursive call (True)\n    or the initial call from the public 'to_namedtuple' function (False).\n    \"\"\"\n    # Default case: if the type of 'obj' is not explicitly registered,\n    # return the object as is. This covers types not convertible to NamedTuple\n    # but that might be nested within convertible structures (e.g., int, str).\n    return obj\n\n@_to_namedtuple_recursive.register(Mapping)\ndef _(obj: Mapping, _started: bool = False) -> Union[NamedTuple, Tuple]:\n    \"\"\"Convert a Mapping (like dict or OrderedDict) to a NamedTuple.\n\n    This implementation is based on Context Function 6.\n    \"\"\"\n    keys = []\n    for key in obj.keys():\n        # Ensure key is a string and validate it as an identifier suitable for NamedTuple.\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # If the key is not a valid identifier (e.g., starts with '_'), skip it.\n                continue\n            # The .isidentifier() check is redundant after validate_identifier,\n            # but is kept for consistency with the provided context function.\n            if key.isidentifier():\n                keys.append(key)\n\n    # Sort keys alphabetically if not an OrderedDict, otherwise keep original order.\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    else:\n        keys = tuple(keys) # Ensure it's a tuple for namedtuple fields\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert the value.\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    # Create and return the NamedTuple.\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid arguments/keys, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n@_to_namedtuple_recursive.register(SimpleNamespace)\ndef _(obj: SimpleNamespace, _started: bool = False) -> NamedTuple:\n    \"\"\"Convert a SimpleNamespace to a NamedTuple.\n\n    Attributes are sorted alphabetically in the returned NamedTuple.\n    \"\"\"\n    keys = []\n    # Iterate over the SimpleNamespace's attributes, which are in its __dict__.\n    for key in obj.__dict__.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier(): # Redundant check\n                keys.append(key)\n\n    # SimpleNamespace attributes are sorted alphabetically as per docstring.\n    keys = tuple(sorted(keys))\n\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)\n        # Recursively convert the attribute value.\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    if args:\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid attributes, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n@_to_namedtuple_recursive.register(NamedTuple)\ndef _(obj: NamedTuple, _started: bool = False) -> NamedTuple:\n    \"\"\"Recursively convert the fields of a NamedTuple.\n\n    This implementation is based on the 'if hasattr(obj, '_fields')' block\n    from Context Function 7, adapted for a direct NamedTuple registration.\n    \"\"\"\n    fields: List[str] = list(obj._fields)\n    if fields:\n        # obj is already guaranteed to be a NamedTuple by the type hint.\n        args = []\n        for attr in obj._fields:\n            val: Any = getattr(obj, attr)\n            # Recursively convert each field's value.\n            val = _to_namedtuple_recursive(val, _started=True)\n            args.append(val)\n        if args:\n            # Reconstruct the NamedTuple with the converted values.\n            # noinspection Mypy\n            make = namedtuple('NamedTuple', fields) # type: ignore[misc]\n            # noinspection PyTypeChecker,PyArgumentList\n            out: NamedTuple = make(*args)\n            return out\n    # If the NamedTuple has no fields or values (e.g., empty), return the original object.\n    return obj\n\n@_to_namedtuple_recursive.register(List)\n@_to_namedtuple_recursive.register(Tuple)\ndef _(obj: Union[List, Tuple], _started: bool = False) -> Union[List[Any], Tuple[Any, ...]]:\n    \"\"\"Recursively convert items within a List or Tuple.\n\n    This implementation is based on Context Function 7, but adapted to use\n    the _to_namedtuple_recursive dispatcher for sub-items and without the\n    NamedTuple-specific handling (as NamedTuple has its own register).\n    \"\"\"\n    # The 'str' handling from Context 7 (checking _started=False) is\n    # not directly needed here as the top-level `to_namedtuple` only\n    # accepts types from `_AllowedTypes`, which excludes `str`.\n    # If a `str` is encountered during recursion, it will fall to the default\n    # `_to_namedtuple_recursive` which simply returns the string as is.\n\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        # Recursively convert each item in the list or tuple.\n        val = _to_namedtuple_recursive(item, _started=True)\n        out.append(val)\n\n    # Return a tuple if the original object was tuple-like, otherwise a list.\n    if not hasattr(obj, 'append'): # Lists have 'append', tuples do not.\n        return tuple(out)\n    return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n             a :obj:`NamedTuple <collections.namedtuple>`.\n\n        If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n        recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n        provided the items can be converted. Items that cannot be converted\n        will still exist in the returned object.\n\n        If the given type is of :obj:`list` the return value will be a new\n        :obj:`list`.  This means the items are not changed in the given\n        ``obj``.\n\n        If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n        (:obj:`dict`), keys that can be proper identifiers will become attributes\n        on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n        the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n        are sorted alphabetically.\n\n        If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n        the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n        keep the same order as the given\n        :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n        If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n        The attributes are sorted alphabetically in the returned\n        :obj:`NamedTuple <collections.NamedTuple>`.\n\n        Any identifier (key or attribute name) that starts with an underscore\n        cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n        All values are recursively converted.  This means a dictionary that\n        contains another dictionary, as one of it's values, will be converted\n        to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n        value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n        A list with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n        A tuple with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Delegate the conversion to the internal singledispatch helper function.\n    # The `_started` parameter defaults to False for the initial call.\n    return _to_namedtuple_recursive(obj)", "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\n@singledispatch\ndef _to_namedtuple(obj: Any, _started: bool = False) -> Union[NamedTuple, Tuple, List, Any]:\n    \"\"\"Internal helper to convert objects or their contents to a namedtuple.\n\n    This function uses functools.singledispatch to handle different types.\n    The `_started` parameter is used internally to distinguish between the\n    initial call to `to_namedtuple` and recursive calls, affecting error\n    handling for non-convertible top-level inputs.\n    \"\"\"\n    # Default behavior for types not specifically registered:\n    # If called recursively, return the object as is (it's not a container\n    # type we can convert further into a NamedTuple).\n    # If it's an initial call with a type not in _AllowedTypes (which should\n    # ideally be caught by type hints), it will also be returned as is.\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(obj: Mapping, _started: bool = False) -> Union[NamedTuple, Tuple]:\n    \"\"\"Handler for Mapping types (e.g., dict, OrderedDict), converting them to NamedTuples.\"\"\"\n    keys = []\n    for key in obj.keys():\n        if isinstance(key, str):\n            try:\n                # Validate identifier: cannot start with underscore, must be a valid Python identifier.\n                # Keys that are not valid will be skipped as per the docstring.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # If the key is not a valid identifier for a NamedTuple attribute, skip it.\n                continue\n            keys.append(key)\n\n    # Sort keys alphabetically if the original object is not an OrderedDict.\n    # Otherwise, preserve the original order.\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    else:\n        # Convert to tuple for immutability required by namedtuple creation.\n        keys = tuple(keys)\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert the values.\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create the NamedTuple with the collected valid keys and converted values.\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        out: NamedTuple = make(*args)\n        return out\n\n    # If no valid keys were found, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)\ndef _(obj: Sequence, _started: bool = False) -> Union[List[Any], Tuple[Any, ...], NamedTuple]:\n    \"\"\"Handler for Sequence types (e.g., list, tuple, existing NamedTuple),\n    recursively converting items to NamedTuples where applicable.\n    \"\"\"\n    if isinstance(obj, str):\n        # Strings are sequences but are treated as atomic values.\n        # If a string is passed as the *initial* object to `to_namedtuple`,\n        # it's considered an invalid top-level input as per flutils' design\n        # and raises a TypeError.\n        # For recursive calls (`_started=True`), strings are returned as is.\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n\n    if hasattr(obj, '_fields'):\n        # If the object has '_fields', it's likely an existing NamedTuple.\n        # We reconstruct it, ensuring its fields are also recursively converted.\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)  # Cast for type checking\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)  # Recursively convert fields\n                args.append(val)\n            if args:\n                # Reconstruct the NamedTuple with converted values.\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                out: NamedTuple = make(*args)\n                return out\n        # Return the original NamedTuple if it has no fields or couldn't be reconstructed.\n        return obj\n\n    # Handle general sequences (list, tuple).\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)  # Recursively convert each item in the sequence\n        out.append(val)\n\n    # Return a tuple if the original object was not mutable (e.g., a tuple),\n    # otherwise return a list (e.g., if the original was a list).\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)\ndef _(obj: SimpleNamespace, _started: bool = False) -> NamedTuple:\n    \"\"\"Handler for SimpleNamespace types, converting them to NamedTuples.\"\"\"\n    keys = []\n    # Iterate over the attributes of SimpleNamespace, which are stored in its __dict__.\n    for key in obj.__dict__.keys():\n        if isinstance(key, str):\n            try:\n                # Validate identifier: attributes starting with an underscore cannot be used.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # Skip attributes that are not valid identifiers for NamedTuple.\n                continue\n            keys.append(key)\n\n    # SimpleNamespace attributes are always sorted alphabetically in the returned NamedTuple.\n    keys = tuple(sorted(keys))\n\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)  # Access attribute value using getattr.\n        val = _to_namedtuple(val, _started=True)  # Recursively convert values.\n        args.append(val)\n\n    if args:\n        # Create the NamedTuple with the sorted valid keys and converted values.\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n\n    # If no valid attributes, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Dispatch the call to the internal singledispatch function.\n    # The _started parameter is False for the initial public call.\n    return _to_namedtuple(obj)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n@singledispatch\ndef _to_namedtuple(obj: Any, _started: bool = False) -> Any:\n    \"\"\"Helper for converting objects to namedtuples recursively.\"\"\"\n    return obj\n\n@_to_namedtuple.register(Mapping)\ndef _to_namedtuple_from_mapping(obj: Mapping, _started: bool = False) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                # Validate the key as a proper identifier, disallowing leading underscores\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # If the key is not a valid identifier or starts with an underscore, skip it\n                continue\n            if key.isidentifier(): # Redundant after validate_identifier, but preserves context logic\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))  # Sort keys alphabetically for non-OrderedDicts\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)  # Recursively convert values\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid arguments/keys, return an empty NamedTuple\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n@_to_namedtuple.register(Sequence)\ndef _to_namedtuple_from_sequence(obj: Sequence, _started: bool = False) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        # This branch handles string-like objects.\n        # If it's the initial call (not recursive) and `obj` is a string, it's an invalid top-level type.\n        # Otherwise, if it's a nested string, return it as is.\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict', 'NamedTuple', 'SimpleNamespace' \"\n                \"to a NamedTuple; got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n\n    if hasattr(obj, '_fields'):\n        # This branch handles NamedTuple objects.\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)  # Recursively convert attributes\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        # If the NamedTuple has no fields or no converted arguments, return the original object.\n        return obj\n\n    # This branch handles general sequence types like list and tuple.\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)  # Recursively convert items\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        # If the original object does not have an 'append' method (e.g., tuple),\n        # return a new tuple.\n        return tuple(out)\n    # If the original object has an 'append' method (e.g., list),\n    # return a new list.\n    return out\n\n@_to_namedtuple.register(SimpleNamespace)\ndef _to_namedtuple_from_simplenamespace(obj: SimpleNamespace, _started: bool = False) -> NamedTuple:\n    keys = []\n    # Use vars() to get the instance's own attributes.\n    for key, val in vars(obj).items():\n        try:\n            # Validate the attribute name as a proper identifier, disallowing leading underscores\n            validate_identifier(key, allow_underscore=False)\n            keys.append(key)\n        except SyntaxError:\n            # If the attribute name is not a valid identifier or starts with an underscore, skip it.\n            continue\n    keys.sort()  # Sort attributes alphabetically as per docstring\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)\n        val = _to_namedtuple(val, _started=True)  # Recursively convert attribute values\n        args.append(val)\n    if args:\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid attributes, return an empty NamedTuple\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj, _started=False)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\n@singledispatch\ndef _to_namedtuple_recursive(obj: Any, _started: bool = False) -> Any:\n    \"\"\"\n    Internal recursive helper for to_namedtuple.\n\n    This is a singledispatch generic function that dispatches based on the type\n    of `obj`. It handles recursive conversion of elements within collections.\n\n    Args:\n        obj: The object to be processed.\n        _started (bool): Internal flag, True if this is a recursive call.\n                         Used to prevent certain TypeErrors on initial call.\n    Returns:\n        The converted object or the original object if no conversion is needed.\n    \"\"\"\n    return obj\n\n\n@_to_namedtuple_recursive.register(Mapping)\ndef _to_namedtuple_from_mapping(\n    obj: Mapping,\n    _started: bool = False\n) -> NamedTuple:\n    \"\"\"\n    Converts a Mapping object (e.g., dict, OrderedDict) to a NamedTuple.\n\n    Keys that are valid Python identifiers and do not start with an underscore\n    become attributes of the NamedTuple. Keys are sorted alphabetically\n    unless the original object is an OrderedDict.\n    Values are recursively converted.\n    \"\"\"\n    keys = []\n    for key in obj.keys():\n        if isinstance(key, str):\n            try:\n                # Validate identifier as per docstring: no leading underscore, valid Python ID.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # Skip keys that are not valid identifiers or start with an underscore.\n                continue\n            # Redundant check but maintained for consistency with context function logic:\n            if key.isidentifier():\n                keys.append(key)\n\n    if not isinstance(obj, OrderedDict):\n        # Docstring: \"attributes of the returned NamedTuple are sorted alphabetically.\"\n        keys = tuple(sorted(keys))\n    else:\n        # Docstring: \"attributes ... keep the same order as the given OrderedDict keys.\"\n        keys = tuple(keys)\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert values\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create a NamedTuple with 'NamedTuple' as its type name.\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid keys were found.\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\n@_to_namedtuple_recursive.register(Sequence)\ndef _to_namedtuple_from_sequence(\n    obj: Sequence,\n    _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple]:\n    \"\"\"\n    Converts a Sequence object (e.g., list, tuple, NamedTuple) by recursively\n    converting its items. The original container type (list/tuple) is preserved.\n    \"\"\"\n    # Specific handling for strings passed as Sequences.\n    # The public 'to_namedtuple' function's _AllowedTypes excludes 'str',\n    # so this check primarily applies if this internal function is called\n    # directly with a string when _started is False, or to string elements\n    # during recursion.\n    if isinstance(obj, str):\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict', 'NamedTuple', 'SimpleNamespace' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return cast(str, obj)\n\n    # Handling for NamedTuple objects (which are also Sequences).\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                # Recursively convert attribute values\n                val = _to_namedtuple_recursive(val, _started=True)\n                args.append(val)\n            if args:\n                make = namedtuple('NamedTuple', fields)\n                out: NamedTuple = make(*args)\n                return out\n        # If NamedTuple has no fields or values, return it as is.\n        return obj\n\n    # Handling for general Sequences (list, tuple, etc.).\n    out = []\n    for item in obj:\n        # Recursively convert each item in the sequence.\n        val = _to_namedtuple_recursive(item, _started=True)\n        out.append(val)\n\n    # If the original object was a tuple-like (no 'append' method), return a tuple.\n    # Otherwise (e.g., list), return a list.\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple_recursive.register(SimpleNamespace)\ndef _to_namedtuple_from_simplenamespace(\n    obj: SimpleNamespace,\n    _started: bool = False\n) -> NamedTuple:\n    \"\"\"\n    Converts a SimpleNamespace object to a NamedTuple.\n\n    Attributes of the SimpleNamespace are converted to NamedTuple attributes,\n    sorted alphabetically. Only attributes with valid Python identifiers\n    (not starting with an underscore) are included.\n    Values are recursively converted.\n    \"\"\"\n    keys = []\n    # Docstring: \"attributes are sorted alphabetically\" for SimpleNamespace.\n    # Iterate over sorted keys from __dict__.\n    for key in sorted(obj.__dict__.keys()):\n        if isinstance(key, str):\n            try:\n                # Validate identifier.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)  # Access value via getattr for SimpleNamespace.\n        # Recursively convert values.\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    if args:\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid attributes were found.\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple}>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple}>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # The public entry point, calls the internal recursive dispatcher\n    # with _started=False to indicate it's the initial call.\n    return _to_namedtuple_recursive(obj, _started=False)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n# The file content already provides these imports and definitions\n# __all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\n@singledispatch\ndef _to_namedtuple_dispatcher(obj: Any, _started: bool = False) -> Any:\n    \"\"\"Internal dispatcher for recursively converting objects to NamedTuple.\"\"\"\n    # This is the default case for types not explicitly registered.\n    # It's primarily used for recursive calls where the value might be\n    # a basic type (int, str, float, etc.) that cannot be converted further\n    # into a NamedTuple. In such cases, the object is returned as is.\n    return obj\n\n\n@_to_namedtuple_dispatcher.register(Mapping)\ndef _convert_mapping_to_namedtuple(\n    obj: Mapping, _started: bool = False\n) -> NamedTuple:\n    \"\"\"Converts a Mapping (like dict or OrderedDict) to a NamedTuple.\"\"\"\n    keys = []\n    for key in obj.keys():\n        # Ensure key is string-like before validation\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                # Validate identifier, disallowing underscores at the start\n                # and filtering out invalid names, keywords, etc.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            # Double-check if it's a valid identifier after validation\n            if key.isidentifier():\n                keys.append(key)\n\n    # Sort keys alphabetically, unless the original object is an OrderedDict\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    else:\n        keys = tuple(keys) # Keep original order for OrderedDict\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert values using the dispatcher\n        val = _to_namedtuple_dispatcher(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create and return the NamedTuple\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid keys are found\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\n@_to_namedtuple_dispatcher.register(Sequence)\ndef _convert_sequence_to_namedtuple(\n    obj: Sequence, _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple]:\n    \"\"\"Converts a Sequence (list, tuple, NamedTuple) to a list or tuple of NamedTuples.\"\"\"\n    # Handle string-like objects specifically. Strings are sequences but\n    # should not be converted to NamedTuples themselves.\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            # If it's an initial call and the object is a string, raise an error\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj  # For recursive calls, return string as is\n\n    # Handle NamedTuple objects: recursively convert their fields\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                # Recursively convert attribute values\n                val = _to_namedtuple_dispatcher(val, _started=True)\n                args.append(val)\n            if args:\n                # Reconstruct the NamedTuple\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj  # Return original NamedTuple if it has no fields\n\n    # Handle other sequence types (list, tuple)\n    out = []\n    for item in obj:\n        # Recursively convert each item in the sequence\n        val = _to_namedtuple_dispatcher(item, _started=True)\n        out.append(val)\n\n    # Return a tuple if the original object was not a list (e.g., tuple)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out  # Return a list if the original object was a list\n\n\n@_to_namedtuple_dispatcher.register(SimpleNamespace)\ndef _convert_simplenamespace_to_namedtuple(\n    obj: SimpleNamespace, _started: bool = False\n) -> NamedTuple:\n    \"\"\"Converts a SimpleNamespace object to a NamedTuple.\"\"\"\n    # Get attributes as a dictionary\n    items = vars(obj)\n\n    keys = []\n    for key in items.keys():\n        # Ensure key is string-like\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                # Validate identifier, disallowing underscores at the start\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            # Double-check if it's a valid identifier after validation\n            if key.isidentifier():\n                keys.append(key)\n\n    # SimpleNamespace attributes are sorted alphabetically\n    keys = tuple(sorted(keys))\n\n    args = []\n    for key in keys:\n        val: Any = items[key]\n        # Recursively convert values\n        val = _to_namedtuple_dispatcher(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create and return the NamedTuple\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    else:\n        # Return an empty NamedTuple if no valid attributes are found\n        make_empty = namedtuple('NamedTuple', '')\n        out = make_empty()\n        return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n            If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n            recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n            provided the items can be converted. Items that cannot be converted\n            will still exist in the returned object.\n\n            If the given type is of :obj:`list` the return value will be a new\n            :obj:`list`.  This means the items are not changed in the given\n            ``obj``.\n\n            If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n            (:obj:`dict`), keys that can be proper identifiers will become attributes\n            on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n            the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n            are sorted alphabetically.\n\n            If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n            the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n            keep the same order as the given\n            :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n            If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n            The attributes are sorted alphabetically in the returned\n            :obj:`NamedTuple <collections.NamedTuple>`.\n\n            Any identifier (key or attribute name) that starts with an underscore\n            cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n            All values are recursively converted.  This means a dictionary that\n            contains another dictionary, as one of it's values, will be converted\n            to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n            value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n        A list with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n        A tuple with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    # This public function simply dispatches to the internal\n    # _to_namedtuple_dispatcher, ensuring that _started is False for the\n    # initial call.\n    return _to_namedtuple_dispatcher(obj, _started=False)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n# _AllowedTypes is defined in the provided File Content\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n@singledispatch\ndef _to_namedtuple_recursive(obj: Any, _started: bool = False) -> Any:\n    \"\"\"Internal recursive helper for to_namedtuple.\n\n    This function is decorated with @singledispatch to handle different\n    object types.\n    The '_started' parameter indicates if this is a recursive call (True)\n    or the initial call from the public 'to_namedtuple' function (False).\n    \"\"\"\n    # Default case: if the type of 'obj' is not explicitly registered,\n    # return the object as is. This covers types not convertible to NamedTuple\n    # but that might be nested within convertible structures (e.g., int, str).\n    return obj\n\n@_to_namedtuple_recursive.register(Mapping)\ndef _(obj: Mapping, _started: bool = False) -> Union[NamedTuple, Tuple]:\n    \"\"\"Convert a Mapping (like dict or OrderedDict) to a NamedTuple.\n\n    This implementation is based on Context Function 6.\n    \"\"\"\n    keys = []\n    for key in obj.keys():\n        # Ensure key is a string and validate it as an identifier suitable for NamedTuple.\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # If the key is not a valid identifier (e.g., starts with '_'), skip it.\n                continue\n            # The .isidentifier() check is redundant after validate_identifier,\n            # but is kept for consistency with the provided context function.\n            if key.isidentifier():\n                keys.append(key)\n\n    # Sort keys alphabetically if not an OrderedDict, otherwise keep original order.\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    else:\n        keys = tuple(keys) # Ensure it's a tuple for namedtuple fields\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert the value.\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    # Create and return the NamedTuple.\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid arguments/keys, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n@_to_namedtuple_recursive.register(SimpleNamespace)\ndef _(obj: SimpleNamespace, _started: bool = False) -> NamedTuple:\n    \"\"\"Convert a SimpleNamespace to a NamedTuple.\n\n    Attributes are sorted alphabetically in the returned NamedTuple.\n    \"\"\"\n    keys = []\n    # Iterate over the SimpleNamespace's attributes, which are in its __dict__.\n    for key in obj.__dict__.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier(): # Redundant check\n                keys.append(key)\n\n    # SimpleNamespace attributes are sorted alphabetically as per docstring.\n    keys = tuple(sorted(keys))\n\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)\n        # Recursively convert the attribute value.\n        val = _to_namedtuple_recursive(val, _started=True)\n        args.append(val)\n\n    if args:\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n    # If no valid attributes, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n@_to_namedtuple_recursive.register(NamedTuple)\ndef _(obj: NamedTuple, _started: bool = False) -> NamedTuple:\n    \"\"\"Recursively convert the fields of a NamedTuple.\n\n    This implementation is based on the 'if hasattr(obj, '_fields')' block\n    from Context Function 7, adapted for a direct NamedTuple registration.\n    \"\"\"\n    fields: List[str] = list(obj._fields)\n    if fields:\n        # obj is already guaranteed to be a NamedTuple by the type hint.\n        args = []\n        for attr in obj._fields:\n            val: Any = getattr(obj, attr)\n            # Recursively convert each field's value.\n            val = _to_namedtuple_recursive(val, _started=True)\n            args.append(val)\n        if args:\n            # Reconstruct the NamedTuple with the converted values.\n            # noinspection Mypy\n            make = namedtuple('NamedTuple', fields) # type: ignore[misc]\n            # noinspection PyTypeChecker,PyArgumentList\n            out: NamedTuple = make(*args)\n            return out\n    # If the NamedTuple has no fields or values (e.g., empty), return the original object.\n    return obj\n\n@_to_namedtuple_recursive.register(List)\n@_to_namedtuple_recursive.register(Tuple)\ndef _(obj: Union[List, Tuple], _started: bool = False) -> Union[List[Any], Tuple[Any, ...]]:\n    \"\"\"Recursively convert items within a List or Tuple.\n\n    This implementation is based on Context Function 7, but adapted to use\n    the _to_namedtuple_recursive dispatcher for sub-items and without the\n    NamedTuple-specific handling (as NamedTuple has its own register).\n    \"\"\"\n    # The 'str' handling from Context 7 (checking _started=False) is\n    # not directly needed here as the top-level `to_namedtuple` only\n    # accepts types from `_AllowedTypes`, which excludes `str`.\n    # If a `str` is encountered during recursion, it will fall to the default\n    # `_to_namedtuple_recursive` which simply returns the string as is.\n\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        # Recursively convert each item in the list or tuple.\n        val = _to_namedtuple_recursive(item, _started=True)\n        out.append(val)\n\n    # Return a tuple if the original object was tuple-like, otherwise a list.\n    if not hasattr(obj, 'append'): # Lists have 'append', tuples do not.\n        return tuple(out)\n    return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n             a :obj:`NamedTuple <collections.namedtuple>`.\n\n        If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n        recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n        provided the items can be converted. Items that cannot be converted\n        will still exist in the returned object.\n\n        If the given type is of :obj:`list` the return value will be a new\n        :obj:`list`.  This means the items are not changed in the given\n        ``obj``.\n\n        If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n        (:obj:`dict`), keys that can be proper identifiers will become attributes\n        on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n        the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n        are sorted alphabetically.\n\n        If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n        the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n        keep the same order as the given\n        :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n        If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n        The attributes are sorted alphabetically in the returned\n        :obj:`NamedTuple <collections.NamedTuple>`.\n\n        Any identifier (key or attribute name) that starts with an underscore\n        cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n        All values are recursively converted.  This means a dictionary that\n        contains another dictionary, as one of it's values, will be converted\n        to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n        value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n        A list with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n        A tuple with any of it's values converted to a\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Delegate the conversion to the internal singledispatch helper function.\n    # The `_started` parameter defaults to False for the initial call.\n    return _to_namedtuple_recursive(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom functools import singledispatch\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nfrom flutils.validators import validate_identifier\n\n__all__ = ['to_namedtuple']\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\n@singledispatch\ndef _to_namedtuple(obj: Any, _started: bool = False) -> Union[NamedTuple, Tuple, List, Any]:\n    \"\"\"Internal helper to convert objects or their contents to a namedtuple.\n\n    This function uses functools.singledispatch to handle different types.\n    The `_started` parameter is used internally to distinguish between the\n    initial call to `to_namedtuple` and recursive calls, affecting error\n    handling for non-convertible top-level inputs.\n    \"\"\"\n    # Default behavior for types not specifically registered:\n    # If called recursively, return the object as is (it's not a container\n    # type we can convert further into a NamedTuple).\n    # If it's an initial call with a type not in _AllowedTypes (which should\n    # ideally be caught by type hints), it will also be returned as is.\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(obj: Mapping, _started: bool = False) -> Union[NamedTuple, Tuple]:\n    \"\"\"Handler for Mapping types (e.g., dict, OrderedDict), converting them to NamedTuples.\"\"\"\n    keys = []\n    for key in obj.keys():\n        if isinstance(key, str):\n            try:\n                # Validate identifier: cannot start with underscore, must be a valid Python identifier.\n                # Keys that are not valid will be skipped as per the docstring.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # If the key is not a valid identifier for a NamedTuple attribute, skip it.\n                continue\n            keys.append(key)\n\n    # Sort keys alphabetically if the original object is not an OrderedDict.\n    # Otherwise, preserve the original order.\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    else:\n        # Convert to tuple for immutability required by namedtuple creation.\n        keys = tuple(keys)\n\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        # Recursively convert the values.\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n\n    if args:\n        # Create the NamedTuple with the collected valid keys and converted values.\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        out: NamedTuple = make(*args)\n        return out\n\n    # If no valid keys were found, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)\ndef _(obj: Sequence, _started: bool = False) -> Union[List[Any], Tuple[Any, ...], NamedTuple]:\n    \"\"\"Handler for Sequence types (e.g., list, tuple, existing NamedTuple),\n    recursively converting items to NamedTuples where applicable.\n    \"\"\"\n    if isinstance(obj, str):\n        # Strings are sequences but are treated as atomic values.\n        # If a string is passed as the *initial* object to `to_namedtuple`,\n        # it's considered an invalid top-level input as per flutils' design\n        # and raises a TypeError.\n        # For recursive calls (`_started=True`), strings are returned as is.\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n\n    if hasattr(obj, '_fields'):\n        # If the object has '_fields', it's likely an existing NamedTuple.\n        # We reconstruct it, ensuring its fields are also recursively converted.\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)  # Cast for type checking\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)  # Recursively convert fields\n                args.append(val)\n            if args:\n                # Reconstruct the NamedTuple with converted values.\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                out: NamedTuple = make(*args)\n                return out\n        # Return the original NamedTuple if it has no fields or couldn't be reconstructed.\n        return obj\n\n    # Handle general sequences (list, tuple).\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)  # Recursively convert each item in the sequence\n        out.append(val)\n\n    # Return a tuple if the original object was not mutable (e.g., a tuple),\n    # otherwise return a list (e.g., if the original was a list).\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)\ndef _(obj: SimpleNamespace, _started: bool = False) -> NamedTuple:\n    \"\"\"Handler for SimpleNamespace types, converting them to NamedTuples.\"\"\"\n    keys = []\n    # Iterate over the attributes of SimpleNamespace, which are stored in its __dict__.\n    for key in obj.__dict__.keys():\n        if isinstance(key, str):\n            try:\n                # Validate identifier: attributes starting with an underscore cannot be used.\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                # Skip attributes that are not valid identifiers for NamedTuple.\n                continue\n            keys.append(key)\n\n    # SimpleNamespace attributes are always sorted alphabetically in the returned NamedTuple.\n    keys = tuple(sorted(keys))\n\n    args = []\n    for key in keys:\n        val: Any = getattr(obj, key)  # Access attribute value using getattr.\n        val = _to_namedtuple(val, _started=True)  # Recursively convert values.\n        args.append(val)\n\n    if args:\n        # Create the NamedTuple with the sorted valid keys and converted values.\n        make = namedtuple('NamedTuple', keys)\n        out: NamedTuple = make(*args)\n        return out\n\n    # If no valid attributes, return an empty NamedTuple.\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Dispatch the call to the internal singledispatch function.\n    # The _started parameter is False for the initial public call.\n    return _to_namedtuple(obj)\n\n\n@singledispatch\ndef _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj\n\n\n@_to_namedtuple.register(Mapping)\ndef _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out\n\n\n@_to_namedtuple.register(Sequence)  # type: ignore[no-redef]\ndef _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out\n\n\n@_to_namedtuple.register(SimpleNamespace)  # type: ignore[no-redef]\ndef _(\n        obj: SimpleNamespace,\n        _started: bool = False\n) -> NamedTuple:\n    return _to_namedtuple(obj.__dict__)\n\n\nimport pickle\ndef test_0():\n    assert () == to_namedtuple(tuple())\ntest_0()\n\ndef test_1():\n    assert to_namedtuple((1,2,3)) == (1, 2, 3)\ntest_1()\n\ndef test_2():\n    assert 4 == len(to_namedtuple((1, 2, 3, 4)))\ntest_2()\n\ndef test_3():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_3()\n\ndef test_8():\n    assert to_namedtuple(namedtuple('A', ('a',))(a=1)) == namedtuple('A', ('a',))(a=1)\ntest_8()\n\ndef test_10():\n    assert to_namedtuple([]) == []\ntest_10()\n\ndef test_11():\n    assert isinstance(to_namedtuple(({'a': 1}, {'b': 2}, {'c': 3})), tuple)\ntest_11()\n\ndef test_12():\n    assert isinstance(to_namedtuple([{'a': 1}, {'b': 2}, {'c': 3}]), list)\ntest_12()\n\ndef test_13():\n    assert to_namedtuple((1, 2)) == (1, 2)\ntest_13()\n\ndef test_15():\n    assert isinstance(to_namedtuple([{'a': 1, 'b': 2}]), list)\ntest_15()\n\ndef test_18():\n    assert isinstance(\n        to_namedtuple([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]),\n        list\n    )\ntest_18()\n\ndef test_20():\n    assert isinstance(\n        to_namedtuple({'a': 1, 'b': 2}).a,\n        int\n    )\ntest_20()\n\ndef test_25():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).first,\n        int\n    )\ntest_25()\n\ndef test_26():\n    assert (1,) == to_namedtuple((1,))\ntest_26()\n\ndef test_27():\n    assert to_namedtuple([(1, 2), (3, 4)]) == [(1, 2), (3, 4)]\ntest_27()\n\ndef test_29():\n    assert to_namedtuple([{1,2,3}]) == [frozenset({1, 2, 3})]\ntest_29()\n\ndef test_49():\n    assert not isinstance(to_namedtuple({'a': {'b': 2}, 'c': 3}), list)\ntest_49()\n\ndef test_50():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).first,\n        int\n    )\ntest_50()\n\ndef test_51():\n    assert isinstance(\n        to_namedtuple(\n            OrderedDict(\n                [\n                    ('first', 1),\n                    ('second', 2),\n                ]\n            )\n        ).second,\n        int\n    )\ntest_51()\n\ndef test_52():\n    assert 1 == len(to_namedtuple({'a': 1}))\ntest_52()\n\ndef test_56():\n    assert isinstance(\n        to_namedtuple(({'a': 1, 'b': 2}, {'c': 3, 'd': 4})),\n        tuple\n    )\ntest_56()\n\ndef test_62():\n    assert isinstance(\n        to_namedtuple(\n            [\n                OrderedDict(\n                    [\n                        ('first', 1),\n                        ('second', 2),\n                    ]\n                ),\n                SimpleNamespace(\n                    first=1,\n                    second=2,\n                ),\n            ]\n        ),\n        list\n    )\ntest_62()\n\ndef test_64():\n    assert isinstance(\n        to_namedtuple(\n            SimpleNamespace(\n                first=1,\n                second=2,\n            )\n        ).second,\n        int\n    )\ntest_64()\n\ndef test_66():\n    assert to_namedtuple([1, 2, 3]) == [1, 2, 3]\ntest_66()\n\ndef test_68():\n    assert 4 == len(to_namedtuple([1, 2, 3, 4]))\ntest_68()\n\ndef test_69():\n    assert to_namedtuple(()) == ()\ntest_69()\n\ndef test_73():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2}))\ntest_73()\n\ndef test_76():\n    assert isinstance(to_namedtuple(({'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_76()\n\ndef test_86():\n    assert isinstance(to_namedtuple([{'_a': 1, 'b': 2}, {'a': 3, 'b': 4}, ]), list)\ntest_86()\n\ndef test_88():\n    assert to_namedtuple([1, 2]) == [1, 2]\ntest_88()\n\ndef test_91():\n    assert isinstance(to_namedtuple((1, 2, 3)), Tuple)\ntest_91()\n\ndef test_94():\n    assert 2 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c'}))\ntest_94()\n\ndef test_95():\n    assert 4 == len(to_namedtuple([1, 2, 'three', 4]))\ntest_95()\n\ndef test_96():\n    assert (1, 2) == to_namedtuple((1, 2))\ntest_96()\n\ndef test_100():\n    assert () == to_namedtuple(())\ntest_100()\n\ndef test_101():\n    assert 4 == len(to_namedtuple((1, 2, 'three', 4)))\ntest_101()\n\ndef test_103():\n    assert 3 == len(to_namedtuple({'a': 1, 'b': 2, 3: 'c', 'd': 4}))\ntest_103()\n\ndef test_108():\n    assert isinstance(to_namedtuple(({'a': 1, 'b': 2}, {'a': 3, 'b': 4}, )), tuple)\ntest_108()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3)) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple({1: 'a', 2: 'b', 'three': 3, 4: 'd'})) == output\ntest_6()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(to_namedtuple(OrderedDict([(1, 'a'), (2, 'b'), ('three', 3), (4, 'd')]))) == output\ntest_36()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1]) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2, 3, 4, 5]) == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1,2,3]) == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': 1, 'b': 2}), dict) == output\ntest_46()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(\n        (set(dir(to_namedtuple(\n            {'a': 1, 'b': 2}\n        )))) - set(dir(object))\n    ) == output\ntest_72()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([]) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(to_namedtuple({'_a': {'a': 1, 'b': 2}, 'b': {'a': 3, 'b': 4}, }), dict) == output\ntest_83()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple((1, 2, 3, 4, 5)) == output\ntest_93()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple(tuple(set([1, 2, 3, 4, 5]))) == output\ntest_97()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+namedtupleutils/to_namedtuple/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert to_namedtuple([1, 2]) == output\ntest_102()\n\n\n"]}
{"task_id": 127, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["from flutils.strutils import convert_escaped_utf8_literal\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    _foreign_name = convert_escaped_utf8_literal(foreign_name)\n    _foreign_name_stripped = _foreign_name.strip()\n\n    if not _foreign_name_stripped:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"The foreign-name cannot be empty or consist only of whitespace.\"\n        )\n\n    # Initialize final variables.\n    # final_attr_name will be set by alias or derived later.\n    final_attr_name: str\n    final_mod_name: str\n    final_mod_attr_name: str = '' # Default: no specific attribute, implying import of entire module\n\n    target_spec: str # The part after ' = ' or the whole string if no alias\n\n    # Step 1: Parse the alias part if present.\n    parts_by_eq = _foreign_name_stripped.split('=', 1)\n    if len(parts_by_eq) == 2:\n        # Case: alias = module.path.to[.attribute]\n        alias_candidate = parts_by_eq[0].strip()\n        target_spec = parts_by_eq[1].strip()\n\n        if not alias_candidate:\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"The alias part cannot be empty when '=' is used.\"\n            )\n        if not target_spec:\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"The module specification part cannot be empty when '=' is used.\"\n            )\n        # Validate and set final_attr_name from the alias.\n        final_attr_name = _validate_attr_identifier(alias_candidate, foreign_name)\n    else:\n        # Case: module.path.to[.attribute] (no alias)\n        target_spec = _foreign_name_stripped\n        # final_attr_name will be derived after final_mod_name and final_mod_attr_name are determined.\n\n    # Step 2: Determine final_mod_name and final_mod_attr_name from target_spec.\n    # This logic assumes that if the target_spec contains a dot AND the part\n    # after the last dot is a non-empty, valid identifier, it represents an attribute.\n    # Otherwise, the entire target_spec is considered the module name.\n    parts_by_dot = target_spec.rsplit('.', 1)\n\n    if len(parts_by_dot) == 2:\n        mod_name_candidate_prefix = parts_by_dot[0].strip()\n        attr_name_candidate_suffix = parts_by_dot[1].strip()\n\n        if not mod_name_candidate_prefix:\n             raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Module path cannot start with a dot (e.g., '.attribute').\"\n            )\n\n        # Check if suffix is a valid identifier. If it is, then it's treated as an attribute to be imported.\n        is_suffix_a_valid_attribute = True\n        try:\n            if not attr_name_candidate_suffix:\n                # Suffix is empty (e.g., 'foo.') - this means no attribute explicitly specified after dot.\n                # Treat the entire target_spec as the module name.\n                is_suffix_a_valid_attribute = False\n            else:\n                # _validate_attr_identifier raises AttributeError if invalid.\n                _validate_attr_identifier(attr_name_candidate_suffix, foreign_name)\n        except AttributeError:\n            is_suffix_a_valid_attribute = False\n\n        if is_suffix_a_valid_attribute:\n            final_mod_name = mod_name_candidate_prefix\n            final_mod_attr_name = attr_name_candidate_suffix\n        else:\n            # Suffix is not a valid attribute identifier or was empty.\n            # Treat the entire target_spec as the module name, no specific attribute.\n            final_mod_name = target_spec\n            final_mod_attr_name = '' # Import entire module\n    else:\n        # No dot found in target_spec (e.g., 'os').\n        # Treat entire target_spec as the module name, no specific attribute.\n        final_mod_name = target_spec\n        final_mod_attr_name = ''\n\n    if not final_mod_name:\n         raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"The module name cannot be empty.\"\n        )\n\n    # Step 3: If not already set by alias, determine the final_attr_name.\n    # 'final_attr_name' will only exist in locals() if an alias was present from Step 1.\n    if 'final_attr_name' not in locals():\n        if final_mod_attr_name:\n            # If a specific attribute was identified (e.g., 'os.path.join'),\n            # the attr_name is that attribute's name.\n            final_attr_name = _validate_attr_identifier(final_mod_attr_name, foreign_name)\n        else:\n            # If the entire module is being picked (e.g., 'os.path' or 'os'),\n            # the attr_name is the last segment of the module's full name.\n            derived_attr_name = final_mod_name.rsplit('.', 1)[-1].strip()\n            if not derived_attr_name:\n                raise AttributeError(\n                    f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                    \"Cannot derive attribute name from an empty or invalid module segment.\"\n                )\n            final_attr_name = _validate_attr_identifier(derived_attr_name, foreign_name)\n\n    # Step 4: Final Validation of all segments of the determined module name.\n    # This catches cases like 'foo..bar' or '..foo', and ensures each segment is a valid identifier.\n    for segment in final_mod_name.split('.'):\n        if not segment:\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Module name segments cannot be empty (e.g., 'foo..bar').\"\n            )\n        # Call _validate_attr_identifier on each segment. It raises AttributeError on failure.\n        _validate_attr_identifier(segment, foreign_name)\n\n    return _AttrMapping(\n        attr_name=final_attr_name,\n        mod_name=final_mod_name,\n        mod_attr_name=final_mod_attr_name,\n        item=foreign_name # Store the original un-expanded item for reference\n    )", "import keyword\nfrom typing import NamedTuple, Union\nfrom collections import UserString\n\n# The following are already defined in the provided file content:\n# from typing import (Any, DefaultDict, Dict, Generator, List, NamedTuple, Optional, Set, Tuple, Union, cast,)\n# _STRIPPED_DUNDERS, _DUNDERS, _BUILTIN_NAMES\n# _validate_attr_identifier (context function 3, already in file content)\n# _AttrMapping (NamedTuple definition)\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n    The expected format is: `[<new_name>=]<module_path>[.<attribute_name>]`\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    foreign_name = foreign_name.strip()\n    if not foreign_name:\n        raise ValueError(\n            \"__attr_map__ contains an invalid item. The foreign-name cannot \"\n            \"be empty.\"\n        )\n\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n\n    parts_eq = foreign_name.split('=', 1)\n\n    if len(parts_eq) == 2:\n        # Case: 'NewName = module.attribute' or 'NewName = module'\n        attr_name_raw = parts_eq[0].strip()\n        target_raw = parts_eq[1].strip()\n\n        if not attr_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Missing attribute name before '='.\"\n            )\n        attr_name = _validate_attr_identifier(attr_name_raw, foreign_name)\n\n    else:\n        # Case: 'module.attribute' or 'module'\n        target_raw = foreign_name\n        attr_name = ''  # Placeholder, will be derived later\n\n    if not target_raw:\n        raise ValueError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"Missing target module or attribute.\"\n        )\n\n    parts_dot = target_raw.rsplit('.', 1)\n\n    if len(parts_dot) == 2:\n        # Case: 'module.attribute' (e.g., 'foo.bar.Baz')\n        mod_name_raw = parts_dot[0].strip()\n        mod_attr_name_raw = parts_dot[1].strip()\n\n        if not mod_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Missing module name before '.' in target.\"\n            )\n        if not mod_attr_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Missing attribute name after '.' in target.\"\n            )\n\n        # Validate each part of the module name (e.g., 'foo', 'bar' in 'foo.bar')\n        mod_name_parts = mod_name_raw.split('.')\n        validated_mod_name_parts = []\n        for part in mod_name_parts:\n            validated_part = _validate_attr_identifier(part, foreign_name)\n            if not validated_part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                    f\"Module name segment {part!r} cannot be empty or invalid.\"\n                )\n            validated_mod_name_parts.append(validated_part)\n        mod_name = \".\".join(validated_mod_name_parts)\n\n        mod_attr_name = _validate_attr_identifier(mod_attr_name_raw, foreign_name)\n\n        if not attr_name:\n            # If attr_name was not explicitly given, derive from mod_attr_name\n            attr_name = mod_attr_name\n\n    else:\n        # Case: 'module' (e.g., 'my_module')\n        mod_name_raw = target_raw.strip()\n        mod_attr_name = ''  # The entire module is being cherry-picked\n\n        if not mod_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Invalid module name in target.\"\n            )\n\n        # Validate each part of the module name (e.g., 'my_module' in 'my_module')\n        mod_name_parts = mod_name_raw.split('.')\n        validated_mod_name_parts = []\n        for part in mod_name_parts:\n            validated_part = _validate_attr_identifier(part, foreign_name)\n            if not validated_part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                    f\"Module name segment {part!r} cannot be empty or invalid.\"\n                )\n            validated_mod_name_parts.append(validated_part)\n        mod_name = \".\".join(validated_mod_name_parts)\n\n        if not attr_name:\n            # If attr_name was not explicitly given, derive from mod_name\n            attr_name = mod_name\n\n    # Final validation for attr_name in case it was derived.\n    # _validate_attr_identifier already strips, so pass the current attr_name.\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    if not attr_name:\n        raise ValueError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"Could not determine a valid attribute name.\"\n        )\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name\n    )", "import keyword\nfrom collections import UserString\nfrom typing import NamedTuple, Union\n\n# Import required context functions or types from their original modules\n# `_validate_attr_identifier` is already in the file content, so it's directly available.\n# `validate_identifier` needs an explicit import as it's from a different module (flutils.validators).\nfrom flutils.validators import validate_identifier\n\n# The following items are provided in the file content and are available in the current scope:\n# _BUILTIN_NAMES, _DUNDERS, _validate_attr_identifier, _AttrMapping\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    original_item = foreign_name.strip()\n    if not original_item:\n        raise ValueError(\n            \"__attr_map__ contains an empty or whitespace-only item.\"\n        )\n\n    # Initialize variables that will hold the parsed components\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n\n    # First, split by '=' to check for explicit attribute naming\n    parts = original_item.split('=', 1)\n\n    if len(parts) == 2:\n        # Format: 'attr_name = mod_name.mod_attr_name' or 'attr_name = mod_name'\n        attr_name = parts[0].strip()\n        source_part = parts[1].strip()\n\n        if not attr_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The left-hand side of '=' (attribute name) cannot be empty.\"\n            )\n        if not source_part:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The right-hand side of '=' (module source) cannot be empty.\"\n            )\n    else:\n        # Format: 'mod_name.mod_attr_name' or 'mod_name'\n        # In this case, attr_name will be derived later\n        attr_name = ''  # Will be populated after parsing source_part\n        source_part = original_item\n\n    # Next, parse the source_part to get mod_name and mod_attr_name\n    # Use rsplit to handle module names with multiple dots (e.g., 'os.path.join')\n    mod_parts = source_part.rsplit('.', 1)\n\n    if len(mod_parts) == 2:\n        # Format: 'module.attribute'\n        mod_name = mod_parts[0].strip()\n        mod_attr_name = mod_parts[1].strip()\n\n        if not mod_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The module name cannot be empty.\"\n            )\n        if not mod_attr_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The module attribute name cannot be empty when explicitly specified.\"\n            )\n    else:\n        # Format: 'module' (the entire module is cherry-picked)\n        mod_name = mod_parts[0].strip()\n        mod_attr_name = \"\"  # An empty string indicates the entire module\n\n        if not mod_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The module name cannot be empty.\"\n            )\n\n    # If attr_name was not explicitly set (i.e., no '=' in the foreign_name),\n    # derive it from the module's attribute or module name.\n    if not attr_name:\n        if mod_attr_name:\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name\n\n    # --- Validation ---\n    # Validate the target attribute name that will be set on the cherry-picking module.\n    # Uses the local `_validate_attr_identifier` for checks against keywords, built-ins, and dunders.\n    _validate_attr_identifier(attr_name, original_item)\n\n    # Validate the attribute name on the cherry-picked module, if specified.\n    if mod_attr_name:\n        _validate_attr_identifier(mod_attr_name, original_item)\n\n    # Validate each segment of the full module name (e.g., 'os', 'path', 'join' in 'os.path.join').\n    # Each segment must be a valid Python identifier.\n    # Using `flutils.validators.validate_identifier` for this.\n    for segment in mod_name.split('.'):\n        try:\n            # `validate_identifier` handles checks for empty strings, starting with numbers,\n            # being keywords, or built-in names.\n            validate_identifier(segment)\n        except SyntaxError as e:\n            raise SyntaxError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                f\"The module name '{mod_name}' contains an invalid segment \"\n                f\"'{segment!r}'. {e.msg}\" # Access .msg for the error message\n            ) from e\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=original_item\n    )", "import keyword\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n# Constants and utility function from the file content are implicitly available:\n# _STRIPPED_DUNDERS\n# _DUNDERS\n# _BUILTIN_NAMES\n# _validate_attr_identifier\n# _AttrMapping\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    original_item = foreign_name\n    foreign_name = foreign_name.strip()\n\n    if not foreign_name:\n        raise ValueError(\n            f\"__attr_map__ item cannot be empty or only whitespace: \"\n            f\"{original_item!r}\"\n        )\n\n    attr_name_out: str\n    mod_name_out: str\n    mod_attr_name_out: str\n\n    # 1. Check for assignment operator '='\n    parts_assign = foreign_name.split('=', 1)\n\n    if len(parts_assign) == 2:\n        # Case: `attr_name = module.mod_attr_name`\n        lhs_raw = parts_assign[0].strip()\n        rhs_raw = parts_assign[1].strip()\n\n        if not lhs_raw:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r} has an empty \"\n                f\"left-hand side before the '='.\"\n            )\n        attr_name_out = _validate_attr_identifier(lhs_raw, original_item)\n\n        if not rhs_raw:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r} has an empty \"\n                f\"right-hand side after the '='.\"\n            )\n        target_rhs = rhs_raw\n    else:\n        # Case: `module.mod_attr_name` or `module_name` (no explicit assignment)\n        attr_name_out = ''  # Will be determined later based on mod_attr_name or mod_name\n        target_rhs = foreign_name\n\n    # 2. Parse `target_rhs` into `mod_name_out` and `mod_attr_name_out`\n    mod_parts = target_rhs.rsplit('.', 1)\n\n    if len(mod_parts) == 2:\n        # Case: `module_path.mod_attr_name`\n        potential_mod_name = mod_parts[0].strip()\n        potential_mod_attr_name = mod_parts[1].strip()\n\n        if not potential_mod_name:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Module path \"\n                f\"cannot be empty before the last dot (e.g., '.attribute').\"\n            )\n        if not potential_mod_attr_name:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Attribute name \"\n                f\"cannot be empty after the last dot (e.g., 'module.').\"\n            )\n\n        mod_name_out = potential_mod_name\n        mod_attr_name_out = _validate_attr_identifier(potential_mod_attr_name, original_item)\n\n    else:\n        # Case: `module_name` (no attribute specified, only a module name)\n        potential_mod_name = mod_parts[0].strip()\n        if not potential_mod_name:\n            # This case should ideally be caught by the initial empty check or 'empty rhs' check\n            # for assignment, but added for robustness.\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Module name \"\n                f\"cannot be empty.\"\n            )\n        mod_name_out = potential_mod_name\n        mod_attr_name_out = '' # Empty string indicates that the entire module is cherry-picked\n\n    # 3. Validate `mod_name_out` parts (dotted path)\n    # Each segment of the module path (e.g., 'os' and 'path' in 'os.path')\n    # must be a valid identifier.\n    for part in mod_name_out.split('.'):\n        if not part: # Catches '..', leading '.', or trailing '.' in module path\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Dotted module path \"\n                f\"contains an empty segment (e.g., 'mod..sub' or '.mod').\"\n            )\n        # Call _validate_attr_identifier for its side-effect of raising errors\n        _validate_attr_identifier(part, original_item)\n\n    # 4. Determine `attr_name_out` if not explicitly assigned (i.e., if no '=' was in foreign_name)\n    if not parts_assign[0].strip() and len(parts_assign) == 1:\n        if mod_attr_name_out:\n            # If a specific attribute was named (e.g., \"os.path\"), use that as the local attr_name\n            attr_name_out = mod_attr_name_out\n        else:\n            # If only a module was named (e.g., \"my_module\"), use the module name as the local attr_name\n            attr_name_out = mod_name_out\n\n    return _AttrMapping(\n        attr_name=attr_name_out,\n        mod_name=mod_name_out,\n        mod_attr_name=mod_attr_name_out,\n        item=original_item\n    )", "import keyword\nfrom collections import UserString\nfrom typing import Union\n\n# The following classes and variables are assumed to be available from the file content:\n# _AttrMapping (NamedTuple)\n# _validate_attr_identifier (function)\n# _STRIPPED_DUNDERS, _DUNDERS, _BUILTIN_NAMES (tuples)\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    original_foreign_name = foreign_name  # Store for error messages\n    foreign_name_stripped = foreign_name.strip()\n\n    if not foreign_name_stripped:\n        raise ValueError(\n            f\"__attr_map__ contains an empty item. \"\n            f\"Cannot expand an empty foreign-name.\"\n        )\n\n    parts_eq = foreign_name_stripped.split('=')\n\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n\n    if len(parts_eq) == 2:\n        # Case: attr_name=module.mod_attr_name OR attr_name=module\n        attr_name = parts_eq[0].strip()\n        rhs = parts_eq[1].strip()\n\n        if not attr_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                f\"The attribute name before '=' cannot be empty.\"\n            )\n        if not rhs:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                f\"The module/attribute part after '=' cannot be empty.\"\n            )\n\n        # Validate attr_name (the alias)\n        _validate_attr_identifier(attr_name, original_foreign_name)\n\n        parts_dot = rhs.rsplit('.', 1)\n        if len(parts_dot) == 2:\n            # Case: attr_name=module.mod_attr_name (e.g., 'mypath=os.path')\n            mod_name = parts_dot[0].strip()\n            mod_attr_name = parts_dot[1].strip()\n\n            if not mod_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The module name cannot be empty.\"\n                )\n            if not mod_attr_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The attribute name after '.' cannot be empty.\"\n                )\n            # Validate mod_attr_name (the actual attribute name from the source module)\n            _validate_attr_identifier(mod_attr_name, original_foreign_name)\n\n        else:\n            # Case: attr_name=module (e.g., 'myos=os')\n            mod_name = rhs\n            mod_attr_name = ''\n\n        # Validate each component of the module name\n        for part in mod_name.split('.'):\n            if not part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"Module name contains an empty component (e.g., 'mod..sub' or '.mod').\"\n                )\n            _validate_attr_identifier(part, original_foreign_name)\n\n    elif len(parts_eq) == 1:\n        # Case: module.mod_attr_name OR module (e.g., 'os.path' or 'os')\n        rhs = foreign_name_stripped\n\n        parts_dot = rhs.rsplit('.', 1)\n        if len(parts_dot) == 2:\n            # Case: module.mod_attr_name (e.g., 'os.path')\n            mod_name = parts_dot[0].strip()\n            mod_attr_name = parts_dot[1].strip()\n\n            if not mod_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The module name cannot be empty.\"\n                )\n            if not mod_attr_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The attribute name after '.' cannot be empty.\"\n                )\n            # In 'from module import attribute', 'attribute' becomes both the module attribute\n            # and the attribute name on the cherry-picking module.\n            attr_name = mod_attr_name\n            _validate_attr_identifier(attr_name, original_foreign_name)\n            _validate_attr_identifier(mod_attr_name, original_foreign_name)\n\n        else:\n            # Case: module (e.g., 'os')\n            mod_name = rhs\n            attr_name = rhs\n            mod_attr_name = ''\n\n        # Validate each component of the module name\n        for part in mod_name.split('.'):\n            if not part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"Module name contains an empty component (e.g., 'mod..sub' or '.mod').\"\n                )\n            _validate_attr_identifier(part, original_foreign_name)\n\n    else:\n        # Case: More than one '=' (e.g., 'a=b=c')\n        raise ValueError(\n            f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n            f\"Multiple '=' characters are not allowed.\"\n        )\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=original_foreign_name\n    )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nfrom flutils.strutils import convert_escaped_utf8_literal\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    _foreign_name = convert_escaped_utf8_literal(foreign_name)\n    _foreign_name_stripped = _foreign_name.strip()\n\n    if not _foreign_name_stripped:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"The foreign-name cannot be empty or consist only of whitespace.\"\n        )\n\n    # Initialize final variables.\n    # final_attr_name will be set by alias or derived later.\n    final_attr_name: str\n    final_mod_name: str\n    final_mod_attr_name: str = '' # Default: no specific attribute, implying import of entire module\n\n    target_spec: str # The part after ' = ' or the whole string if no alias\n\n    # Step 1: Parse the alias part if present.\n    parts_by_eq = _foreign_name_stripped.split('=', 1)\n    if len(parts_by_eq) == 2:\n        # Case: alias = module.path.to[.attribute]\n        alias_candidate = parts_by_eq[0].strip()\n        target_spec = parts_by_eq[1].strip()\n\n        if not alias_candidate:\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"The alias part cannot be empty when '=' is used.\"\n            )\n        if not target_spec:\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"The module specification part cannot be empty when '=' is used.\"\n            )\n        # Validate and set final_attr_name from the alias.\n        final_attr_name = _validate_attr_identifier(alias_candidate, foreign_name)\n    else:\n        # Case: module.path.to[.attribute] (no alias)\n        target_spec = _foreign_name_stripped\n        # final_attr_name will be derived after final_mod_name and final_mod_attr_name are determined.\n\n    # Step 2: Determine final_mod_name and final_mod_attr_name from target_spec.\n    # This logic assumes that if the target_spec contains a dot AND the part\n    # after the last dot is a non-empty, valid identifier, it represents an attribute.\n    # Otherwise, the entire target_spec is considered the module name.\n    parts_by_dot = target_spec.rsplit('.', 1)\n\n    if len(parts_by_dot) == 2:\n        mod_name_candidate_prefix = parts_by_dot[0].strip()\n        attr_name_candidate_suffix = parts_by_dot[1].strip()\n\n        if not mod_name_candidate_prefix:\n             raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Module path cannot start with a dot (e.g., '.attribute').\"\n            )\n\n        # Check if suffix is a valid identifier. If it is, then it's treated as an attribute to be imported.\n        is_suffix_a_valid_attribute = True\n        try:\n            if not attr_name_candidate_suffix:\n                # Suffix is empty (e.g., 'foo.') - this means no attribute explicitly specified after dot.\n                # Treat the entire target_spec as the module name.\n                is_suffix_a_valid_attribute = False\n            else:\n                # _validate_attr_identifier raises AttributeError if invalid.\n                _validate_attr_identifier(attr_name_candidate_suffix, foreign_name)\n        except AttributeError:\n            is_suffix_a_valid_attribute = False\n\n        if is_suffix_a_valid_attribute:\n            final_mod_name = mod_name_candidate_prefix\n            final_mod_attr_name = attr_name_candidate_suffix\n        else:\n            # Suffix is not a valid attribute identifier or was empty.\n            # Treat the entire target_spec as the module name, no specific attribute.\n            final_mod_name = target_spec\n            final_mod_attr_name = '' # Import entire module\n    else:\n        # No dot found in target_spec (e.g., 'os').\n        # Treat entire target_spec as the module name, no specific attribute.\n        final_mod_name = target_spec\n        final_mod_attr_name = ''\n\n    if not final_mod_name:\n         raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"The module name cannot be empty.\"\n        )\n\n    # Step 3: If not already set by alias, determine the final_attr_name.\n    # 'final_attr_name' will only exist in locals() if an alias was present from Step 1.\n    if 'final_attr_name' not in locals():\n        if final_mod_attr_name:\n            # If a specific attribute was identified (e.g., 'os.path.join'),\n            # the attr_name is that attribute's name.\n            final_attr_name = _validate_attr_identifier(final_mod_attr_name, foreign_name)\n        else:\n            # If the entire module is being picked (e.g., 'os.path' or 'os'),\n            # the attr_name is the last segment of the module's full name.\n            derived_attr_name = final_mod_name.rsplit('.', 1)[-1].strip()\n            if not derived_attr_name:\n                raise AttributeError(\n                    f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                    \"Cannot derive attribute name from an empty or invalid module segment.\"\n                )\n            final_attr_name = _validate_attr_identifier(derived_attr_name, foreign_name)\n\n    # Step 4: Final Validation of all segments of the determined module name.\n    # This catches cases like 'foo..bar' or '..foo', and ensures each segment is a valid identifier.\n    for segment in final_mod_name.split('.'):\n        if not segment:\n            raise AttributeError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Module name segments cannot be empty (e.g., 'foo..bar').\"\n            )\n        # Call _validate_attr_identifier on each segment. It raises AttributeError on failure.\n        _validate_attr_identifier(segment, foreign_name)\n\n    return _AttrMapping(\n        attr_name=final_attr_name,\n        mod_name=final_mod_name,\n        mod_attr_name=final_mod_attr_name,\n        item=foreign_name # Store the original un-expanded item for reference\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nimport keyword\nfrom typing import NamedTuple, Union\nfrom collections import UserString\n\n# The following are already defined in the provided file content:\n# from typing import (Any, DefaultDict, Dict, Generator, List, NamedTuple, Optional, Set, Tuple, Union, cast,)\n# _STRIPPED_DUNDERS, _DUNDERS, _BUILTIN_NAMES\n# _validate_attr_identifier (context function 3, already in file content)\n# _AttrMapping (NamedTuple definition)\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n    The expected format is: `[<new_name>=]<module_path>[.<attribute_name>]`\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    foreign_name = foreign_name.strip()\n    if not foreign_name:\n        raise ValueError(\n            \"__attr_map__ contains an invalid item. The foreign-name cannot \"\n            \"be empty.\"\n        )\n\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n\n    parts_eq = foreign_name.split('=', 1)\n\n    if len(parts_eq) == 2:\n        # Case: 'NewName = module.attribute' or 'NewName = module'\n        attr_name_raw = parts_eq[0].strip()\n        target_raw = parts_eq[1].strip()\n\n        if not attr_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Missing attribute name before '='.\"\n            )\n        attr_name = _validate_attr_identifier(attr_name_raw, foreign_name)\n\n    else:\n        # Case: 'module.attribute' or 'module'\n        target_raw = foreign_name\n        attr_name = ''  # Placeholder, will be derived later\n\n    if not target_raw:\n        raise ValueError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"Missing target module or attribute.\"\n        )\n\n    parts_dot = target_raw.rsplit('.', 1)\n\n    if len(parts_dot) == 2:\n        # Case: 'module.attribute' (e.g., 'foo.bar.Baz')\n        mod_name_raw = parts_dot[0].strip()\n        mod_attr_name_raw = parts_dot[1].strip()\n\n        if not mod_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Missing module name before '.' in target.\"\n            )\n        if not mod_attr_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Missing attribute name after '.' in target.\"\n            )\n\n        # Validate each part of the module name (e.g., 'foo', 'bar' in 'foo.bar')\n        mod_name_parts = mod_name_raw.split('.')\n        validated_mod_name_parts = []\n        for part in mod_name_parts:\n            validated_part = _validate_attr_identifier(part, foreign_name)\n            if not validated_part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                    f\"Module name segment {part!r} cannot be empty or invalid.\"\n                )\n            validated_mod_name_parts.append(validated_part)\n        mod_name = \".\".join(validated_mod_name_parts)\n\n        mod_attr_name = _validate_attr_identifier(mod_attr_name_raw, foreign_name)\n\n        if not attr_name:\n            # If attr_name was not explicitly given, derive from mod_attr_name\n            attr_name = mod_attr_name\n\n    else:\n        # Case: 'module' (e.g., 'my_module')\n        mod_name_raw = target_raw.strip()\n        mod_attr_name = ''  # The entire module is being cherry-picked\n\n        if not mod_name_raw:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                \"Invalid module name in target.\"\n            )\n\n        # Validate each part of the module name (e.g., 'my_module' in 'my_module')\n        mod_name_parts = mod_name_raw.split('.')\n        validated_mod_name_parts = []\n        for part in mod_name_parts:\n            validated_part = _validate_attr_identifier(part, foreign_name)\n            if not validated_part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n                    f\"Module name segment {part!r} cannot be empty or invalid.\"\n                )\n            validated_mod_name_parts.append(validated_part)\n        mod_name = \".\".join(validated_mod_name_parts)\n\n        if not attr_name:\n            # If attr_name was not explicitly given, derive from mod_name\n            attr_name = mod_name\n\n    # Final validation for attr_name in case it was derived.\n    # _validate_attr_identifier already strips, so pass the current attr_name.\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    if not attr_name:\n        raise ValueError(\n            f\"__attr_map__ contains an invalid item of: {foreign_name!r}. \"\n            \"Could not determine a valid attribute name.\"\n        )\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nimport keyword\nfrom collections import UserString\nfrom typing import NamedTuple, Union\n\n# Import required context functions or types from their original modules\n# `_validate_attr_identifier` is already in the file content, so it's directly available.\n# `validate_identifier` needs an explicit import as it's from a different module (flutils.validators).\nfrom flutils.validators import validate_identifier\n\n# The following items are provided in the file content and are available in the current scope:\n# _BUILTIN_NAMES, _DUNDERS, _validate_attr_identifier, _AttrMapping\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    original_item = foreign_name.strip()\n    if not original_item:\n        raise ValueError(\n            \"__attr_map__ contains an empty or whitespace-only item.\"\n        )\n\n    # Initialize variables that will hold the parsed components\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n\n    # First, split by '=' to check for explicit attribute naming\n    parts = original_item.split('=', 1)\n\n    if len(parts) == 2:\n        # Format: 'attr_name = mod_name.mod_attr_name' or 'attr_name = mod_name'\n        attr_name = parts[0].strip()\n        source_part = parts[1].strip()\n\n        if not attr_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The left-hand side of '=' (attribute name) cannot be empty.\"\n            )\n        if not source_part:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The right-hand side of '=' (module source) cannot be empty.\"\n            )\n    else:\n        # Format: 'mod_name.mod_attr_name' or 'mod_name'\n        # In this case, attr_name will be derived later\n        attr_name = ''  # Will be populated after parsing source_part\n        source_part = original_item\n\n    # Next, parse the source_part to get mod_name and mod_attr_name\n    # Use rsplit to handle module names with multiple dots (e.g., 'os.path.join')\n    mod_parts = source_part.rsplit('.', 1)\n\n    if len(mod_parts) == 2:\n        # Format: 'module.attribute'\n        mod_name = mod_parts[0].strip()\n        mod_attr_name = mod_parts[1].strip()\n\n        if not mod_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The module name cannot be empty.\"\n            )\n        if not mod_attr_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The module attribute name cannot be empty when explicitly specified.\"\n            )\n    else:\n        # Format: 'module' (the entire module is cherry-picked)\n        mod_name = mod_parts[0].strip()\n        mod_attr_name = \"\"  # An empty string indicates the entire module\n\n        if not mod_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                \"The module name cannot be empty.\"\n            )\n\n    # If attr_name was not explicitly set (i.e., no '=' in the foreign_name),\n    # derive it from the module's attribute or module name.\n    if not attr_name:\n        if mod_attr_name:\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name\n\n    # --- Validation ---\n    # Validate the target attribute name that will be set on the cherry-picking module.\n    # Uses the local `_validate_attr_identifier` for checks against keywords, built-ins, and dunders.\n    _validate_attr_identifier(attr_name, original_item)\n\n    # Validate the attribute name on the cherry-picked module, if specified.\n    if mod_attr_name:\n        _validate_attr_identifier(mod_attr_name, original_item)\n\n    # Validate each segment of the full module name (e.g., 'os', 'path', 'join' in 'os.path.join').\n    # Each segment must be a valid Python identifier.\n    # Using `flutils.validators.validate_identifier` for this.\n    for segment in mod_name.split('.'):\n        try:\n            # `validate_identifier` handles checks for empty strings, starting with numbers,\n            # being keywords, or built-in names.\n            validate_identifier(segment)\n        except SyntaxError as e:\n            raise SyntaxError(\n                f\"__attr_map__ contains an invalid item of: {original_item!r}. \"\n                f\"The module name '{mod_name}' contains an invalid segment \"\n                f\"'{segment!r}'. {e.msg}\" # Access .msg for the error message\n            ) from e\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=original_item\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nimport keyword\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n# Constants and utility function from the file content are implicitly available:\n# _STRIPPED_DUNDERS\n# _DUNDERS\n# _BUILTIN_NAMES\n# _validate_attr_identifier\n# _AttrMapping\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    original_item = foreign_name\n    foreign_name = foreign_name.strip()\n\n    if not foreign_name:\n        raise ValueError(\n            f\"__attr_map__ item cannot be empty or only whitespace: \"\n            f\"{original_item!r}\"\n        )\n\n    attr_name_out: str\n    mod_name_out: str\n    mod_attr_name_out: str\n\n    # 1. Check for assignment operator '='\n    parts_assign = foreign_name.split('=', 1)\n\n    if len(parts_assign) == 2:\n        # Case: `attr_name = module.mod_attr_name`\n        lhs_raw = parts_assign[0].strip()\n        rhs_raw = parts_assign[1].strip()\n\n        if not lhs_raw:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r} has an empty \"\n                f\"left-hand side before the '='.\"\n            )\n        attr_name_out = _validate_attr_identifier(lhs_raw, original_item)\n\n        if not rhs_raw:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r} has an empty \"\n                f\"right-hand side after the '='.\"\n            )\n        target_rhs = rhs_raw\n    else:\n        # Case: `module.mod_attr_name` or `module_name` (no explicit assignment)\n        attr_name_out = ''  # Will be determined later based on mod_attr_name or mod_name\n        target_rhs = foreign_name\n\n    # 2. Parse `target_rhs` into `mod_name_out` and `mod_attr_name_out`\n    mod_parts = target_rhs.rsplit('.', 1)\n\n    if len(mod_parts) == 2:\n        # Case: `module_path.mod_attr_name`\n        potential_mod_name = mod_parts[0].strip()\n        potential_mod_attr_name = mod_parts[1].strip()\n\n        if not potential_mod_name:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Module path \"\n                f\"cannot be empty before the last dot (e.g., '.attribute').\"\n            )\n        if not potential_mod_attr_name:\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Attribute name \"\n                f\"cannot be empty after the last dot (e.g., 'module.').\"\n            )\n\n        mod_name_out = potential_mod_name\n        mod_attr_name_out = _validate_attr_identifier(potential_mod_attr_name, original_item)\n\n    else:\n        # Case: `module_name` (no attribute specified, only a module name)\n        potential_mod_name = mod_parts[0].strip()\n        if not potential_mod_name:\n            # This case should ideally be caught by the initial empty check or 'empty rhs' check\n            # for assignment, but added for robustness.\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Module name \"\n                f\"cannot be empty.\"\n            )\n        mod_name_out = potential_mod_name\n        mod_attr_name_out = '' # Empty string indicates that the entire module is cherry-picked\n\n    # 3. Validate `mod_name_out` parts (dotted path)\n    # Each segment of the module path (e.g., 'os' and 'path' in 'os.path')\n    # must be a valid identifier.\n    for part in mod_name_out.split('.'):\n        if not part: # Catches '..', leading '.', or trailing '.' in module path\n            raise ValueError(\n                f\"__attr_map__ item {original_item!r}: Dotted module path \"\n                f\"contains an empty segment (e.g., 'mod..sub' or '.mod').\"\n            )\n        # Call _validate_attr_identifier for its side-effect of raising errors\n        _validate_attr_identifier(part, original_item)\n\n    # 4. Determine `attr_name_out` if not explicitly assigned (i.e., if no '=' was in foreign_name)\n    if not parts_assign[0].strip() and len(parts_assign) == 1:\n        if mod_attr_name_out:\n            # If a specific attribute was named (e.g., \"os.path\"), use that as the local attr_name\n            attr_name_out = mod_attr_name_out\n        else:\n            # If only a module was named (e.g., \"my_module\"), use the module name as the local attr_name\n            attr_name_out = mod_name_out\n\n    return _AttrMapping(\n        attr_name=attr_name_out,\n        mod_name=mod_name_out,\n        mod_attr_name=mod_attr_name_out,\n        item=original_item\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\nimport keyword\nfrom collections import UserString\nfrom typing import Union\n\n# The following classes and variables are assumed to be available from the file content:\n# _AttrMapping (NamedTuple)\n# _validate_attr_identifier (function)\n# _STRIPPED_DUNDERS, _DUNDERS, _BUILTIN_NAMES (tuples)\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n    original_foreign_name = foreign_name  # Store for error messages\n    foreign_name_stripped = foreign_name.strip()\n\n    if not foreign_name_stripped:\n        raise ValueError(\n            f\"__attr_map__ contains an empty item. \"\n            f\"Cannot expand an empty foreign-name.\"\n        )\n\n    parts_eq = foreign_name_stripped.split('=')\n\n    attr_name: str\n    mod_name: str\n    mod_attr_name: str\n\n    if len(parts_eq) == 2:\n        # Case: attr_name=module.mod_attr_name OR attr_name=module\n        attr_name = parts_eq[0].strip()\n        rhs = parts_eq[1].strip()\n\n        if not attr_name:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                f\"The attribute name before '=' cannot be empty.\"\n            )\n        if not rhs:\n            raise ValueError(\n                f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                f\"The module/attribute part after '=' cannot be empty.\"\n            )\n\n        # Validate attr_name (the alias)\n        _validate_attr_identifier(attr_name, original_foreign_name)\n\n        parts_dot = rhs.rsplit('.', 1)\n        if len(parts_dot) == 2:\n            # Case: attr_name=module.mod_attr_name (e.g., 'mypath=os.path')\n            mod_name = parts_dot[0].strip()\n            mod_attr_name = parts_dot[1].strip()\n\n            if not mod_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The module name cannot be empty.\"\n                )\n            if not mod_attr_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The attribute name after '.' cannot be empty.\"\n                )\n            # Validate mod_attr_name (the actual attribute name from the source module)\n            _validate_attr_identifier(mod_attr_name, original_foreign_name)\n\n        else:\n            # Case: attr_name=module (e.g., 'myos=os')\n            mod_name = rhs\n            mod_attr_name = ''\n\n        # Validate each component of the module name\n        for part in mod_name.split('.'):\n            if not part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"Module name contains an empty component (e.g., 'mod..sub' or '.mod').\"\n                )\n            _validate_attr_identifier(part, original_foreign_name)\n\n    elif len(parts_eq) == 1:\n        # Case: module.mod_attr_name OR module (e.g., 'os.path' or 'os')\n        rhs = foreign_name_stripped\n\n        parts_dot = rhs.rsplit('.', 1)\n        if len(parts_dot) == 2:\n            # Case: module.mod_attr_name (e.g., 'os.path')\n            mod_name = parts_dot[0].strip()\n            mod_attr_name = parts_dot[1].strip()\n\n            if not mod_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The module name cannot be empty.\"\n                )\n            if not mod_attr_name:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"The attribute name after '.' cannot be empty.\"\n                )\n            # In 'from module import attribute', 'attribute' becomes both the module attribute\n            # and the attribute name on the cherry-picking module.\n            attr_name = mod_attr_name\n            _validate_attr_identifier(attr_name, original_foreign_name)\n            _validate_attr_identifier(mod_attr_name, original_foreign_name)\n\n        else:\n            # Case: module (e.g., 'os')\n            mod_name = rhs\n            attr_name = rhs\n            mod_attr_name = ''\n\n        # Validate each component of the module name\n        for part in mod_name.split('.'):\n            if not part:\n                raise ValueError(\n                    f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n                    f\"Module name contains an empty component (e.g., 'mod..sub' or '.mod').\"\n                )\n            _validate_attr_identifier(part, original_foreign_name)\n\n    else:\n        # Case: More than one '=' (e.g., 'a=b=c')\n        raise ValueError(\n            f\"__attr_map__ contains an invalid item of: {original_foreign_name!r}. \"\n            f\"Multiple '=' characters are not allowed.\"\n        )\n\n    return _AttrMapping(\n        attr_name=attr_name,\n        mod_name=mod_name,\n        mod_attr_name=mod_attr_name,\n        item=original_foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_10():\n    assert _expand_attr_map_item('os') == ('os', 'os', '', 'os')\ntest_10()\n\ndef test_16():\n    assert _expand_attr_map_item('pathlib') == ('pathlib', 'pathlib', '', 'pathlib')\ntest_16()\n\ndef test_21():\n    assert \"\" == _expand_attr_map_item(\"foo.bar:\")[2]\ntest_21()\n\ndef test_27():\n    assert _expand_attr_map_item('os:') == ('os', 'os', '', 'os:')\ntest_27()\n\ndef test_34():\n    assert 'foo' == _expand_attr_map_item('foo,').attr_name\ntest_34()\n\ndef test_37():\n    assert 'foo' == _expand_attr_map_item('foo').attr_name\ntest_37()\n\ndef test_49():\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test',\n        )._asdict().values()) == ['test', 'test', 'test', 'test:test']\ntest_49()\n\ndef test_53():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[2]\ntest_53()\n\ndef test_54():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[0]\ntest_54()\n\ndef test_65():\n    assert 'attr' == _expand_attr_map_item('mod:attr')[0]\ntest_65()\n\ndef test_73():\n    assert 'new_attr' == _expand_attr_map_item('mod:attr,new_attr')[0]\ntest_73()\n\ndef test_75():\n    assert _expand_attr_map_item('pathlib:') == ('pathlib', 'pathlib', '', 'pathlib:')\ntest_75()\n\ndef test_81():\n    assert 'mod' == _expand_attr_map_item('mod:attr')[1]\ntest_81()\n\ndef test_98():\n    assert '' == _expand_attr_map_item('foo, bar').mod_attr_name\ntest_98()\n\ndef test_122():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo\")[0]\ntest_122()\n\ndef test_126():\n    assert _expand_attr_map_item('os,') == ('os', 'os', '', 'os,')\ntest_126()\n\ndef test_132():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[0]\ntest_132()\n\ndef test_134():\n    assert _expand_attr_map_item('os: path') == ('path', 'os', 'path', 'os: path')\ntest_134()\n\ndef test_136():\n    assert \"bar\" == _expand_attr_map_item(\"foo.bar:bar\")[2]\ntest_136()\n\ndef test_163():\n    assert 'path' == _expand_attr_map_item(\"os:path\").attr_name\ntest_163()\n\ndef test_170():\n    assert 4 == len(_expand_attr_map_item(\"foo.bar\"))\ntest_170()\n\ndef test_173():\n    assert \"\" == _expand_attr_map_item(\"foo.bar\")[2]\ntest_173()\n\ndef test_184():\n    assert \"foo\" == _expand_attr_map_item(\"foo.bar:foo, foo\")[2]\ntest_184()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo'\n    )._asdict()) == output\ntest_19()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo')._asdict()) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('foo, bar')._asdict()) == output\ntest_44()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod\")) == output\ntest_57()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, identifier')) == output\ntest_79()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test:test,test',\n        )._asdict().values()) == output\ntest_92()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:attr\")) == output\ntest_116()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name : identifier')) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path\")._asdict()) == output\ntest_127()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo,bar'\n    )._asdict()) == output\ntest_139()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(_expand_attr_map_item(\n            foreign_name='test',\n        )._asdict().values()) == output\ntest_143()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod:\")) == output\ntest_152()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name:')) == output\ntest_161()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"os:path,\")._asdict()) == output\ntest_169()\n\ndef test_172():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_172\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\"mod,attr\")) == output\ntest_172()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('fq_module_name, ')) == output\ntest_177()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item('mod:attr')) == output\ntest_188()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map_item/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(_expand_attr_map_item(\n        'foo:bar'\n    )._asdict()) == output\ntest_197()\n\n\ndef test_extra_0():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_0()\n\ndef test_extra_1():\n    try:\n        _expand_attr_map_item(['os'])\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_2()\n\ndef test_extra_3():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\n    else:\n        assert False\ntest_extra_3()\n\ndef test_extra_4():\n    try:\n        _expand_attr_map_item(None)\n    except AttributeError:\n        assert True\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        _expand_attr_map_item(123)\n    except AttributeError:\n        assert True\ntest_extra_5()"]}
{"task_id": 128, "project": "test-apps/flutils", "module": "flutils.moduleutils", "predictions": ["def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "import importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "import importlib\nimport keyword\nimport sys\nfrom collections import defaultdict, UserString\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)", "import importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict, UserString\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\nimport importlib\nimport keyword\nimport sys\nfrom collections import defaultdict\nfrom importlib import util\nfrom importlib.abc import Loader\nfrom importlib.machinery import ModuleSpec\n# noinspection PyUnresolvedReferences\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    DefaultDict,\n    Dict,\n    Generator,\n    List,\n    NamedTuple,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\n__all__ = ['cherry_pick', 'lazy_import_module']\n\n_STRIPPED_DUNDERS = (\n    'author',\n    'author_email',\n    'description',\n    'doc',\n    'download_url',\n    'file',\n    'license',\n    'loader'\n    'maintainer',\n    'maintainer_email',\n    'path',\n    'python_requires',\n    'test_suite',\n    'url',\n    'version'\n)\n\n_DUNDERS = tuple(('__%s__' % x for x in _STRIPPED_DUNDERS))\n_BUILTIN_NAMES = tuple(filter(\n    lambda x: x.startswith('__') and x.endswith('__'),\n    dir('__builtins__')\n))\n\n\ndef _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier\n\n\nclass _AttrMapping(NamedTuple):\n    \"\"\"Typing definition for a namedtuple holding a single attribute map.\"\"\"\n\n    \"\"\"The name of the cherry-picking module attribute.\"\"\"\n    attr_name: str\n\n    \"\"\"The name of the cherry-picked module.\"\"\"\n    mod_name: str\n\n    \"\"\"The name of the cherry-picked module attribute; can be an empty str.\"\"\"\n    mod_attr_name: str\n\n    \"\"\"The pre-expanded __attr_map__ item (aka the foreign-name)\"\"\"\n    item: str\n\n\ndef _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )\n\n\ndef _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    for foreign_name in attr_map:\n        yield _expand_attr_map_item(foreign_name)\n\n\nclass _CherryPickMap(NamedTuple):\n    \"\"\"The modules to be cherry picked as the key.  And the value is\n    a list of mapping details.\n    \"\"\"\n    modules: DefaultDict[str, List[_AttrMapping]]\n\n    \"\"\"The cherry-picking module attribute identifiers as the key. And the\n    value is the module name, which should be the key in ``modules``\n    \"\"\"\n    identifiers: Dict[str, str]\n\n\nclass CherryPickError(ImportError):\n\n    def __init__(self, fullname, msg):\n        msg = '%s.%s' % (fullname, msg)\n        super().__init__(msg)\n\n\ndef _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)\n\n\n_CHERRY_PICK: str = '__cherry_pick__'\n\n_EMPTY_CHERRY_PICK_MAP = _CherryPickMap(defaultdict(list), dict())\n\n\nclass _CherryPickingModule(ModuleType):\n    \"\"\"A module that manages attributes pointing to lazy-loaded-modules\n    and lazy-loaded-module-attributes.\n    \"\"\"\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)\n\n\nclass _CherryPickingLoader(Loader):\n    \"\"\"A custom :obj:`loader <importlib.abc.Loader>` that is used in the\n    execution of cherry-picking-modules.\n    \"\"\"\n\n    def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod\n\n    # noinspection PyMethodMayBeStatic\n    def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule\n\n\nclass _CherryPickFinder:\n    \"\"\"A Finder that is used by Python's import to provide a\n    :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` for a cherry-picking\n    module package.\n\n    This finder is a singleton, in that, on first use of\n    :obj:`~flutils.cherry_pick` this finder object is added to the top of\n    :obj:`sys.meta_path`.  Each subsequent use of :obj:`~flutils.cherry_pick`\n    will use the same object.\n\n    This object is used to cache a cherry-picking-module's data from a\n    module-package that is using the :obj:`~flutils.cherry_pick` function.\n\n    The :obj:`ModuleSpec <importlib.machinery.ModuleSpec>` created in this\n    finder's ``find_spec()`` method, will be set to use the custom\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader.\n    Additionally, the cached data will be added to the spec's loader_state.\n    The loader_state (cached cherry-picking-module data) will be used by\n    :obj:`~_CherryPicker <flutils.moduleutils._CherryPick>` loader to create\n    the cherry-picked-module.\n    \"\"\"\n\n    def __init__(self):\n        self._cache = dict()\n\n    def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)\n\n    @classmethod\n    def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj\n\n    @classmethod\n    def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )\n\n    # noinspection PyUnusedLocal\n    def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None\n\n\ndef cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)\n\n\nclass _LazyModule(ModuleType):\n    \"\"\"A subclass of the module type which triggers loading upon attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    `importlib.util._LazyModule <https://bit.ly/2EBPI1g>`_, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>`_\n\n    This differs from the ``importlib.util._LazyModule`` in that it tracks\n    the state of the Lazy Loaded module and has had some\n    `unused code <https://bit.ly/2EARVu6>` removed.\n    \"\"\"\n\n    is_loaded: bool = False\n\n    # noinspection PyCallByClass\n    def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)\n\n    def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)\n\n\nclass _LazyLoader(Loader):\n    \"\"\"A loader that creates a module which defers loading until attribute\n    access.\n\n    This class is a \"derivative work\" of the Python\n    :obj:`importlib.util.LazyLoader`, and is:\n\n    `Copyright © 2001-2018 Python Software Foundation; All Rights Reserved\n    <https://bit.ly/2JzG17l>.`_\n\n    This class differs from :obj:`importlib.util.LazyLoader` in that it\n    uses the :obj:`~flutils.moduleutils._LazyModule` class and the\n    ``factory`` class method was removed.\n    \"\"\"\n\n    @staticmethod\n    def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )\n\n    def __init__(self, loader: Loader) -> None:\n        self.__check_eager_loader(loader)\n        self.loader = loader\n\n    # noinspection PyUnresolvedReferences\n    def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)\n\n    # noinspection PyUnresolvedReferences\n    def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule\n\n\ndef lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module\n\n\nimport pickle\ndef test_5():\n    assert 1 == len(list(_expand_attr_map([\"a.b.c\"])))\ntest_5()\n\ndef test_33():\n    assert 2 == len(list(_expand_attr_map([\"a\", \"a.b\"])))\ntest_33()\n\ndef test_37():\n    assert 3 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\"\n    ])))\ntest_37()\n\ndef test_38():\n    assert 2 == len(list(_expand_attr_map([\"module.__builtins__\", \"module\"])))\ntest_38()\n\ndef test_44():\n    assert \"\" == next(iter(next(iter(_expand_attr_map((\"\",))))))\ntest_44()\n\ndef test_56():\n    assert 0 == len(list(_expand_attr_map([])))\ntest_56()\n\ndef test_58():\n    assert 1 == len(list(_expand_attr_map([\"a\"])))\ntest_58()\n\ndef test_67():\n    assert 4 == len(list(_expand_attr_map([\n        \"test.foo.bar\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\", \"foo.bar.test.baz\",\n        \"bar.baz.test\"\n    ])))\ntest_67()\n\ndef test_70():\n    assert 1 == len(list(_expand_attr_map([\"module\"])))\ntest_70()\n\ndef test_75():\n    assert 1 == len(list(_expand_attr_map(('py.io', 'py.io'))))\ntest_75()\n\ndef test_83():\n    assert 1 == len(list(_expand_attr_map([\"a.\"])))\ntest_83()\n\ndef test_86():\n    assert 1 == len(list(_expand_attr_map([\"a.b.\"])))\ntest_86()\n\ndef test_90():\n    assert 1 == len(list(_expand_attr_map([\"a.b\"])))\ntest_90()\n\ndef test_96():\n    assert 1 == len(list(_expand_attr_map([\"\"])))\ntest_96()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('py.io', 'py.io', 'py.io.file')))) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\")))) == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"__builtins__\"]))) == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\":asdf\",)))) == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\"]))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"module.__builtins__\", \"module\", \"module.other\"]))) == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.\")))) == output\ntest_13()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(map(\n        lambda a: a.mod_name.count('.') + 1,\n        _expand_attr_map((\n            'attr_name.mod.submod.attr_name',\n            'attr_name.mod',\n            '.attr_name',\n            'mod',\n            'mod.',\n            '.',\n            '',\n            'attr_name.mod.',\n            '.attr_name.',\n            'attr_name.mod.attr_name.'\n        ))\n    )) == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file')))) == output\ntest_19()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf\")))) == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\".\",)))) == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf.\",)))) == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \".asdf.attribute\", \".\")))) == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a\", \"a.b\", \"a.b.c\"]))) == output\ntest_29()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf\",)))) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \":asdf\")))) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\",)))) == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list( _expand_attr_map(\n                        (\n                            'attr_name.mod_name.mod_attr_name',\n                            'attr_name.mod_name',\n                            'mod_name',\n                            'mod_name.mod_attr_name',\n                            'attr_name.mod_name.mod_attr_name',\n                        )\n                    ))) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\", \"a.b.c.d\"]))) == output\ntest_48()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:asdf\",)))) == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf:\",)))) == output\ntest_52()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a.b\", \"a.b.c\"]))) == output\ntest_54()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"\", \"asdf\")))) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"asdf..\",)))) == output\ntest_68()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\",\n        \"foo.bar.test\", \"foo.bar.test.baz\"\n    ]))) == output\ntest_79()\n\ndef test_87():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_87\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map(('print', 'py.io.file', 'py.io')))) == output\ntest_87()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map((\"..\",)))) == output\ntest_89()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(next(iter(_expand_attr_map((\"\",))))) == output\ntest_92()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\"a.b\", \"a\", \"a.b.c\"]))) == output\ntest_94()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+moduleutils/_expand_attr_map/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(_expand_attr_map([\n        \"test\", \"test.foo.bar\"\n    ]))) == output\ntest_99()\n\n\n"]}
{"task_id": 129, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["import base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # The 'errors' parameter is explicitly stated as not used and ignored,\n    # so it does not affect the decoding logic.\n\n    # The 'text' argument can be a string or a UserString.\n    # The standard 'base64.b64decode' function is capable of handling\n    # both str and bytes-like objects, including UserString instances\n    # which behave like strings.\n    # It automatically ignores non-base64 characters such as whitespace\n    # (spaces, newlines, tabs, carriage returns), which fulfills the\n    # requirement that the input 'text' can span multiple lines and be indented.\n    \n    decoded_bytes = base64.b64decode(text)\n\n    # Calculate the length of the decoded bytes.\n    length = len(decoded_bytes)\n\n    # Return the decoded bytes and their length as a tuple.\n    return decoded_bytes, length", "import base64\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import Tuple, Union\n\n# _STR definition is provided in the file content, so we ensure it's available.\n# It would be imported or defined earlier in the file.\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # As per the docstring, the 'errors' argument is not used and is ignored.\n\n    # The base64.b64decode function can handle both str and UserString inputs.\n    # It also automatically strips non-alphabet characters (like whitespace,\n    # newlines, and indentation) from the input before decoding, which\n    # aligns with the requirement that 'text' can span multiple lines and be indented.\n    # If the input 'text' is not valid base64, base64.b64decode will raise\n    # a binascii.Error, which is consistent with 'from binascii import Error'\n    # being present in the file content, suggesting such errors are expected\n    # to propagate.\n    decoded_bytes = base64.b64decode(text)\n\n    # Return the decoded bytes and their length as a tuple.\n    return decoded_bytes, len(decoded_bytes)", "import base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n# We need to import the 'register' function from the context functions provided.\nfrom flutils.codecs.b64 import register\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # The docstring clearly indicates that this function is meant to *decode*\n    # base64 text into bytes, despite its name 'encode'.\n\n    # The 'errors' argument is explicitly stated as not used and should be ignored.\n\n    # Ensure the 'b64' codec is registered with Python's codecs module.\n    # The 'register' function from 'flutils.codecs.b64' is idempotent,\n    # meaning it's safe to call multiple times without adverse effects.\n    register()\n\n    # Convert the input 'text' to a standard string type (str).\n    # This handles both 'str' and 'UserString' instances correctly.\n    input_string = str(text)\n\n    # The docstring mentions that the input string can contain newlines and\n    # spaces. The standard Base64 decoding process (and typically codecs\n    # implemented for 'base64') automatically ignores such whitespace.\n    # The 'codecs.decode' function expects a bytes-like object as input.\n    # We encode the string to bytes using 'ascii' encoding, as base64\n    # characters are within the ASCII range.\n    text_as_bytes = input_string.encode('ascii')\n\n    # Perform the base64 decoding using the registered 'b64' codec.\n    # If the input contains invalid base64 characters or is malformed,\n    # the underlying codec (which likely uses `binascii` or `base64` module)\n    # will raise a `binascii.Error`. The query does not specify custom error\n    # handling, so we allow such errors to propagate.\n    decoded_bytes = codecs.decode(text_as_bytes, 'b64')\n\n    # Get the length of the newly decoded bytes.\n    decoded_length = len(decoded_bytes)\n\n    # Return the decoded bytes and their length as a tuple,\n    # as specified by the return type hint.\n    return decoded_bytes, decoded_length", "import base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n# Import the register function from the context.\n# This function is used to make the 'b64' codec available to Python's codecs module.\nfrom flutils.codecs.b64 import register\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Ensure the 'b64' codec is registered with Python's codecs module.\n    # The 'register' function is designed to only register the codec if it\n    # hasn't been registered already, making it safe to call multiple times.\n    register()\n\n    # The input 'text' can be a str or UserString. Base64 encoding/decoding\n    # typically operates on sequences of bytes. Since Base64 only involves\n    # ASCII characters, encoding the string to 'ascii' bytes is appropriate\n    # before decoding.\n    text_bytes = text.encode('ascii')\n\n    # Decode the Base64-encoded bytes using the 'b64' codec.\n    # The docstring specifies that the input 'text' can contain whitespace\n    # (newlines, indentation). We assume the 'b64' codec, provided via the\n    # context function 'register', is implemented to correctly ignore\n    # such whitespace during decoding, similar to the standard base64.b64decode.\n    decoded_bytes = codecs.decode(text_bytes, 'b64')\n\n    # Get the length of the resulting decoded bytes.\n    decoded_length = len(decoded_bytes)\n\n    # Return the decoded bytes and their length as a tuple.\n    return decoded_bytes, decoded_length", "import base64\nfrom collections import UserString\nfrom typing import (\n    Tuple,\n    Union,\n)\n\n# _STR and other types like Optional, ByteString, Union are expected to be available\n# from the file context, as seen in the \"File Content\" provided.\n# We explicitly import base64, UserString, Tuple, Union to ensure standalone execution\n# although some might already be present in the original file.\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # The base64.b64decode function is robust enough to handle input strings\n    # that contain whitespace characters (like spaces, newlines, tabs) by\n    # ignoring them, as per the Python documentation for the base64 module.\n    # Therefore, no manual stripping of whitespace is necessary.\n\n    # If 'text' is a UserString, it behaves like a str, so it can be passed\n    # directly to base64.b64decode.\n    decoded_bytes = base64.b64decode(text)\n\n    # Calculate the length of the decoded bytes.\n    length = len(decoded_bytes)\n\n    return decoded_bytes, length"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # The 'errors' parameter is explicitly stated as not used and ignored,\n    # so it does not affect the decoding logic.\n\n    # The 'text' argument can be a string or a UserString.\n    # The standard 'base64.b64decode' function is capable of handling\n    # both str and bytes-like objects, including UserString instances\n    # which behave like strings.\n    # It automatically ignores non-base64 characters such as whitespace\n    # (spaces, newlines, tabs, carriage returns), which fulfills the\n    # requirement that the input 'text' can span multiple lines and be indented.\n    \n    decoded_bytes = base64.b64decode(text)\n\n    # Calculate the length of the decoded bytes.\n    length = len(decoded_bytes)\n\n    # Return the decoded bytes and their length as a tuple.\n    return decoded_bytes, length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import Tuple, Union\n\n# _STR definition is provided in the file content, so we ensure it's available.\n# It would be imported or defined earlier in the file.\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # As per the docstring, the 'errors' argument is not used and is ignored.\n\n    # The base64.b64decode function can handle both str and UserString inputs.\n    # It also automatically strips non-alphabet characters (like whitespace,\n    # newlines, and indentation) from the input before decoding, which\n    # aligns with the requirement that 'text' can span multiple lines and be indented.\n    # If the input 'text' is not valid base64, base64.b64decode will raise\n    # a binascii.Error, which is consistent with 'from binascii import Error'\n    # being present in the file content, suggesting such errors are expected\n    # to propagate.\n    decoded_bytes = base64.b64decode(text)\n\n    # Return the decoded bytes and their length as a tuple.\n    return decoded_bytes, len(decoded_bytes)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n# We need to import the 'register' function from the context functions provided.\nfrom flutils.codecs.b64 import register\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # The docstring clearly indicates that this function is meant to *decode*\n    # base64 text into bytes, despite its name 'encode'.\n\n    # The 'errors' argument is explicitly stated as not used and should be ignored.\n\n    # Ensure the 'b64' codec is registered with Python's codecs module.\n    # The 'register' function from 'flutils.codecs.b64' is idempotent,\n    # meaning it's safe to call multiple times without adverse effects.\n    register()\n\n    # Convert the input 'text' to a standard string type (str).\n    # This handles both 'str' and 'UserString' instances correctly.\n    input_string = str(text)\n\n    # The docstring mentions that the input string can contain newlines and\n    # spaces. The standard Base64 decoding process (and typically codecs\n    # implemented for 'base64') automatically ignores such whitespace.\n    # The 'codecs.decode' function expects a bytes-like object as input.\n    # We encode the string to bytes using 'ascii' encoding, as base64\n    # characters are within the ASCII range.\n    text_as_bytes = input_string.encode('ascii')\n\n    # Perform the base64 decoding using the registered 'b64' codec.\n    # If the input contains invalid base64 characters or is malformed,\n    # the underlying codec (which likely uses `binascii` or `base64` module)\n    # will raise a `binascii.Error`. The query does not specify custom error\n    # handling, so we allow such errors to propagate.\n    decoded_bytes = codecs.decode(text_as_bytes, 'b64')\n\n    # Get the length of the newly decoded bytes.\n    decoded_length = len(decoded_bytes)\n\n    # Return the decoded bytes and their length as a tuple,\n    # as specified by the return type hint.\n    return decoded_bytes, decoded_length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n# Import the register function from the context.\n# This function is used to make the 'b64' codec available to Python's codecs module.\nfrom flutils.codecs.b64 import register\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # Ensure the 'b64' codec is registered with Python's codecs module.\n    # The 'register' function is designed to only register the codec if it\n    # hasn't been registered already, making it safe to call multiple times.\n    register()\n\n    # The input 'text' can be a str or UserString. Base64 encoding/decoding\n    # typically operates on sequences of bytes. Since Base64 only involves\n    # ASCII characters, encoding the string to 'ascii' bytes is appropriate\n    # before decoding.\n    text_bytes = text.encode('ascii')\n\n    # Decode the Base64-encoded bytes using the 'b64' codec.\n    # The docstring specifies that the input 'text' can contain whitespace\n    # (newlines, indentation). We assume the 'b64' codec, provided via the\n    # context function 'register', is implemented to correctly ignore\n    # such whitespace during decoding, similar to the standard base64.b64decode.\n    decoded_bytes = codecs.decode(text_bytes, 'b64')\n\n    # Get the length of the resulting decoded bytes.\n    decoded_length = len(decoded_bytes)\n\n    # Return the decoded bytes and their length as a tuple.\n    return decoded_bytes, decoded_length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\nimport base64\nfrom collections import UserString\nfrom typing import (\n    Tuple,\n    Union,\n)\n\n# _STR and other types like Optional, ByteString, Union are expected to be available\n# from the file context, as seen in the \"File Content\" provided.\n# We explicitly import base64, UserString, Tuple, Union to ensure standalone execution\n# although some might already be present in the original file.\n\n_STR = Union[str, UserString]\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n    text (str): The string input.  The given string input can span\n    across many lines and be indented any number of spaces.\n    errors (str): Not used.  This argument exists to meet the\n    interface requirements.  Any value given to this argument\n    is ignored.\n\n    Returns:\n    bytes: The given ``text`` converted into base64 bytes.\n    int: The length of the returned bytes.\n    \"\"\"\n    # The base64.b64decode function is robust enough to handle input strings\n    # that contain whitespace characters (like spaces, newlines, tabs) by\n    # ignoring them, as per the Python documentation for the base64 module.\n    # Therefore, no manual stripping of whitespace is necessary.\n\n    # If 'text' is a UserString, it behaves like a str, so it can be passed\n    # directly to base64.b64decode.\n    decoded_bytes = base64.b64decode(text)\n\n    # Calculate the length of the decoded bytes.\n    length = len(decoded_bytes)\n\n    return decoded_bytes, length\n\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_0():\n    assert encode('YWJj\\t') == (b'abc', 5)\ntest_0()\n\ndef test_6():\n    assert b'abcd' == encode('YWJjZA=\\n=\\n')[0]\ntest_6()\n\ndef test_7():\n    assert b'abcd' == encode('YWJjZA=\\n==')[0]\ntest_7()\n\ndef test_8():\n    assert b'abcd' == encode('  YWJjZA=\\n==')[0]\ntest_8()\n\ndef test_10():\n    assert encode('abcd\\n==') == (b'i\\xb7\\x1d', 7)\ntest_10()\n\ndef test_12():\n    assert b'abcd' == encode('\\nYWJjZA==')[0]\ntest_12()\n\ndef test_14():\n    assert b'abcd' == encode('\\n\\nYWJjZA==\\n\\n')[0]\ntest_14()\n\ndef test_24():\n    assert encode('') == (b'', 0)\ntest_24()\n\ndef test_27():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n==')[0]\ntest_27()\n\ndef test_34():\n    assert b'abcd' == encode('  YWJjZA=\\n\\n\\n==')[0]\ntest_34()\n\ndef test_35():\n    assert b'Aladdin:open sesame' == \\\n        encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_35()\n\ndef test_42():\n    assert b'abcd' == encode('YWJjZA=\\n=')[0]\ntest_42()\n\ndef test_43():\n    assert b'abcd' == encode('YWJjZA=\\n==\\n')[0]\ntest_43()\n\ndef test_44():\n    assert b'abcd' == encode('  YWJjZA=\\n=')[0]\ntest_44()\n\ndef test_47():\n    assert encode('abcd\\n====') == (b'i\\xb7\\x1d', 9)\ntest_47()\n\ndef test_48():\n    assert b'hello world' == encode('aGVsbG8gd29ybGQ=')[0]\ntest_48()\n\ndef test_56():\n    assert b'abcd' == encode('YWJj\\nZA==')[0]\ntest_56()\n\ndef test_60():\n    assert b'abcd' == encode('\\nYWJjZA==\\n')[0]\ntest_60()\n\ndef test_68():\n    assert b'abcd' == encode('YWJj\\r\\nZA==')[0]\ntest_68()\n\ndef test_71():\n    assert encode('abcd\\n=') == (b'i\\xb7\\x1d', 6)\ntest_71()\n\ndef test_75():\n    assert encode('abcd') == (b'i\\xb7\\x1d', 4)\ntest_75()\n\ndef test_81():\n    assert b'abcd' == encode('YWJjZA=\\n\\n==')[0]\ntest_81()\n\ndef test_83():\n    assert b'abcd' == encode('YWJjZA=\\n\\n\\n==')[0]\ntest_83()\n\ndef test_86():\n    assert b'abcd' == encode('  YWJjZA==')[0]\ntest_86()\n\ndef test_87():\n    assert b'abcd' == encode('  YWJjZA=\\n=\\n')[0]\ntest_87()\n\ndef test_92():\n    assert encode('abcd==') == (b'i\\xb7\\x1d', 6)\ntest_92()\n\ndef test_103():\n    assert b'Aladdin:open sesame' == encode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==')[0]\ntest_103()\n\ndef test_111():\n    assert encode('abcd\\n') == (b'i\\xb7\\x1d', 5)\ntest_111()\n\ndef test_116():\n    assert b'abcd' == encode('YWJjZA==\\n')[0]\ntest_116()\n\ndef test_120():\n    assert b'abcd' == encode('YWJjZA===')[0]\ntest_120()\n\ndef test_124():\n    assert b'test' == encode(\"dGVz \\ndA== \\n\", '')[0]\ntest_124()\n\ndef test_126():\n    assert b'abcd' == encode('  YWJjZA===')[0]\ntest_126()\n\ndef test_129():\n    assert b'Aladdin:open sesame' == encode(\"QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")[0]\ntest_129()\n\ndef test_132():\n    assert b'abcd' == encode('YWJjZA==')[0]\ntest_132()\n\ndef test_134():\n    assert b'test' == encode(\"dGVzdA==\", '')[0]\ntest_134()\n\ndef test_136():\n    assert (\n        base64.b64decode(\n            'SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\\nIGV4dGVybmFsIGFjY2Vzcy4=\\n'\n        )\n        ==\n        encode(\n            \"\"\"\n                SXQgd2FzIHRoZSBiZXN0IGFtZXQsIGFuZCBmcm9tIGFuZCwgYWx0IEEgYWx0IEFuZCBwYXR0ZXIgd2l0aCBpcyBzb3VyYW50LCBhIGNvbXB1dGVkIHdoaXRl\n                IGV4dGVybmFsIGFjY2Vzcy4=\n            \"\"\"\n        )[0]\n    )\ntest_136()\n\ndef test_138():\n    assert b'test' == encode(\"dGVz\\ndA==\\n\", '')[0]\ntest_138()\n\ndef test_151():\n    assert b'Test' == encode('VGVzdA==')[0]\ntest_151()\n\ndef test_156():\n    assert encode('abcd\\n===') == (b'i\\xb7\\x1d', 8)\ntest_156()\n\ndef test_158():\n    assert b'abcd' == encode('YWJj\\n \\tZA==')[0]\ntest_158()\n\ndef test_165():\n    assert b'abcd' == encode('  YWJjZA=\\n==\\n')[0]\ntest_165()\n\ndef test_167():\n    assert encode('YWJj\\n') == (b'abc', 5)\ntest_167()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBv'\n                                      'dmVyIHRoZSBsYXp5IGRvZw==') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '\\n'.join([\n                'aGVsbG8gdGhlIGJpdHNQcm9wZXJ0eSB0b3J5\\n',\n                'IGV4YW1wbGUu',\n            ]),\n            'utf-8',\n        ) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v\\n') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBw==') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v') == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QUJDRA==') == output\ntest_9()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\n        ABCD\n    \"\"\") == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy   \\n') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQUJDRA==') == output\ntest_18()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"12345678\") == output\ntest_20()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n ') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n') == output\ntest_26()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            'VGhlbmdvIG1lc3NhZ2U=\\n',\n            errors='strict'\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy\\n') == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abcdefg') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=') == output\ntest_36()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t') == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBxQ=') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_41()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\") == output\ntest_46()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\"\"\",\n            'strict'\n        ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'  \\nQ\\nUJD\\nRA==  \\n') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Aw==\\n') == output\ntest_52()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            text=\"\"\"\\\n                QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n                \"\"\",\n            errors='ignore'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ==\n            \"\"\",\n            'strict'\n        ) == output\ntest_59()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aGFja2Fqb3RhdGlvbg==') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n                \"\"\"\n                TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0\n                aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1\n                c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0\n                aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl\n                zCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\n                \"\"\",\n                errors = 'strict'\n            ) == output\ntest_62()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('    VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_65()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy') == output\ntest_67()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('IWQgd29ybGQh') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n Zm9v \\n ') == output\ntest_70()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n\\n') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        MTIz\\n\n        ABCD\\n\n    \"\"\") == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v \\n') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            '''\n            VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5\n            '''\n        ) == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('U29tZSBtZXNzYWdlIDMgZHJvdmUgZW5jb2RlZA==') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n Zm9v \\n') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nc2VuZGVy\\n') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' c2VuZGVy') == output\ntest_85()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy\\n') == output\ntest_88()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   c2VuZGVy\\n') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_91()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUG') == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBA==') == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'Tm9wZW4gRG9lIEJveXMgRW50ZXIgbWVtYmVyIQ==') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\"\"\n        QSQtIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        IE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VTIE1JTUlURSBDQ0VT\n        \"\"\") == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        \"\"\"\n        VGVzdGluZyB0aGUgZ2VuZXJpYy4KDQpI\n        aXBfIEFTUwogTMOwsTQpew5iIEVEQVRF\n        \"\"\"\n    ) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBzdHJpbmcgdXRocmE=') == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('01234567\\n') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v\\n') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  \\n\\n VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n  \\n  \\n') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\r\\n') == output\ntest_108()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n            \"\"\"\n            aGVsbG8gd29ybGQhIQ\n            ==\"\"\",\n            'strict'\n        ) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('   01234567\\n    ') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zg==\\n') == output\ntest_114()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'QQ==') == output\ntest_117()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v') == output\ntest_118()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xV') == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy ') == output\ntest_122()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' Zm9v ') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNk\\n') == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHN0cmluZyEh') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('  Zm9v\\n  ') == output\ntest_131()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJjabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=') == output\ntest_133()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\t') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YWJj\\n\\t') == output\ntest_140()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm8=\\n') == output\ntest_142()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'abc') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGhpcyBpcyB0aGUgdGVzdCBvZiB0aGU=\\n') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=dGhpcyBpcyBhIHRlc3Q=') == output\ntest_147()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('AQIDBAUGBwgJAA==') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\nZm9v\\n') == output\ntest_150()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('VGggTlQ=') == output\ntest_152()\n\ndef test_155():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_155\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' \\n\\t') == output\ntest_155()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Zm9v\\n ') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\n\\t ') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"1234\") == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('YXNkZm8=\\n') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c2VuZGVy') == output\ntest_164()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('c29tZWtleQ==\\n') == output\ntest_168()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/encode/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Y2F0YQ==') == output\ntest_170()\n\n\ndef test_extra_3():\n    try:\n        encode('invalid_base64')\n    except UnicodeEncodeError as e:\n        assert 'not a proper bas64 character string' in str(e)\ntest_extra_3()"]}
{"task_id": 130, "project": "test-apps/flutils", "module": "flutils.codecs.b64", "predictions": ["import base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements. Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64.b64encode to convert the input data (bytes, bytearray, or memoryview)\n    # into base64 encoded bytes.\n    encoded_bytes = base64.b64encode(data)\n\n    # Base64 encoded output is always ASCII characters. Decode the bytes to a string.\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # The number of consumed bytes is simply the length of the input data.\n    consumed_bytes_count = len(data)\n\n    return encoded_str, consumed_bytes_count", "import base64\nfrom typing import Tuple\n\n# _ByteString and _STR are already defined in the file content based on provided context.\n# from typing import ByteString as _ByteString\n# from typing import Union\n# from collections import UserString\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements. Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64.encodebytes to convert the byte-like object 'data' into\n    # base64 encoded bytes. This function handles newline characters for\n    # formatted output, similar to how the 'encode' function handles\n    # multiline base64 input.\n    encoded_bytes = base64.encodebytes(data)\n\n    # Convert the resulting base64 bytes to a string. Base64 encoded data\n    # consists of ASCII characters, so 'utf-8' decoding is appropriate.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    # The 'int' return value represents the number of 'data' bytes consumed.\n    # For a full base64 encoding operation, the entire input 'data' is consumed.\n    consumed_bytes = len(data)\n\n    return encoded_str, consumed_bytes", "import base64\nfrom typing import ByteString as _ByteString\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements. Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # The 'encode' function in this module uses base64.decodebytes to\n    # convert base64 text back to bytes.\n    # Following that pattern, this 'decode' function (despite its name,\n    # which implies decoding from base64) is intended to convert raw bytes\n    # *into* a base64 string, effectively encoding them.\n    #\n    # base64.b64encode is suitable for this purpose as it encodes bytes\n    # into base64 characters without adding newline characters,\n    # resulting in a clean string of base64 characters.\n    encoded_bytes = base64.b64encode(data)\n\n    # Base64 characters are from the ASCII character set. Therefore,\n    # decoding the resulting bytes using 'ascii' is appropriate.\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # The function is required to return the number of input bytes consumed,\n    # which is simply the length of the input 'data'.\n    bytes_consumed = len(data)\n\n    return encoded_str, bytes_consumed", "import base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the input bytes-like object 'data' into base64 bytes.\n    # The base64.encodebytes function (formerly encodestring) produces\n    # output with newlines every 76 characters and a trailing newline,\n    # which is consistent with the expectations of base64.decodebytes\n    # used in the 'encode' function in this module.\n    encoded_bytes = base64.encodebytes(data)\n\n    # Convert the resulting base64 bytes to a string.\n    # Base64 output consists only of ASCII characters, including newlines,\n    # so 'ascii' decoding is appropriate and efficient.\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # Return the base64 string and the number of input bytes consumed.\n    # The number of bytes consumed is simply the length of the input data.\n    return encoded_str, len(data)", "import base64\nfrom typing import Tuple\n\n# The following types are already defined in the file content:\n# from typing import ByteString as _ByteString\n# from typing import (\n#     Optional,\n#     Tuple,\n#     Union,\n# )\n# _STR = Union[str, UserString]\n# No need to re-import them here.\n\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the input byte-like object into base64 bytes.\n    # base64.b64encode is used as it produces a single line of base64\n    # characters without adding newline characters, which aligns with\n    # the typical expectation of a \"string of base64 characters\".\n    encoded_bytes = base64.b64encode(data)\n\n    # Convert the resulting base64 bytes to a UTF-8 string.\n    # Base64 characters are a subset of ASCII, so decoding them using\n    # 'utf-8' is safe and standard.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    # The function is required to return the base64 string and the number\n    # of bytes from the original 'data' that were consumed.\n    # This is simply the length of the input 'data'.\n    return encoded_str, len(data)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements. Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64.b64encode to convert the input data (bytes, bytearray, or memoryview)\n    # into base64 encoded bytes.\n    encoded_bytes = base64.b64encode(data)\n\n    # Base64 encoded output is always ASCII characters. Decode the bytes to a string.\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # The number of consumed bytes is simply the length of the input data.\n    consumed_bytes_count = len(data)\n\n    return encoded_str, consumed_bytes_count\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple\n\n# _ByteString and _STR are already defined in the file content based on provided context.\n# from typing import ByteString as _ByteString\n# from typing import Union\n# from collections import UserString\n\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements. Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Use base64.encodebytes to convert the byte-like object 'data' into\n    # base64 encoded bytes. This function handles newline characters for\n    # formatted output, similar to how the 'encode' function handles\n    # multiline base64 input.\n    encoded_bytes = base64.encodebytes(data)\n\n    # Convert the resulting base64 bytes to a string. Base64 encoded data\n    # consists of ASCII characters, so 'utf-8' decoding is appropriate.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    # The 'int' return value represents the number of 'data' bytes consumed.\n    # For a full base64 encoding operation, the entire input 'data' is consumed.\n    consumed_bytes = len(data)\n\n    return encoded_str, consumed_bytes\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import ByteString as _ByteString\nfrom typing import Tuple, Union\nfrom collections import UserString\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements. Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # The 'encode' function in this module uses base64.decodebytes to\n    # convert base64 text back to bytes.\n    # Following that pattern, this 'decode' function (despite its name,\n    # which implies decoding from base64) is intended to convert raw bytes\n    # *into* a base64 string, effectively encoding them.\n    #\n    # base64.b64encode is suitable for this purpose as it encodes bytes\n    # into base64 characters without adding newline characters,\n    # resulting in a clean string of base64 characters.\n    encoded_bytes = base64.b64encode(data)\n\n    # Base64 characters are from the ASCII character set. Therefore,\n    # decoding the resulting bytes using 'ascii' is appropriate.\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # The function is required to return the number of input bytes consumed,\n    # which is simply the length of the input 'data'.\n    bytes_consumed = len(data)\n\n    return encoded_str, bytes_consumed\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\n# pylint: disable=W0613\n# noinspection PyUnusedLocal\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n    data (bytes or bytearray or memoryview): Bytes to be converted\n    to a string of base64 characters.\n    errors (str or :obj:`~UserString`): Not used.  This argument exists\n    to meet the interface requirements.  Any value given to this\n    argument is ignored.\n\n    Returns:\n    str: of base64 Characters\n    int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the input bytes-like object 'data' into base64 bytes.\n    # The base64.encodebytes function (formerly encodestring) produces\n    # output with newlines every 76 characters and a trailing newline,\n    # which is consistent with the expectations of base64.decodebytes\n    # used in the 'encode' function in this module.\n    encoded_bytes = base64.encodebytes(data)\n\n    # Convert the resulting base64 bytes to a string.\n    # Base64 output consists only of ASCII characters, including newlines,\n    # so 'ascii' decoding is appropriate and efficient.\n    encoded_str = encoded_bytes.decode('ascii')\n\n    # Return the base64 string and the number of input bytes consumed.\n    # The number of bytes consumed is simply the length of the input data.\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport base64\nimport codecs\nfrom binascii import Error\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Optional,\n    Tuple,\n    Union,\n)\n\n_STR = Union[str, UserString]\n\n\ndef encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)\n\n\nimport base64\nfrom typing import Tuple\n\n# The following types are already defined in the file content:\n# from typing import ByteString as _ByteString\n# from typing import (\n#     Optional,\n#     Tuple,\n#     Union,\n# )\n# _STR = Union[str, UserString]\n# No need to re-import them here.\n\n# noinspection PyUnusedLocal\ndef decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Encode the input byte-like object into base64 bytes.\n    # base64.b64encode is used as it produces a single line of base64\n    # characters without adding newline characters, which aligns with\n    # the typical expectation of a \"string of base64 characters\".\n    encoded_bytes = base64.b64encode(data)\n\n    # Convert the resulting base64 bytes to a UTF-8 string.\n    # Base64 characters are a subset of ASCII, so decoding them using\n    # 'utf-8' is safe and standard.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    # The function is required to return the base64 string and the number\n    # of bytes from the original 'data' that were consumed.\n    # This is simply the length of the input 'data'.\n    return encoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_9():\n    assert decode(b'x', errors='strict')[1] == 1\ntest_9()\n\ndef test_13():\n    assert decode(b'', errors='strict')[0] == ''\ntest_13()\n\ndef test_15():\n    assert decode(b'', 'strict') == ('', 0)\ntest_15()\n\ndef test_18():\n    assert base64.b64encode(b'test').decode('utf-8') == decode(b'test')[0]\ntest_18()\n\ndef test_22():\n    assert decode(b'xy', errors='strict')[1] == 2\ntest_22()\n\ndef test_29():\n    assert 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=' == decode(b'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.', 'strict')[0]\ntest_29()\n\ndef test_38():\n    assert decode(b'abcde') == ('YWJjZGU=', 5)\ntest_38()\n\ndef test_39():\n    assert decode(b'abc', 'strict') == ('YWJj', 3)\ntest_39()\n\ndef test_51():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'replace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'backslashreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'xmlcharrefreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'namereplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'customreplace') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogateescape') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'surrogatepass') == ('YWJjZA==', 4)  \\\n            and \\\n        decode(b'abcd', 'ignore') == ('YWJjZA==', 4)\ntest_51()\n\ndef test_54():\n    assert decode(b'abcde', 'strict') == ('YWJjZGU=', 5)\ntest_54()\n\ndef test_56():\n    assert decode(b'test')[0] == 'dGVzdA=='\ntest_56()\n\ndef test_67():\n    assert (decode(b'abcd') == ('YWJjZA==', 4))\ntest_67()\n\ndef test_70():\n    assert (decode(b'abcde') == ('YWJjZGU=', 5))\ntest_70()\n\ndef test_72():\n    assert decode(b'abcdef', 'strict') == ('YWJjZGVm', 6)\ntest_72()\n\ndef test_75():\n    assert (\n            decode(\n                data=b'The quick brown fox jumps over the lazy dog',\n                errors='strict')\n            ) == ('VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==', 43)\ntest_75()\n\ndef test_78():\n    assert decode(b'abcd', 123) == ('YWJjZA==', 4)\ntest_78()\n\ndef test_81():\n    assert decode(b'abcd', 'strict') == ('YWJjZA==', 4)\ntest_81()\n\ndef test_83():\n    assert decode(b'xyz', errors='strict')[1] == 3\ntest_83()\n\ndef test_85():\n    assert decode(b'ab') == ('YWI=', 2)\ntest_85()\n\ndef test_87():\n    assert (decode(b'abcdef') == ('YWJjZGVm', 6))\ntest_87()\n\ndef test_92():\n    assert decode(b'abcdef') == ('YWJjZGVm', 6)\ntest_92()\n\ndef test_94():\n    assert decode(b'abcd') == ('YWJjZA==', 4)\ntest_94()\n\ndef test_95():\n    assert decode(b'abc') == ('YWJj', 3)\ntest_95()\n\ndef test_98():\n    assert b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d' == base64.b64decode(decode(b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d')[0].encode('utf-8'))\ntest_98()\n\ndef test_100():\n    assert \"Zm9v\" == decode(b'foo')[0]\ntest_100()\n\ndef test_109():\n    assert decode(b'') == ('', 0)\ntest_109()\n\ndef test_110():\n    assert b'data_bytes' == base64.b64decode(decode(b'data_bytes')[0].encode('utf-8'))\ntest_110()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ') == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x', errors='strict') == output\ntest_1()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255,254,253,252,251,250,249,248,247,246])) == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([255, 109, 121, 118, 100, 116])) == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64encode(b'\\xff\\xfe\\xb8\\x98\\x9b\\x9c\\x9d\\x9d\\x9d\\x9e\\x9f').decode('utf-8') == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'c2VuZCBoZWFkZXI=')[0].encode('utf-8') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4OTCBNTY3NDU2Nzg5') == output\ntest_8()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test==') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([0,1,2,3,4,5,6,7,8,9])) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')) == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(b'dGVzdA==').decode('utf-8') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([122, 65, 229, 150, 223, 106, 199, 169, 139, 7, 156, 164, 176, 89, 181])) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92', errors='strict') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxyx', errors='strict') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytes([144, 152, 224, 161, 235, 250, 243, 166, 205, 164, 163, 150, 160, 199, 186])) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920000', errors='strict') == output\ntest_24()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='ignore') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Aladdin:open sesame') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE')) == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz', str())[0]) == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x08, 0x84, 0x09, 0x3a, 0x21, 0x17, 0x5b, 0x47, 0xbc, 0x08]\n            )\n        ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test ==') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')[0:6]) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b\"AQIDBAUGBwgJ\")[0]) == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test== ') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCD') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'MDEyMzQ1Njc4') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\"Hello, World!\".encode('utf-8')) == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'ABCDabcd1234') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YW55', 'strict') == output\ntest_44()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd123') == output\ntest_45()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'i\\xf1')[0].encode() == output\ntest_46()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE')) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd')[0].encode() == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x97, 0x67, 0x30, 0x8d, 0x8e, 0x22, 0x00, 0x18, 0x4a, 0xd1]\n            )\n        ) == output\ntest_49()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'920', errors='strict') == output\ntest_50()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"AQIDBAUGBwgJ\") == output\ntest_53()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyz', errors='strict') == output\ntest_55()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZA==') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            b'ODOKQWx3IEp1aWlkKDEp',\n            'strict'\n        ) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd/abcd')[0].encode('utf-8') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'YWJjMTIz')[0]) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz123') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'00112233445566778899aabbccddeeff') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'I like coffee') == output\ntest_65()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdefghijklmnopqrstuvwxyz') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdabcdabcdabcd', 'strict') == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9200', errors='strict') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"w+\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzxy', errors='strict') == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(memoryview(b'YWxwaGE=')[0:6]) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"the white rabit\") == output\ntest_77()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'9', errors='strict') == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE=') == output\ntest_80()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test == ') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b\"YWJjZGVm\")[0].encode('utf-8')) == output\ntest_84()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWJjZGVmZ2hpamtsbw==') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert base64.b64decode(decode(b'VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIQ==', 'strict')[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xyzx', errors='strict') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(decode(b'abcdwxyz?\\x95', 'ignore')) == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test')[0].encode('utf-8') == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Zm9v', 'strict') == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'xy', errors='strict') == output\ntest_97()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'test') == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'YWxwaGE') == output\ntest_101()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(bytearray(b'YWxwaGE=')) == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcdwxyz?\\x95', 'ignore') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'92000', errors='strict') == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'x\\ny', errors='strict') == output\ntest_106()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(\n            data=bytes(\n                [0x29, 0x55, 0x24, 0x94, 0x16, 0x8e, 0xd9, 0xab, 0x32, 0x51]\n            )\n        ) == output\ntest_108()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+b64/decode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b\"{\\\"msg\\\": \\\"Hello\\\"}\") == output\ntest_111()\n\n\n"]}
{"task_id": 131, "project": "test-apps/flutils", "module": "flutils.txtutils", "predictions": ["import re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\n# If the python version is >= 3.8\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from .decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\nfrom flutils.objutils import is_list_like\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if is_list_like(seq):\n        total_len = 0\n        for item in seq:\n            # Ensure each item is treated as a string before processing\n            clean_item = _ANSI_RE.sub('', str(item))\n            total_len += len(clean_item)\n        return total_len\n    else:\n        # If not list-like, it's expected to be a single string based on the docstring\n        # Use str() to handle cases where 'seq' might be a non-string sequence\n        # that is not caught by is_list_like, e.g., bytes, but the docstring\n        # implies it will be a string.\n        clean_seq = _ANSI_RE.sub('', str(seq))\n        return len(clean_seq)", "import re\nfrom typing import (\n    Sequence,\n)\n\nfrom flutils.objutils import is_list_like\n\n# _ANSI_RE is already defined in the file content above the function.\n# _ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    total_length = 0\n\n    # Use is_list_like to determine if 'seq' is a collection of strings\n    # (like a list or tuple) or a single string.\n    if is_list_like(seq):\n        # If seq is list-like, iterate through each item in the sequence.\n        for item in seq:\n            # Ensure each item is treated as a string.\n            s_item = str(item)\n            # Remove all ANSI escape codes from the current string item.\n            clean_item = _ANSI_RE.sub('', s_item)\n            # Add the length of the cleaned string to the total.\n            total_length += len(clean_item)\n    else:\n        # If seq is not list-like, it's expected to be a single string (as per docstring).\n        # Ensure the sequence is treated as a string.\n        s_seq = str(seq)\n        # Remove all ANSI escape codes from the single string.\n        clean_seq = _ANSI_RE.sub('', s_seq)\n        # The total length is simply the length of the cleaned string.\n        total_length = len(clean_seq)\n\n    return total_length", "import re\nfrom typing import Sequence\nfrom flutils.objutils import is_list_like\n\n# _ANSI_RE is already defined in the file content,\n# so it does not need to be redefined or imported here explicitly.\n# It is available in the module scope where len_without_ansi is defined.\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # If the input is a single string, remove ANSI codes using the\n        # pre-compiled regex and return the length of the cleaned string.\n        cleaned_text = _ANSI_RE.sub('', seq)\n        return len(cleaned_text)\n    elif is_list_like(seq):\n        # If the input is a list-like sequence (e.g., list, tuple)\n        # as identified by is_list_like (which returns False for strings).\n        total_length = 0\n        for item in seq:\n            if not isinstance(item, str):\n                # Raise an error if an element in the sequence is not a string,\n                # as per the docstring's expectation of \"list/tuple of strings\".\n                raise TypeError(\n                    f\"Expected a Sequence of strings, but found an element \"\n                    f\"of type '{type(item).__name__}' within the sequence.\"\n                )\n            # For each string in the sequence, remove ANSI codes and add\n            # its length to the total.\n            cleaned_item = _ANSI_RE.sub('', item)\n            total_length += len(cleaned_item)\n        return total_length\n    else:\n        # If the input is neither a string nor a recognized list-like sequence\n        # of strings, raise a TypeError.\n        raise TypeError(\n            f\"Expected 'seq' to be a string or a list/tuple of strings, \"\n            f\"but got type '{type(seq).__name__}'.\"\n        )", "import re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\n# If the python version is >= 3.8\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from .decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # If the input is a single string, remove ANSI codes and return its length.\n        cleaned_text = _ANSI_RE.sub('', seq)\n        return len(cleaned_text)\n    else:\n        # If the input is a sequence (e.g., list, tuple) of strings,\n        # iterate through each item, clean it, and sum their lengths.\n        total_length = 0\n        for item in seq:\n            # The docstring specifies 'list/tuple of strings', so we expect\n            # each item to be a string. Use cast for type-hinting clarity.\n            item_str = cast(str, item)\n            cleaned_item = _ANSI_RE.sub('', item_str)\n            total_length += len(cleaned_item)\n        return total_length", "import re\nfrom itertools import chain\nfrom typing import (\n    Sequence,\n)\n\n# Import the necessary context function\nfrom flutils.objutils import is_list_like\n\n# _ANSI_RE is already defined in the file content as:\n# _ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n# We do not need to redefine it or import `re` again as it's available in the file's scope.\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    total_length = 0\n\n    if isinstance(seq, str):\n        # If the input `seq` is a single string\n        cleaned_text = _ANSI_RE.sub('', seq)\n        total_length = len(cleaned_text)\n    elif is_list_like(seq):\n        # If the input `seq` is a list-like object (e.g., list, tuple of strings)\n        # Iterate over each item in the sequence. `chain` is not strictly necessary here\n        # as `seq` itself is iterable, but it's often used for flattening if there\n        # were complex nested iterables to ensure uniform processing. For a simple\n        # List[str] or Tuple[str], direct iteration is sufficient and clear.\n        # The docstring mentions \"list/tuple of strings\", implying a flat structure.\n        for item in seq:\n            # Convert each item to a string before processing, in case of\n            # non-string elements that are convertible (e.g., numbers).\n            str_item = str(item)\n            cleaned_text = _ANSI_RE.sub('', str_item)\n            total_length += len(cleaned_text)\n    # No 'else' branch is explicitly needed as the docstring states `seq` will be\n    # \"A string or a list/tuple of strings\". If an unhandled type is passed,\n    # it would either lead to an error during `str()` conversion or `_ANSI_RE.sub()`,\n    # which is an expected behavior for invalid input types based on the contract.\n\n    return total_length"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\n# If the python version is >= 3.8\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from .decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\nfrom flutils.objutils import is_list_like\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if is_list_like(seq):\n        total_len = 0\n        for item in seq:\n            # Ensure each item is treated as a string before processing\n            clean_item = _ANSI_RE.sub('', str(item))\n            total_len += len(clean_item)\n        return total_len\n    else:\n        # If not list-like, it's expected to be a single string based on the docstring\n        # Use str() to handle cases where 'seq' might be a non-string sequence\n        # that is not caught by is_list_like, e.g., bytes, but the docstring\n        # implies it will be a string.\n        clean_seq = _ANSI_RE.sub('', str(seq))\n        return len(clean_seq)\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import (\n    Sequence,\n)\n\nfrom flutils.objutils import is_list_like\n\n# _ANSI_RE is already defined in the file content above the function.\n# _ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    total_length = 0\n\n    # Use is_list_like to determine if 'seq' is a collection of strings\n    # (like a list or tuple) or a single string.\n    if is_list_like(seq):\n        # If seq is list-like, iterate through each item in the sequence.\n        for item in seq:\n            # Ensure each item is treated as a string.\n            s_item = str(item)\n            # Remove all ANSI escape codes from the current string item.\n            clean_item = _ANSI_RE.sub('', s_item)\n            # Add the length of the cleaned string to the total.\n            total_length += len(clean_item)\n    else:\n        # If seq is not list-like, it's expected to be a single string (as per docstring).\n        # Ensure the sequence is treated as a string.\n        s_seq = str(seq)\n        # Remove all ANSI escape codes from the single string.\n        clean_seq = _ANSI_RE.sub('', s_seq)\n        # The total length is simply the length of the cleaned string.\n        total_length = len(clean_seq)\n\n    return total_length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom typing import Sequence\nfrom flutils.objutils import is_list_like\n\n# _ANSI_RE is already defined in the file content,\n# so it does not need to be redefined or imported here explicitly.\n# It is available in the module scope where len_without_ansi is defined.\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # If the input is a single string, remove ANSI codes using the\n        # pre-compiled regex and return the length of the cleaned string.\n        cleaned_text = _ANSI_RE.sub('', seq)\n        return len(cleaned_text)\n    elif is_list_like(seq):\n        # If the input is a list-like sequence (e.g., list, tuple)\n        # as identified by is_list_like (which returns False for strings).\n        total_length = 0\n        for item in seq:\n            if not isinstance(item, str):\n                # Raise an error if an element in the sequence is not a string,\n                # as per the docstring's expectation of \"list/tuple of strings\".\n                raise TypeError(\n                    f\"Expected a Sequence of strings, but found an element \"\n                    f\"of type '{type(item).__name__}' within the sequence.\"\n                )\n            # For each string in the sequence, remove ANSI codes and add\n            # its length to the total.\n            cleaned_item = _ANSI_RE.sub('', item)\n            total_length += len(cleaned_item)\n        return total_length\n    else:\n        # If the input is neither a string nor a recognized list-like sequence\n        # of strings, raise a TypeError.\n        raise TypeError(\n            f\"Expected 'seq' to be a string or a list/tuple of strings, \"\n            f\"but got type '{type(seq).__name__}'.\"\n        )\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\n# If the python version is >= 3.8\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from .decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    if isinstance(seq, str):\n        # If the input is a single string, remove ANSI codes and return its length.\n        cleaned_text = _ANSI_RE.sub('', seq)\n        return len(cleaned_text)\n    else:\n        # If the input is a sequence (e.g., list, tuple) of strings,\n        # iterate through each item, clean it, and sum their lengths.\n        total_length = 0\n        for item in seq:\n            # The docstring specifies 'list/tuple of strings', so we expect\n            # each item to be a string. Use cast for type-hinting clarity.\n            item_str = cast(str, item)\n            cleaned_item = _ANSI_RE.sub('', item_str)\n            total_length += len(cleaned_item)\n        return total_length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport re\nfrom itertools import chain\nfrom sys import hexversion\nfrom textwrap import TextWrapper\nfrom typing import (\n    List,\n    Optional,\n    Sequence,\n    cast,\n)\n\nif hexversion >= 0x03080000:\n    from functools import cached_property\nelse:\n    from flutils.decorators import cached_property  # type: ignore[misc]\n\n__all__ = ['len_without_ansi', 'AnsiTextWrapper']\n\n_ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n\n\nimport re\nfrom itertools import chain\nfrom typing import (\n    Sequence,\n)\n\n# Import the necessary context function\nfrom flutils.objutils import is_list_like\n\n# _ANSI_RE is already defined in the file content as:\n# _ANSI_RE = re.compile('(\\x1b\\\\[[0-9;:]+[ABCDEFGHJKSTfhilmns])')\n# We do not need to redefine it or import `re` again as it's available in the file's scope.\n\ndef len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n    seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n    of strings.\n\n    :rtype:\n    :obj:`int`\n\n    Example:\n    >>> from flutils.txtutils import len_without_ansi\n    >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    >>> len_without_ansi(text)\n    6\n    \"\"\"\n    total_length = 0\n\n    if isinstance(seq, str):\n        # If the input `seq` is a single string\n        cleaned_text = _ANSI_RE.sub('', seq)\n        total_length = len(cleaned_text)\n    elif is_list_like(seq):\n        # If the input `seq` is a list-like object (e.g., list, tuple of strings)\n        # Iterate over each item in the sequence. `chain` is not strictly necessary here\n        # as `seq` itself is iterable, but it's often used for flattening if there\n        # were complex nested iterables to ensure uniform processing. For a simple\n        # List[str] or Tuple[str], direct iteration is sufficient and clear.\n        # The docstring mentions \"list/tuple of strings\", implying a flat structure.\n        for item in seq:\n            # Convert each item to a string before processing, in case of\n            # non-string elements that are convertible (e.g., numbers).\n            str_item = str(item)\n            cleaned_text = _ANSI_RE.sub('', str_item)\n            total_length += len(cleaned_text)\n    # No 'else' branch is explicitly needed as the docstring states `seq` will be\n    # \"A string or a list/tuple of strings\". If an unhandled type is passed,\n    # it would either lead to an error during `str()` conversion or `_ANSI_RE.sub()`,\n    # which is an expected behavior for invalid input types based on the contract.\n\n    return total_length\n\n\nclass AnsiTextWrapper(TextWrapper):\n    \"\"\"A :obj:`TextWrapper <textwrap.TextWrapper>` object that correctly\n    wraps text containing ANSI codes.\n\n\n    *New in version 0.6*\n\n    Args:\n        width (int, optional): The maximum length of wrapped lines.\n            As long as there are no individual words in the input text\n            longer than this given ``width``,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            guarantees that no output line will be longer than ``width``\n            characters.  Defaults to: ``70``\n        initial_indent (str, optional): Text that will be prepended\n            to the first line of wrapped output. Counts towards the\n            length of the first line. An empty string value will not\n            indent the first line.  Defaults to: ``''`` an empty string.\n        subsequent_indent (str, optional): Text that will be prepended\n            to all lines of wrapped output except the first. Counts\n            towards the length of each line except the first.\n            Defaults to: ``''`` an empty string.\n        expand_tabs (bool, optional): If :obj:`True`, then all tab\n            characters in text will be expanded to spaces using the\n            :obj:`expandtabs <str.expandtabs>`.  Also see the ``tabsize``\n            argument.  Defaults to: :obj:`True`.\n        replace_whitespace (bool, optional): If :obj:`True`, after tab\n            expansion but before wrapping, the wrap() method will replace\n            each whitespace character with a single space. The whitespace\n            characters replaced are as follows: tab, newline, vertical\n            tab, form-feed, and carriage return (``'\\\\t\\\\n\\\\v\\\\f\\\\r'``).\n            Defaults to: :obj:`True`.\n        fix_sentence_endings (bool, optional): If :obj:`True`,\n            :obj:`~flutils.txtutils.AnsiTextWrapper`\n            attempts to detect sentence endings and\n            ensure that sentences are always separated by exactly two\n            spaces. This is generally desired for text in a monospaced\n            font. However, the sentence detection algorithm is imperfect;\n            it assumes that a sentence ending consists of a lowercase\n            letter followed by one of '.', '!', or '?', possibly\n            followed by one of '\"' or \"'\", followed by a space.\n            Defaults to: :obj:`False`.\n        break_long_words (bool, optional): If :obj:`True`, then words\n            longer than width will be broken in order to ensure that no\n            lines are longer than width. If it is :obj:`False`, long words\n            will not be broken, and some lines may be longer than width.\n            (Long words will be put on a line by themselves, in order to\n            minimize the amount by which width is exceeded.)\n            Defaults to: :obj:`True`.\n        drop_whitespace (bool, optional): If :obj:`True`, whitespace at\n            the beginning and ending of every line (after wrapping but\n            before indenting) is dropped. Whitespace at the beginning of\n            the paragraph, however, is not dropped if non-whitespace\n            follows it. If whitespace being dropped takes up an entire\n            line, the whole line is dropped. Defaults to: :obj:`True`\n        break_on_hyphens (bool, optional): If :obj:`True`, wrapping will\n            occur preferably on whitespaces and right after hyphens in\n            compound words, as it is customary in English. If\n            :obj:`false`, only whitespaces will be considered as\n            potentially good places for line breaks, but you need to set\n            ``break_long_words`` to :obj:`False` if you want truly\n            insecable words.  Defaults to: :obj:`True`.\n        tabsize (int, optional): If ``expand_tabs`` is :obj:`True`, then\n            all tab characters in text will be expanded to zero or more\n            spaces, depending on the current column and the given tab size.\n            Defaults to: ``8``.\n        max_lines (:obj:`int` or :obj:`None`, optional): If not :obj:`None`,\n            then the output will contain at most ``max_lines lines``, with\n            ``placeholder`` appearing at the end of the output.\n            Defaults to: :obj:`None`.\n        placeholder (str, optional): Text that will appear at the end of\n            the output text if it has been truncated.\n            Defaults to: ``' [...]'``\n\n    Note:\n        The ``initial_indent``, ``subsequent_indent`` and ``placeholder``\n        parameters can also contain ANSI codes.\n\n    Note:\n        If ``expand_tabs`` is :obj:`False` and ``replace_whitespace``\n        is :obj:`True`, each tab character will be replaced by a single\n        space, which is not the same as tab expansion.\n\n    Note:\n        If ``replace_whitespace`` is :obj:`False`, newlines may appear\n        in the middle of a line and cause strange output. For this reason,\n        text should be split into paragraphs (using :obj:`str.splitlines`\n        or similar) which are wrapped separately.\n\n    Example:\n        Use :obj:`~flutils.txtutils.AnsiTextWrapper` the same way as using\n        :obj:`TextWrapper <textwrap.TextWrapper>`::\n\n            from flutils.txtutils import AnsiTextWrapper\n            text = (\n                '\\\\x1b[31m\\\\x1b[1m\\\\x1b[4mLorem ipsum dolor sit amet, '\n                'consectetur adipiscing elit. Cras fermentum maximus '\n                'auctor. Cras a varius ligula. Phasellus ut ipsum eu '\n                'erat consequat posuere.\\\\x1b[0m Pellentesque habitant '\n                'morbi tristique senectus et netus et malesuada fames ac '\n                'turpis egestas. Maecenas ultricies lacus id massa '\n                'interdum dignissim. Curabitur \\\\x1b[38;2;55;172;230m '\n                'efficitur ante sit amet nibh consectetur, consequat '\n                'rutrum nunc\\\\x1b[0m egestas. Duis mattis arcu eget orci '\n                'euismod, sit amet vulputate ante scelerisque. Aliquam '\n                'ultrices, turpis id gravida vestibulum, tortor ipsum '\n                'consequat mauris, eu cursus nisi felis at felis. '\n                'Quisque blandit lacus nec mattis suscipit. Proin sed '\n                'tortor ante.  Praesent fermentum orci id dolor '\n                '\\\\x1b[38;5;208meuismod, quis auctor nisl sodales.\\\\x1b[0m'\n            )\n            wrapper = AnsiTextWrapper(width=40)\n            wrapped_text = wrapper.fill(text)\n            print(wrapped_text)\n\n        The output:\n\n            .. image:: ../static/AnsiTextWrapper_example_result.png\n               :scale: 75%\n\n    \"\"\"\n\n    def __init__(\n            self,\n            width: int = 70,\n            initial_indent: str = '',\n            subsequent_indent: str = '',\n            expand_tabs: bool = True,\n            replace_whitespace: bool = True,\n            fix_sentence_endings: bool = False,\n            break_long_words: bool = True,\n            drop_whitespace: bool = True,\n            break_on_hyphens: bool = True,\n            tabsize: int = 8,\n            *,\n            max_lines: Optional[int] = None,\n            placeholder: str = ' [...]'\n    ) -> None:\n        self.__initial_indent: str = ''\n        self.__subsequent_indent: str = ''\n        self.__placeholder: str = ''\n        self.width: int = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs: bool = expand_tabs\n        self.replace_whitespace: bool = replace_whitespace\n        self.fix_sentence_endings: bool = fix_sentence_endings\n        self.break_long_words: bool = break_long_words\n        self.drop_whitespace: bool = drop_whitespace\n        self.break_on_hyphens: bool = break_on_hyphens\n        self.tabsize: int = tabsize\n        self.max_lines: Optional[int] = max_lines\n        self.placeholder = placeholder\n\n    @property  # type: ignore[override]\n    def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent\n\n    @initial_indent.setter\n    def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']\n\n    @cached_property\n    def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)\n\n    @property  # type: ignore[override]\n    def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent\n\n    @subsequent_indent.setter\n    def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']\n\n    @cached_property\n    def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)\n\n    @property  # type: ignore[override]\n    def placeholder(self) -> str:  # type: ignore\n        return self.__placeholder\n\n    @placeholder.setter\n    def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']\n\n    @cached_property\n    def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)\n\n    def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]\n\n    def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)\n\n    def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)\n\n\nimport pickle\ndef test_1():\n    assert len_without_ansi('foo\\x1b[38;5;209m') == 3\ntest_1()\n\ndef test_3():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz']) == 9\ntest_3()\n\ndef test_8():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoobar\\x1b[0m'\n    )\ntest_8()\n\ndef test_10():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar'\n        ]\n    )\ntest_10()\n\ndef test_11():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209mbar', '\\x1b[0m')\n    )\ntest_11()\n\ndef test_12():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            '\\x1b[0m'\n        ]\n    )\ntest_12()\n\ndef test_13():\n    assert len_without_ansi('foo\\x1b[38;5;209mbar') == 6\ntest_13()\n\ndef test_18():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209m', 'foobar', '\\x1b[0m')\n    )\ntest_18()\n\ndef test_22():\n    assert 0 == len_without_ansi(\n        []\n    )\ntest_22()\n\ndef test_25():\n    assert len_without_ansi('foo bar') == 7\ntest_25()\n\ndef test_27():\n    assert 6 == len_without_ansi(\n        '\\x1b[38;5;209mfoo\\x1b[0mbar'\n    )\ntest_27()\n\ndef test_28():\n    assert 10 == len_without_ansi(\n        ['\\x1b[38;5;209mfoo', '\\x1b[0m', '\\x1b[38;5;209mbar baz']\n    )\ntest_28()\n\ndef test_32():\n    assert 6 == len_without_ansi(['foo', 'b\\x1b[38;5;209mar'])\ntest_32()\n\ndef test_33():\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m']) == 6\ntest_33()\n\ndef test_37():\n    assert len_without_ansi(('',)) == 0\ntest_37()\n\ndef test_44():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mb\\x1b[0mar')\ntest_44()\n\ndef test_45():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mf',\n            'o',\n            'o',\n            'b',\n            'a',\n            'r\\x1b[0m'\n        ]\n    )\ntest_45()\n\ndef test_46():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar')\ntest_46()\n\ndef test_49():\n    assert 6 == len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m')\ntest_49()\n\ndef test_52():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foo', 'bar', '\\x1b[0m']\n    )\ntest_52()\n\ndef test_55():\n    assert 6 == len_without_ansi(\n        ('\\x1b[38;5;209mfoo', 'bar\\x1b[0m')\n    )\ntest_55()\n\ndef test_57():\n    assert 4 == len_without_ansi('abcd')\ntest_57()\n\ndef test_64():\n    assert len_without_ansi('') == 0\ntest_64()\n\ndef test_70():\n    assert 10 == len_without_ansi('test\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_70()\n\ndef test_83():\n    assert 6 == len_without_ansi('foobar')\ntest_83()\n\ndef test_84():\n    assert 0 == len_without_ansi('')\ntest_84()\n\ndef test_86():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m'))\ntest_86()\n\ndef test_87():\n    assert 1 == len_without_ansi(['a'])\ntest_87()\n\ndef test_88():\n    assert 6 == len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m')\n    )\ntest_88()\n\ndef test_92():\n    assert 6 == len_without_ansi(\n        [\n            '\\x1b[38;5;209mfoo\\x1b[0m',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_92()\n\ndef test_100():\n    assert len_without_ansi('\\x1b[38;5;209mfoo') == 3\ntest_100()\n\ndef test_103():\n    assert 6 == len_without_ansi(('\\x1b[38;5;209mfoo\\x1b[0m', 'bar'))\ntest_103()\n\ndef test_107():\n    assert 0 == len_without_ansi(\n        ['\\x1b[38;5;209m', '\\x1b[0m']\n    )\ntest_107()\n\ndef test_108():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar'\n        ]\n    )\ntest_108()\n\ndef test_109():\n    assert 6 == len_without_ansi(\n        [\n            'foo\\x1b[38;5;209m',\n            'bar\\x1b[0m'\n        ]\n    )\ntest_109()\n\ndef test_110():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mb\\x1b[0mar\\x1b[0m'\n        ]\n    )\ntest_110()\n\ndef test_112():\n    assert 3 == len_without_ansi('abc')\ntest_112()\n\ndef test_113():\n    assert len_without_ansi(()) == 0\ntest_113()\n\ndef test_114():\n    assert len_without_ansi('foo') == 3\ntest_114()\n\ndef test_118():\n    assert 6 == len_without_ansi(('foo', '\\x1b[38;5;209mbar\\x1b[0m'))\ntest_118()\n\ndef test_120():\n    assert len_without_ansi('hello world') == 11\ntest_120()\n\ndef test_136():\n    assert len_without_ansi([]) == 0\ntest_136()\n\ndef test_143():\n    assert 6 == len_without_ansi(('foo\\x1b[38;5;209mbar\\x1b[0m'))\ntest_143()\n\ndef test_148():\n    assert 6 == len_without_ansi('\\x1b[38;5;209mfoobar\\x1b[0m')\ntest_148()\n\ndef test_149():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    )\ntest_149()\n\ndef test_153():\n    assert 12 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_153()\n\ndef test_155():\n    assert 6 == len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar\\x1b[0m'\n        ]\n    )\ntest_155()\n\ndef test_172():\n    assert 0 == len_without_ansi(\n        '\\x1b[0m'\n    )\ntest_172()\n\ndef test_176():\n    assert 6 == len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '']\n    )\ntest_176()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m')) == output\ntest_2()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'f', '\\\\x1b[0m']\n    ) == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'ob', 'ar\\\\x1b[0m']\n    ) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo bar baz'\n    ) == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209m',\n        'foo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_9()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar') == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m']\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m']\n    ) == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209mfoo') == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m']) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\x1b[38;5;209mfoo\\x1b[38;5;209m',\n                              '\\x1b[38;5;209mbar\\x1b[38;5;209m']) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1m\\\\x1b[38;5;209mw\\\\x1b[0m') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m']) == output\ntest_29()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')\n    ) == output\ntest_30()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', 'bar\\\\x1b[0m']\n    ) == output\ntest_31()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209m',\n            'b',\n            'a',\n            'r\\x1b[0m',\n            'bar'\n        ]\n    ) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoobar\\\\x1b[0m',\n                              '\\\\x1b[38;5;209mfoobar\\\\x1b[0m']) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oba', 'r\\\\x1b[0m']\n    ) == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'f', '\\x1b[0m', 'b', '\\x1b[0m', 'a', 'r']\n    ) == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo bar', 'baz']\n    ) == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\\\x1b[0mbar') == output\ntest_41()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m', '\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']\n    ) == output\ntest_42()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello']\n    ) == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo ', '\\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mb', 'ar']) == output\ntest_48()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\nbar') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'foobar')) == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\x1b[38;5;209m'\n    ) == output\ntest_54()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')) == output\ntest_56()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foobar\\\\x1b[0m')) == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\rbar') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']) == output\ntest_60()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m',\n            'hello\\\\x1b[31;1mworld\\\\x1b[0m'\n        )\n    ) == output\ntest_61()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            '\\\\x1b[38;5;209mbar\\\\x1b[0m',\n        )\n    ) == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_63()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m', 'baz')) == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfo', 'oob', 'ar\\\\x1b[0m']\n    ) == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo', '\\\\x1b[38;5;209mbar', '\\\\x1b[0m', 'foo\\\\x1b[38;5;209m', 'bar\\\\x1b[0m']\n    ) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209m', 'bar', '\\\\x1b[0m']) == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_69()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', 'bar\\\\x1b[0m']) == output\ntest_71()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz'\n        ]\n    ) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\n\\rbar') == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209mfoo') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'ba', 'r']) == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar')) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mf', 'oo', 'bar\\\\x1b[0m']\n    ) == output\ntest_79()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m', 'foobar']\n    ) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',]) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\nbar\\\\x1b[0m') == output\ntest_82()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0mbar\\\\x1b[0m') == output\ntest_85()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('abc') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar']\n    ) == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\t\\n\\rbar') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\x1b[38;5;209mfoo\\x1b[0m', '\\x1b[38;5;209mbar\\x1b[0m')\n    ) == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            'bar\\x1b[38;5;209m',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', 'bar', '\\\\x1b[0m')) == output\ntest_96()\n\ndef test_97():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_97\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz\\x1b[0m'\n        ]\n    ) == output\ntest_97()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0m', 'bar', '\\\\x1b[38;5;209m', 'baz']\n    ) == output\ntest_99()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[0mfoo\\\\x1b[38;5;209m\\\\x1b[0mbar\\\\x1b[38;5;209m\\\\x1b[0m') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m\\x1b[38;5;209m') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'foo', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foobar', '\\\\x1b[38;5;209mbar']) == output\ntest_106()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m', '\\\\x1b[38;5;209m']) == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209mb',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209mfo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209mj',\n            '\\x1b[38;5;209mu',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209mr',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m',)) == output\ntest_116()\n\ndef test_117():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_117\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        [\n            'foo',\n            '\\x1b[38;5;209mbar',\n            'baz'\n        ]\n    ) == output\ntest_117()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0m', 'bar']) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n    ) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo\\x1b[0m\\\\x1b[38;5;209mbar\\\\x1b[0m') == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209mbar', '\\x1b[0m', 'baz')\n    ) == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[0m') == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(''.join(\n        ['\\x1b[38;5;209m', 'foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m']\n    )) == output\ntest_128()\n\ndef test_129():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_129\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209m', 'foo', '\\\\x1b[0mbar']) == output\ntest_129()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo',\n            'bar\\\\x1b[0m',\n        )\n    ) == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m') == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209m', 'foobar', '\\\\x1b[0m')\n    ) == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo', 'bar']) == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo\\x1b[38;5;209m', 'bar\\x1b[0m', 'baz')\n    ) == output\ntest_134()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['foo \\x1b[38;5;209mbar', '\\x1b[0m baz']\n    ) == output\ntest_135()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['\\\\x1b[38;5;209mfoo', '\\\\x1b[0mbar']) == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209m') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('foo', '\\x1b[38;5;209m', 'bar', '\\x1b[0m', 'baz')\n    ) == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo bar') == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo', '\\\\x1b[0mb', 'ar')) == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoobar\\\\x1b[0m') == output\ntest_142()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\x1b[38;5;209m', 'foobar', '\\x1b[0m', '', '\\x1b[38;5;209m', 'foobar', '\\x1b[0m']\n    ) == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('hello\\\\x1b[31;1mworld\\\\x1b[0m') == output\ntest_145()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209m\\\\x1b[38;5;209mfoobar\\\\x1b[0m\\\\x1b[38;5;209m') == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('foo', 'bar')) == output\ntest_147()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi({'\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m'}) == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoobar\\\\x1b[0m')) == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\x1b[38;5;209mfoo\\x1b[38;5;209mbar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209m\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_154()\n\ndef test_158():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_158\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi([\n        '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n        '\\\\x1b[38;5;209m',\n        'bar\\\\x1b[0m'\n    ]) == output\ntest_158()\n\ndef test_159():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_159\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('\\\\x1b[38;5;209mfoo bar\\\\x1b[0m') == output\ntest_159()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            'The quick brown ',\n            '\\x1b[38;5;209m',\n            'roa',\n            '\\x1b[38;5;209mn ',\n            '\\x1b[38;5;209m',\n            'fo',\n            '\\x1b[38;5;209m',\n            'x',\n            '\\x1b[38;5;209m',\n            'j',\n            '\\x1b[38;5;209m',\n            'u',\n            '\\x1b[38;5;209m',\n            'mb',\n            '\\x1b[38;5;209m',\n            'r',\n            '\\x1b[38;5;209m',\n            's.\\x1b[0m'\n        )\n    ) == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['foo\\x1b[38;5;209m', 'bar\\x1b[38;5;209m',\n                              'baz\\x1b[38;5;209m']) == output\ntest_161()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        'foo \\x1b[38;5;209mbar\\x1b[0m baz'\n    ) == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello')\n    ) == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\tbar') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(r'\\x1b[38;5;209mfoo\\x1b[0m bar\\x1b[38;5;209m') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(['ab', 'cd']) == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(('\\\\x1b[38;5;209mfoo\\\\x1b[0m', '\\\\x1b[38;5;209mbar\\\\x1b[0m')) == output\ntest_169()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi('foo\\x1b[38;5;209mbar\\x1b[0m') == output\ntest_170()\n\ndef test_171():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_171\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ['\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world']\n    ) == output\ntest_171()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209m',\n            'foobar',\n            '\\\\x1b[0m',\n        )\n    ) == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        ('\\\\x1b[38;5;209mfoobar\\\\x1b[0m', 'hello', 'world')\n    ) == output\ntest_174()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+txtutils/len_without_ansi/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len_without_ansi(\n        (\n            '\\\\x1b[38;5;209mfoo\\\\x1b[0m',\n            'bar\\\\x1b[38;5;209m\\\\x1b[0m',\n        )\n    ) == output\ntest_175()\n\n\n"]}
{"task_id": 132, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_unicode_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    if not text:\n        return \"\"\n\n    result = []\n    for char in text:\n        code_point = ord(char)\n        if code_point <= 0xFF:  # Basic Latin and Latin-1 Supplement (U+0000 to U+00FF)\n            # Represent as \\xXX\n            result.append(f\"\\\\x{code_point:02x}\")\n        elif code_point <= 0xFFFF:  # Basic Multilingual Plane (BMP) (U+0100 to U+FFFF)\n            # Represent as \\uXXXX\n            result.append(f\"\\\\u{code_point:04x}\")\n        else:  # Supplementary Planes (U+10000 to U+10FFFF)\n            # Represent as \\UXXXXXXXX\n            result.append(f\"\\\\U{code_point:08x}\")\n    return \"\".join(result)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_unicode_literal(t) # Changed from as_literal to match function name\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    if not text:\n        return \"\"\n\n    escaped_chars = []\n    for char in text:\n        code_point = ord(char)\n        if code_point < 0x100:  # U+0000 to U+00FF (Basic Latin, Latin-1 Supplement)\n            # Use \\xNN format\n            escaped_chars.append(f\"\\\\x{code_point:02x}\")\n        elif code_point < 0x10000:  # U+0100 to U+FFFF (BMP characters)\n            # Use \\uNNNN format\n            escaped_chars.append(f\"\\\\u{code_point:04x}\")\n        else:  # U+10000 to U+10FFFF (Supplementary Plane characters)\n            # Use \\UNNNNNNNN format\n            escaped_chars.append(f\"\\\\U{code_point:08x}\")\n    \n    return \"\".join(escaped_chars)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    if not text:\n        return ''\n\n    escaped_chars = []\n    for char in text:\n        code_point = ord(char)\n        if code_point < 0x100:  # U+0000 to U+00FF (Basic Latin, Latin-1 Supplement)\n            escaped_chars.append(f'\\\\x{code_point:02x}')\n        elif code_point < 0x10000:  # U+0100 to U+FFFF (Basic Multilingual Plane)\n            escaped_chars.append(f'\\\\u{code_point:04x}')\n        else:  # U+10000 onwards (Supplementary Planes)\n            escaped_chars.append(f'\\\\U{code_point:08x}')\n    return ''.join(escaped_chars)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result_parts = []\n    for char in text:\n        code_point = ord(char)\n        if code_point <= 0xFF:\n            # For characters with code points up to 0xFF (e.g., ASCII, Latin-1),\n            # use the \\xHH format.\n            # We use '\\\\x' to ensure the output string contains a literal backslash\n            # followed by 'x', effectively escaping the backslash itself in the string literal.\n            hex_val = f\"{code_point:02x}\"\n            result_parts.append(f\"\\\\\\\\x{hex_val}\")\n        elif code_point <= 0xFFFF:\n            # For characters with code points up to 0xFFFF (Basic Multilingual Plane),\n            # use the \\uHHHH format.\n            hex_val = f\"{code_point:04x}\"\n            result_parts.append(f\"\\\\\\\\u{hex_val}\")\n        else:\n            # For characters with code points greater than 0xFFFF (Supplementary Planes),\n            # use the \\U00HHHHHHH format.\n            hex_val = f\"{code_point:08x}\"\n            result_parts.append(f\"\\\\\\\\U{hex_val}\")\n    \n    return \"\".join(result_parts)", "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    escaped_chars = []\n    for char in text:\n        cp = ord(char)\n        if cp <= 0xFF:  # Code points 0x00 to 0xFF (255) -> \\xXX\n            # Example: '\\x31'\n            escaped_chars.append(f'\\\\\\\\x{cp:02x}')\n        elif cp <= 0xFFFF:  # Code points 0x100 to 0xFFFF (65535) -> \\uXXXX\n            # Example: '\\u2605'\n            escaped_chars.append(f'\\\\\\\\u{cp:04x}')\n        else:  # Code points 0x10000 to 0x10FFFF (1114111) -> \\UXXXXXXXX\n            # Example: '\\U0001f6d1'\n            escaped_chars.append(f'\\\\\\\\U{cp:08x}')\n    return ''.join(escaped_chars)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_unicode_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    if not text:\n        return \"\"\n\n    result = []\n    for char in text:\n        code_point = ord(char)\n        if code_point <= 0xFF:  # Basic Latin and Latin-1 Supplement (U+0000 to U+00FF)\n            # Represent as \\xXX\n            result.append(f\"\\\\x{code_point:02x}\")\n        elif code_point <= 0xFFFF:  # Basic Multilingual Plane (BMP) (U+0100 to U+FFFF)\n            # Represent as \\uXXXX\n            result.append(f\"\\\\u{code_point:04x}\")\n        else:  # Supplementary Planes (U+10000 to U+10FFFF)\n            # Represent as \\UXXXXXXXX\n            result.append(f\"\\\\U{code_point:08x}\")\n    return \"\".join(result)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_unicode_literal(t) # Changed from as_literal to match function name\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    if not text:\n        return \"\"\n\n    escaped_chars = []\n    for char in text:\n        code_point = ord(char)\n        if code_point < 0x100:  # U+0000 to U+00FF (Basic Latin, Latin-1 Supplement)\n            # Use \\xNN format\n            escaped_chars.append(f\"\\\\x{code_point:02x}\")\n        elif code_point < 0x10000:  # U+0100 to U+FFFF (BMP characters)\n            # Use \\uNNNN format\n            escaped_chars.append(f\"\\\\u{code_point:04x}\")\n        else:  # U+10000 to U+10FFFF (Supplementary Plane characters)\n            # Use \\UNNNNNNNN format\n            escaped_chars.append(f\"\\\\U{code_point:08x}\")\n    \n    return \"\".join(escaped_chars)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    if not text:\n        return ''\n\n    escaped_chars = []\n    for char in text:\n        code_point = ord(char)\n        if code_point < 0x100:  # U+0000 to U+00FF (Basic Latin, Latin-1 Supplement)\n            escaped_chars.append(f'\\\\x{code_point:02x}')\n        elif code_point < 0x10000:  # U+0100 to U+FFFF (Basic Multilingual Plane)\n            escaped_chars.append(f'\\\\u{code_point:04x}')\n        else:  # U+10000 onwards (Supplementary Planes)\n            escaped_chars.append(f'\\\\U{code_point:08x}')\n    return ''.join(escaped_chars)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    result_parts = []\n    for char in text:\n        code_point = ord(char)\n        if code_point <= 0xFF:\n            # For characters with code points up to 0xFF (e.g., ASCII, Latin-1),\n            # use the \\xHH format.\n            # We use '\\\\x' to ensure the output string contains a literal backslash\n            # followed by 'x', effectively escaping the backslash itself in the string literal.\n            hex_val = f\"{code_point:02x}\"\n            result_parts.append(f\"\\\\\\\\x{hex_val}\")\n        elif code_point <= 0xFFFF:\n            # For characters with code points up to 0xFFFF (Basic Multilingual Plane),\n            # use the \\uHHHH format.\n            hex_val = f\"{code_point:04x}\"\n            result_parts.append(f\"\\\\\\\\u{hex_val}\")\n        else:\n            # For characters with code points greater than 0xFFFF (Supplementary Planes),\n            # use the \\U00HHHHHHH format.\n            hex_val = f\"{code_point:08x}\"\n            result_parts.append(f\"\\\\\\\\U{hex_val}\")\n    \n    return \"\".join(result_parts)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped Python literal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_unicode_literal\n    >>> t = '1.★ 🛑'\n    >>> as_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    escaped_chars = []\n    for char in text:\n        cp = ord(char)\n        if cp <= 0xFF:  # Code points 0x00 to 0xFF (255) -> \\xXX\n            # Example: '\\x31'\n            escaped_chars.append(f'\\\\\\\\x{cp:02x}')\n        elif cp <= 0xFFFF:  # Code points 0x100 to 0xFFFF (65535) -> \\uXXXX\n            # Example: '\\u2605'\n            escaped_chars.append(f'\\\\\\\\u{cp:04x}')\n        else:  # Code points 0x10000 to 0x10FFFF (1114111) -> \\UXXXXXXXX\n            # Example: '\\U0001f6d1'\n            escaped_chars.append(f'\\\\\\\\U{cp:08x}')\n    return ''.join(escaped_chars)\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert \"\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal('★ 🛑')\ntest_0()\n\ndef test_1():\n    assert re.sub(r'\\\\x[0-9a-f]{2}|\\\\u[0-9a-f]{4}|\\\\U[0-9a-f]{8}',\n                   '',\n                   as_escaped_unicode_literal('1.★ 🛑')) == ''\ntest_1()\n\ndef test_2():\n    assert '1.★ 🛑' == eval('\"{}\"'.format(as_escaped_unicode_literal('1.★ 🛑')))\ntest_2()\n\ndef test_3():\n    assert re.match(\n        r'^\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1$',\n        as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_3()\n\ndef test_4():\n    assert as_escaped_unicode_literal('1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_4()\n\ndef test_5():\n    assert \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\" == as_escaped_unicode_literal(\"1.★ 🛑\")\ntest_5()\n\ndef test_7():\n    assert '\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('★ 🛑')\ntest_7()\n\ndef test_11():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal(\n        '1.★ 🛑'\n    )\ntest_11()\n\ndef test_15():\n    assert as_escaped_unicode_literal(  '1.★ 🛑') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_15()\n\ndef test_17():\n    assert re.match(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1',\n                     as_escaped_unicode_literal('1.★ 🛑'))\ntest_17()\n\ndef test_19():\n    assert as_escaped_unicode_literal(\n        '1.★ 🛑'\n    ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_19()\n\ndef test_20():\n    assert as_escaped_unicode_literal(\n            '1.★ 🛑'\n        ) == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_20()\n\ndef test_22():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_22()\n\ndef test_25():\n    assert (\n        as_escaped_unicode_literal('1.★ 🛑') ==\n        r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'\n    )\ntest_25()\n\ndef test_27():\n    assert r'\\x31\\x2e\\u2605\\x20\\U0001f6d1' == \\\n            as_escaped_unicode_literal('1.★ 🛑')\ntest_27()\n\ndef test_29():\n    assert '\\\\U0001f6d1' == as_escaped_unicode_literal('🛑')\ntest_29()\n\ndef test_30():\n    assert '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1' == as_escaped_unicode_literal('1.★ 🛑')\ntest_30()\n\ndef test_33():\n    assert r\"\\x31\\x2e\\u2605\\x20\\U0001f6d1\" == as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\ntest_33()\n\ndef test_34():\n    assert re.search(r'\\\\u2605', as_escaped_unicode_literal('1.★ 🛑')).group(0) == '\\\\u2605'\ntest_34()\n\ndef test_35():\n    assert '\\\\u2605' == as_escaped_unicode_literal('★')\ntest_35()\n\ndef test_36():\n    assert (\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        == as_escaped_unicode_literal('1.★ 🛑')\n    )\ntest_36()\n\ndef test_38():\n    assert (as_escaped_unicode_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_38()\n\ndef test_39():\n    assert re.match(\n        (\n            r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ),\n        as_escaped_unicode_literal(\n            '1.★ 🛑'\n        )\n    )\ntest_39()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑') == output\ntest_6()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑') == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('🛑 ‼️') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑!') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1. 🛑‼️') == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-8')) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑')) == output\ntest_24()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_unicode_literal('1.★ 🛑').encode('utf-16-le')) == output\ntest_28()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.search(r'\\\\x31', as_escaped_unicode_literal('1')).group(0) == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_unicode_literal('1.★ 🛑') == output\ntest_32()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_unicode_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.fullmatch(\n        r'\\\\x31\\\\x2e\\\\u2605 \\\\u2119\\\\u26d1',\n        as_escaped_unicode_literal('1.★ ⛐⛑')\n    ) == output\ntest_37()\n\n\n"]}
{"task_id": 133, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    # To convert a string to its UTF-8 escaped hexadecimal literal form,\n    # we first encode the string into a sequence of UTF-8 bytes.\n    # Then, for each byte in this sequence, we convert it to its two-digit\n    # hexadecimal representation and prefix it with '\\x'.\n\n    # 1. Encode the input string to UTF-8 bytes.\n    #    This returns a bytes object, where each element is an integer\n    #    representing a byte (0-255).\n    utf8_bytes = text.encode('utf-8')\n\n    # 2. Initialize a list to hold the escaped hexadecimal strings for each byte.\n    escaped_parts = []\n\n    # 3. Iterate through each byte value in the encoded bytes.\n    for byte_value in utf8_bytes:\n        # Format the byte value as a two-digit hexadecimal string (e.g., 49 -> '31', 226 -> 'e2').\n        # The '02x' format specifier ensures two digits, padding with a leading zero if necessary,\n        # and 'x' specifies lowercase hexadecimal.\n        # We then prefix this with '\\\\x' to form the escaped literal.\n        hex_literal = f'\\\\x{byte_value:02x}'\n        escaped_parts.append(hex_literal)\n\n    # 4. Join all the individual escaped parts to form the final string.\n    return ''.join(escaped_parts)", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n        text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_utf8_literal\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError('Argument \"text\" must be a str.')\n\n    # Encode the input string to UTF-8 bytes.\n    # This will give us a bytes object, e.g., b'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n    utf8_bytes = text.encode('utf-8')\n\n    # Initialize a list to store the escaped hexadecimal representations of each byte.\n    escaped_parts = []\n\n    # Iterate over each byte in the UTF-8 encoded sequence.\n    # Each 'b' in the loop will be an integer representing the byte's value (0-255).\n    for b in utf8_bytes:\n        # Convert the integer byte value to a two-digit lowercase hexadecimal string,\n        # zero-padded if necessary (e.g., 10 -> '0a', 255 -> 'ff').\n        # Then prefix it with '\\\\x'.\n        escaped_parts.append(f'\\\\x{b:02x}')\n\n    # Join all the escaped byte strings together to form the final output string.\n    return ''.join(escaped_parts)", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    # Encode the input string to UTF-8 bytes.\n    # This converts the string of Unicode characters into a sequence of bytes\n    # according to the UTF-8 encoding standard.\n    utf8_bytes = text.encode('utf8')\n\n    # Initialize a list to store the hexadecimal representation of each byte.\n    escaped_parts = []\n\n    # Iterate over each byte in the UTF-8 encoded sequence.\n    # Each 'byte_val' here is an integer from 0 to 255.\n    for byte_val in utf8_bytes:\n        # Convert the integer byte value to its hexadecimal string representation.\n        # The f-string `f'\\\\x{byte_val:02x}'` formats the integer:\n        # - `\\\\x` adds the literal backslash and 'x' prefix.\n        # - `:02x` formats the integer as a hexadecimal number (`x`),\n        #   padding with a leading zero if necessary to ensure two digits (`02`).\n        escaped_parts.append(f'\\\\x{byte_val:02x}')\n\n    # Join all the individual escaped byte strings into a single string.\n    return ''.join(escaped_parts)", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out_parts = []\n    # Encode the input string to UTF-8 bytes.\n    utf8_bytes = text.encode('utf8')\n\n    # Iterate over each byte in the UTF-8 encoded string.\n    for byte_val in utf8_bytes:\n        # Convert the byte value to its hexadecimal representation,\n        # formatted to two digits with a leading zero if necessary,\n        # and prefix with '\\x'.\n        # For example, 49 (decimal for '1') becomes '31' in hex, formatted as '\\x31'.\n        # 226 (decimal for first byte of '★') becomes 'e2' in hex, formatted as '\\xe2'.\n        escaped_byte = '\\\\x{:02x}'.format(byte_val)\n        out_parts.append(escaped_byte)\n\n    # Join all the escaped byte parts to form the final string.\n    return \"\".join(out_parts)", "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out_parts = []\n    for char in text:\n        # Encode the character to its UTF-8 byte representation.\n        # This will return a bytes object (e.g., b'\\xe2\\x98\\x85' for '★').\n        utf8_bytes = char.encode('utf8')\n\n        # Iterate over each byte in the utf8_bytes object.\n        # Each 'byte' will be an integer between 0 and 255.\n        for byte in utf8_bytes:\n            # Convert the byte (integer) to its two-digit hexadecimal\n            # string representation, prefixed with '\\x'.\n            # For example, 0x31 (49) becomes '\\x31'.\n            # 0x01 (1) becomes '\\x01' due to 0-padding.\n            out_parts.append('\\\\x{:02x}'.format(byte))\n\n    # Join all the '\\xNN' parts into a single string.\n    return ''.join(out_parts)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    # To convert a string to its UTF-8 escaped hexadecimal literal form,\n    # we first encode the string into a sequence of UTF-8 bytes.\n    # Then, for each byte in this sequence, we convert it to its two-digit\n    # hexadecimal representation and prefix it with '\\x'.\n\n    # 1. Encode the input string to UTF-8 bytes.\n    #    This returns a bytes object, where each element is an integer\n    #    representing a byte (0-255).\n    utf8_bytes = text.encode('utf-8')\n\n    # 2. Initialize a list to hold the escaped hexadecimal strings for each byte.\n    escaped_parts = []\n\n    # 3. Iterate through each byte value in the encoded bytes.\n    for byte_value in utf8_bytes:\n        # Format the byte value as a two-digit hexadecimal string (e.g., 49 -> '31', 226 -> 'e2').\n        # The '02x' format specifier ensures two digits, padding with a leading zero if necessary,\n        # and 'x' specifies lowercase hexadecimal.\n        # We then prefix this with '\\\\x' to form the escaped literal.\n        hex_literal = f'\\\\x{byte_value:02x}'\n        escaped_parts.append(hex_literal)\n\n    # 4. Join all the individual escaped parts to form the final string.\n    return ''.join(escaped_parts)\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n        text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_utf8_literal\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError('Argument \"text\" must be a str.')\n\n    # Encode the input string to UTF-8 bytes.\n    # This will give us a bytes object, e.g., b'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n    utf8_bytes = text.encode('utf-8')\n\n    # Initialize a list to store the escaped hexadecimal representations of each byte.\n    escaped_parts = []\n\n    # Iterate over each byte in the UTF-8 encoded sequence.\n    # Each 'b' in the loop will be an integer representing the byte's value (0-255).\n    for b in utf8_bytes:\n        # Convert the integer byte value to a two-digit lowercase hexadecimal string,\n        # zero-padded if necessary (e.g., 10 -> '0a', 255 -> 'ff').\n        # Then prefix it with '\\\\x'.\n        escaped_parts.append(f'\\\\x{b:02x}')\n\n    # Join all the escaped byte strings together to form the final output string.\n    return ''.join(escaped_parts)\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\\\\\\\\x91'\n    \"\"\"\n    # Encode the input string to UTF-8 bytes.\n    # This converts the string of Unicode characters into a sequence of bytes\n    # according to the UTF-8 encoding standard.\n    utf8_bytes = text.encode('utf8')\n\n    # Initialize a list to store the hexadecimal representation of each byte.\n    escaped_parts = []\n\n    # Iterate over each byte in the UTF-8 encoded sequence.\n    # Each 'byte_val' here is an integer from 0 to 255.\n    for byte_val in utf8_bytes:\n        # Convert the integer byte value to its hexadecimal string representation.\n        # The f-string `f'\\\\x{byte_val:02x}'` formats the integer:\n        # - `\\\\x` adds the literal backslash and 'x' prefix.\n        # - `:02x` formats the integer as a hexadecimal number (`x`),\n        #   padding with a leading zero if necessary to ensure two digits (`02`).\n        escaped_parts.append(f'\\\\x{byte_val:02x}')\n\n    # Join all the individual escaped byte strings into a single string.\n    return ''.join(escaped_parts)\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_escaped_utf8_literal\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out_parts = []\n    # Encode the input string to UTF-8 bytes.\n    utf8_bytes = text.encode('utf8')\n\n    # Iterate over each byte in the UTF-8 encoded string.\n    for byte_val in utf8_bytes:\n        # Convert the byte value to its hexadecimal representation,\n        # formatted to two digits with a leading zero if necessary,\n        # and prefix with '\\x'.\n        # For example, 49 (decimal for '1') becomes '31' in hex, formatted as '\\x31'.\n        # 226 (decimal for first byte of '★') becomes 'e2' in hex, formatted as '\\xe2'.\n        escaped_byte = '\\\\x{:02x}'.format(byte_val)\n        out_parts.append(escaped_byte)\n\n    # Join all the escaped byte parts to form the final string.\n    return \"\".join(out_parts)\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n    text (:obj:`str`): The string to convert.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each character of the given ``text`` converted\n    into an escaped UTF8 hexadecimal.\n\n    Example:\n    >>> from flutils.strutils import as_literal_utf8\n    >>> t = '1.★ 🛑'\n    >>> as_escaped_utf8_literal(t)\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n    \\\\\\\\x91'\n    \"\"\"\n    out_parts = []\n    for char in text:\n        # Encode the character to its UTF-8 byte representation.\n        # This will return a bytes object (e.g., b'\\xe2\\x98\\x85' for '★').\n        utf8_bytes = char.encode('utf8')\n\n        # Iterate over each byte in the utf8_bytes object.\n        # Each 'byte' will be an integer between 0 and 255.\n        for byte in utf8_bytes:\n            # Convert the byte (integer) to its two-digit hexadecimal\n            # string representation, prefixed with '\\x'.\n            # For example, 0x31 (49) becomes '\\x31'.\n            # 0x01 (1) becomes '\\x01' due to 0-padding.\n            out_parts.append('\\\\x{:02x}'.format(byte))\n\n    # Join all the '\\xNN' parts into a single string.\n    return ''.join(out_parts)\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_0()\n\ndef test_2():\n    assert b'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == \\\n            bytes(as_escaped_utf8_literal('1.★ 🛑'), 'utf8')\ntest_2()\n\ndef test_3():\n    assert as_escaped_utf8_literal('1.★ 🛑') == (\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_3()\n\ndef test_4():\n    assert (\n        r'\\x31\\x2e\\xe2\\x98\\x85\\x20\\xf0\\x9f\\x9b\\x91'\n        ==\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_4()\n\ndef test_5():\n    assert (\n            as_escaped_utf8_literal('1.★ 🛑') ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_5()\n\ndef test_6():\n    assert ''.join([\n        '\\\\x31', '\\\\x2e', '\\\\xe2', '\\\\x98', '\\\\x85', '\\\\x20', '\\\\xf0', '\\\\x9f',\n        '\\\\x9b', '\\\\x91'\n    ]) == as_escaped_utf8_literal('1.★ 🛑')\ntest_6()\n\ndef test_8():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_8()\n\ndef test_9():\n    assert (\n            as_escaped_utf8_literal(\n                    '1.★ 🛑'\n            )\n            ==\n            '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n    )\ntest_9()\n\ndef test_10():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('🛑'))) / float(len('\\\\xf0\\\\x9f\\\\x9b\\\\x91')) <= 1.0\ntest_10()\n\ndef test_22():\n    assert re.match(\n            r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n            as_escaped_utf8_literal('1.★ 🛑')\n        )\ntest_22()\n\ndef test_23():\n    assert (\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\n        == as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_23()\n\ndef test_24():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n    '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_24()\n\ndef test_27():\n    assert as_escaped_utf8_literal('1.★ 🛑') == \\\n                '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91'\ntest_27()\n\ndef test_28():\n    assert re.match(\n        r'\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑')\n    )\ntest_28()\n\ndef test_30():\n    assert 1.0 <= float(len(as_escaped_utf8_literal('★'))) / float(len('\\\\xe2\\\\x98\\\\x85')) <= 1.0\ntest_30()\n\ndef test_32():\n    assert (re.match(\n        r'(?s)^\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91$',\n        as_escaped_utf8_literal('1.★ 🛑')\n    ) is not None)\ntest_32()\n\ndef test_35():\n    assert '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91' == as_escaped_utf8_literal('1.★ 🛑')\ntest_35()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_1()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_7()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(re.findall(r'\\\\x[0-9a-fA-F]{2}',\n                               as_escaped_utf8_literal('1.★ 🛑'))) == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_13()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        '\\\\x31\\\\x2e\\\\xe2\\\\x98\\\\x85\\\\x20\\\\xf0\\\\x9f\\\\x9b\\\\x91',\n        as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_14()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.sub(\n        r'[\\s\\\\]+',\n        '',\n        \"'%s'\" % as_escaped_utf8_literal('1.★ 🛑'),\n    ) == output\ntest_16()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(\n        r'[^\\x00-\\x7f]',\n        as_escaped_utf8_literal('★')\n    ) == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n            '1.★ 🛑',\n    ) == output\ntest_21()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(r'1.★ 🛑') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(\n        '1.★ 🛑'\n    ) == output\ntest_31()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal(u'\\u00A0') == output\ntest_34()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert as_escaped_utf8_literal('1.★ 🛑') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/as_escaped_utf8_literal/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(as_escaped_utf8_literal('1.★ 🛑')) == output\ntest_37()\n\n\n"]}
{"task_id": 134, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # _CAMEL_TO_UNDERSCORE_RE is defined in the file content as:\n    # _CAMEL_TO_UNDERSCORE_RE = re.compile(\n    #     '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n    # )\n    # This regex captures an uppercase letter that:\n    # 1. Is preceded by a lowercase letter or digit (e.g., 'fooBar' -> 'Bar')\n    # 2. Is not at the start of the string AND is followed by a lowercase letter\n    #    (e.g., 'HTTPRequest' -> 'Request')\n\n    # Replace the captured uppercase letter with an underscore followed by the\n    # lowercase version of that letter. The r'_\\1' refers to inserting an\n    # underscore and then the content of the first captured group (the matched\n    # uppercase letter).\n    underscored_text = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n\n    # Convert the entire resulting string to lowercase.\n    return underscored_text.lower()", "import re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\n# noinspection PySameParameterValue\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()", "import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # The _CAMEL_TO_UNDERSCORE_RE regex is defined globally in this file.\n    # It captures an uppercase letter that should be preceded by an underscore.\n    # Specifically, it matches:\n    # 1. An uppercase letter ([A-Z]) that is preceded by a lowercase letter\n    #    or a digit ((?<=[a-z0-9])). This handles transitions like 'fooBar' -> 'foo_Bar'.\n    # 2. Or, an uppercase letter ([A-Z]) that is not at the start of the string\n    #    ((?!^)) and is followed by a lowercase letter ((?=[a-z])). This handles\n    #    transitions for acronyms like 'HTTPResponse' -> 'HTTP_Response'.\n    #\n    # The '_\\1' replacement inserts an underscore before the matched uppercase letter.\n    s1 = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Finally, convert the entire string to lowercase to ensure consistency\n    # (e.g., 'FooBar' becomes 'foo_bar', 'HTTPResponse' becomes 'http_response').\n    return s1.lower()", "import re\n\n# The _CAMEL_TO_UNDERSCORE_RE regular expression is defined in the file content\n# outside of the function. It's designed to find the points where a camel-cased\n# string needs an underscore inserted.\n#\n# The regex consists of two alternative patterns:\n# 1. ((?<=[a-z0-9])[A-Z]): Matches an uppercase letter that is preceded by a\n#    lowercase letter or a digit. This handles transitions like 'fooBar' -> 'foo_Bar'.\n# 2. (?!^)[A-Z](?=[a-z]): Matches an uppercase letter that is not at the\n#    beginning of the string and is followed by a lowercase letter. This handles\n#    transitions within acronyms or from an acronym to a word, like 'HTTPRequest'\n#    where 'R' is followed by 'e', leading to 'HTTP_Request'.\n# The entire pattern is wrapped in a capturing group `(...)` so that `\\1` in\n# the replacement string refers to the matched uppercase character.\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use re.sub to replace the matched uppercase characters with an underscore\n    # followed by the character itself (which will then be lowercased).\n    # The r'_\\1' means an underscore followed by the content of the first\n    # capturing group (which is the matched uppercase letter).\n    # Finally, convert the entire resulting string to lowercase.\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()", "import re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # _CAMEL_TO_UNDERSCORE_RE is defined in the file content:\n    # _CAMEL_TO_UNDERSCORE_RE = re.compile(\n    #     '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n    # )\n    # This regex matches an uppercase letter that:\n    # 1. Is preceded by a lowercase letter or a digit (e.g., 'fooBar' -> 'B').\n    # 2. Is not at the beginning of the string AND is followed by a lowercase\n    #    letter (e.g., 'FOOBar' -> 'B').\n    # The replacement adds an underscore before the matched uppercase letter.\n    # The entire string is then converted to lowercase.\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # _CAMEL_TO_UNDERSCORE_RE is defined in the file content as:\n    # _CAMEL_TO_UNDERSCORE_RE = re.compile(\n    #     '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n    # )\n    # This regex captures an uppercase letter that:\n    # 1. Is preceded by a lowercase letter or digit (e.g., 'fooBar' -> 'Bar')\n    # 2. Is not at the start of the string AND is followed by a lowercase letter\n    #    (e.g., 'HTTPRequest' -> 'Request')\n\n    # Replace the captured uppercase letter with an underscore followed by the\n    # lowercase version of that letter. The r'_\\1' refers to inserting an\n    # underscore and then the content of the first captured group (the matched\n    # uppercase letter).\n    underscored_text = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n\n    # Convert the entire resulting string to lowercase.\n    return underscored_text.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\n# noinspection PySameParameterValue\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # The _CAMEL_TO_UNDERSCORE_RE regex is defined globally in this file.\n    # It captures an uppercase letter that should be preceded by an underscore.\n    # Specifically, it matches:\n    # 1. An uppercase letter ([A-Z]) that is preceded by a lowercase letter\n    #    or a digit ((?<=[a-z0-9])). This handles transitions like 'fooBar' -> 'foo_Bar'.\n    # 2. Or, an uppercase letter ([A-Z]) that is not at the start of the string\n    #    ((?!^)) and is followed by a lowercase letter ((?=[a-z])). This handles\n    #    transitions for acronyms like 'HTTPResponse' -> 'HTTP_Response'.\n    #\n    # The '_\\1' replacement inserts an underscore before the matched uppercase letter.\n    s1 = _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text)\n    # Finally, convert the entire string to lowercase to ensure consistency\n    # (e.g., 'FooBar' becomes 'foo_bar', 'HTTPResponse' becomes 'http_response').\n    return s1.lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\n# The _CAMEL_TO_UNDERSCORE_RE regular expression is defined in the file content\n# outside of the function. It's designed to find the points where a camel-cased\n# string needs an underscore inserted.\n#\n# The regex consists of two alternative patterns:\n# 1. ((?<=[a-z0-9])[A-Z]): Matches an uppercase letter that is preceded by a\n#    lowercase letter or a digit. This handles transitions like 'fooBar' -> 'foo_Bar'.\n# 2. (?!^)[A-Z](?=[a-z]): Matches an uppercase letter that is not at the\n#    beginning of the string and is followed by a lowercase letter. This handles\n#    transitions within acronyms or from an acronym to a word, like 'HTTPRequest'\n#    where 'R' is followed by 'e', leading to 'HTTP_Request'.\n# The entire pattern is wrapped in a capturing group `(...)` so that `\\1` in\n# the replacement string refers to the matched uppercase character.\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # Use re.sub to replace the matched uppercase characters with an underscore\n    # followed by the character itself (which will then be lowercased).\n    # The r'_\\1' means an underscore followed by the content of the first\n    # capturing group (which is the matched uppercase letter).\n    # Finally, convert the entire resulting string to lowercase.\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\nimport re\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n    text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n    >>> from flutils.strutils import camel_to_underscore\n    >>> camel_to_underscore('FooBar')\n    'foo_bar'\n    \"\"\"\n    # _CAMEL_TO_UNDERSCORE_RE is defined in the file content:\n    # _CAMEL_TO_UNDERSCORE_RE = re.compile(\n    #     '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n    # )\n    # This regex matches an uppercase letter that:\n    # 1. Is preceded by a lowercase letter or a digit (e.g., 'fooBar' -> 'B').\n    # 2. Is not at the beginning of the string AND is followed by a lowercase\n    #    letter (e.g., 'FOOBar' -> 'B').\n    # The replacement adds an underscore before the matched uppercase letter.\n    # The entire string is then converted to lowercase.\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert camel_to_underscore('12FooBar1') == '12_foo_bar1'\ntest_0()\n\ndef test_1():\n    assert camel_to_underscore('Foo12Bar34') == 'foo12_bar34'\ntest_1()\n\ndef test_2():\n    assert camel_to_underscore('FooBar123FooBar') == 'foo_bar123_foo_bar'\ntest_2()\n\ndef test_3():\n    assert camel_to_underscore('Bar') == 'bar'\ntest_3()\n\ndef test_5():\n    assert camel_to_underscore('FooBARBaz23') == 'foo_bar_baz23'\ntest_5()\n\ndef test_6():\n    assert camel_to_underscore('FooBar234') == 'foo_bar234'\ntest_6()\n\ndef test_7():\n    assert camel_to_underscore('_fooBar1') == '_foo_bar1'\ntest_7()\n\ndef test_8():\n    assert camel_to_underscore('foobar') == 'foobar'\ntest_8()\n\ndef test_9():\n    assert camel_to_underscore('FooBar12') == 'foo_bar12'\ntest_9()\n\ndef test_10():\n    assert camel_to_underscore('foo2Bar') == 'foo2_bar'\ntest_10()\n\ndef test_12():\n    assert camel_to_underscore('BazFooBar1Qux') == 'baz_foo_bar1_qux'\ntest_12()\n\ndef test_13():\n    assert camel_to_underscore('12FooBarBaz12') == '12_foo_bar_baz12'\ntest_13()\n\ndef test_14():\n    assert camel_to_underscore('FooBar_12') == 'foo_bar_12'\ntest_14()\n\ndef test_15():\n    assert camel_to_underscore('FooBarFooBar') == 'foo_bar_foo_bar'\ntest_15()\n\ndef test_16():\n    assert camel_to_underscore('FooBarBazBang') == 'foo_bar_baz_bang'\ntest_16()\n\ndef test_17():\n    assert camel_to_underscore('fooBarBaz23') == 'foo_bar_baz23'\ntest_17()\n\ndef test_18():\n    assert camel_to_underscore('F12B') == 'f12_b'\ntest_18()\n\ndef test_19():\n    assert camel_to_underscore('fooBarBazBar100') == 'foo_bar_baz_bar100'\ntest_19()\n\ndef test_20():\n    assert camel_to_underscore('fooBar1_1_1') == 'foo_bar1_1_1'\ntest_20()\n\ndef test_21():\n    assert camel_to_underscore('foo__bar') == 'foo__bar'\ntest_21()\n\ndef test_22():\n    assert camel_to_underscore('Foo123Bar123') == 'foo123_bar123'\ntest_22()\n\ndef test_23():\n    assert camel_to_underscore('fooBar2Bar') == 'foo_bar2_bar'\ntest_23()\n\ndef test_24():\n    assert camel_to_underscore('Foo123BarBaz') == 'foo123_bar_baz'\ntest_24()\n\ndef test_25():\n    assert camel_to_underscore('FooBarBAZ234Baz') == 'foo_bar_baz234_baz'\ntest_25()\n\ndef test_26():\n    assert camel_to_underscore('fooBarBarBar') == 'foo_bar_bar_bar'\ntest_26()\n\ndef test_28():\n    assert camel_to_underscore('F1BarB2') == 'f1_bar_b2'\ntest_28()\n\ndef test_29():\n    assert camel_to_underscore('1FooBar1') == '1_foo_bar1'\ntest_29()\n\ndef test_30():\n    assert camel_to_underscore('Foo__bar') == 'foo__bar'\ntest_30()\n\ndef test_31():\n    assert camel_to_underscore('FoobarQix') == 'foobar_qix'\ntest_31()\n\ndef test_32():\n    assert camel_to_underscore('FooBar12_12') == 'foo_bar12_12'\ntest_32()\n\ndef test_33():\n    assert camel_to_underscore('fooBar_1_1') == 'foo_bar_1_1'\ntest_33()\n\ndef test_34():\n    assert camel_to_underscore('fooBARBaz') == 'foo_bar_baz'\ntest_34()\n\ndef test_35():\n    assert camel_to_underscore('fooBar_1') == 'foo_bar_1'\ntest_35()\n\ndef test_37():\n    assert camel_to_underscore('fooBarBar') == 'foo_bar_bar'\ntest_37()\n\ndef test_39():\n    assert camel_to_underscore('Foo2B2a2r') == 'foo2_b2a2r'\ntest_39()\n\ndef test_40():\n    assert camel_to_underscore('F1BarB2C') == 'f1_bar_b2_c'\ntest_40()\n\ndef test_41():\n    assert camel_to_underscore('FooBar10') == 'foo_bar10'\ntest_41()\n\ndef test_42():\n    assert camel_to_underscore('Foo_') == 'foo_'\ntest_42()\n\ndef test_44():\n    assert 'foo_bar' == camel_to_underscore('FooBar')\ntest_44()\n\ndef test_45():\n    assert camel_to_underscore('fooBar') == 'foo_bar'\ntest_45()\n\ndef test_46():\n    assert camel_to_underscore('iAmAnAwesomeCamel') == 'i_am_an_awesome_camel'\ntest_46()\n\ndef test_50():\n    assert camel_to_underscore('foo') == 'foo'\ntest_50()\n\ndef test_53():\n    assert camel_to_underscore('Foo12Bar12Baz12') == 'foo12_bar12_baz12'\ntest_53()\n\ndef test_54():\n    assert camel_to_underscore('FooBarAbc123') == 'foo_bar_abc123'\ntest_54()\n\ndef test_55():\n    assert camel_to_underscore('Foo1Bar2') == 'foo1_bar2'\ntest_55()\n\ndef test_56():\n    assert camel_to_underscore('FooBarBaz1') == 'foo_bar_baz1'\ntest_56()\n\ndef test_57():\n    assert camel_to_underscore('FooBarBaz23') == 'foo_bar_baz23'\ntest_57()\n\ndef test_58():\n    assert camel_to_underscore('foobarBaz') == 'foobar_baz'\ntest_58()\n\ndef test_59():\n    assert camel_to_underscore('fooBAR') == 'foo_bar'\ntest_59()\n\ndef test_60():\n    assert camel_to_underscore('foo2bar') == 'foo2bar'\ntest_60()\n\ndef test_61():\n    assert camel_to_underscore('fooBarBaz123Hello') == 'foo_bar_baz123_hello'\ntest_61()\n\ndef test_62():\n    assert camel_to_underscore('Foo123Bar4') == 'foo123_bar4'\ntest_62()\n\ndef test_63():\n    assert camel_to_underscore('FooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar'\ntest_63()\n\ndef test_64():\n    assert camel_to_underscore('Foo2Bar2Quux') == 'foo2_bar2_quux'\ntest_64()\n\ndef test_65():\n    assert camel_to_underscore('fooBarBazBar10') == 'foo_bar_baz_bar10'\ntest_65()\n\ndef test_66():\n    assert camel_to_underscore('FooB2B2ar') == 'foo_b2_b2ar'\ntest_66()\n\ndef test_67():\n    assert camel_to_underscore('BazFooBar1') == 'baz_foo_bar1'\ntest_67()\n\ndef test_69():\n    assert camel_to_underscore('Foo123Bar') == 'foo123_bar'\ntest_69()\n\ndef test_70():\n    assert camel_to_underscore('Foo0Bar') == 'foo0_bar'\ntest_70()\n\ndef test_71():\n    assert camel_to_underscore('FooBarBaz') == 'foo_bar_baz'\ntest_71()\n\ndef test_72():\n    assert camel_to_underscore('BazFooBarQux') == 'baz_foo_bar_qux'\ntest_72()\n\ndef test_73():\n    assert camel_to_underscore('FooBar2') == 'foo_bar2'\ntest_73()\n\ndef test_74():\n    assert camel_to_underscore('FooBar100') == 'foo_bar100'\ntest_74()\n\ndef test_75():\n    assert camel_to_underscore('FooBar__') == 'foo_bar__'\ntest_75()\n\ndef test_76():\n    assert camel_to_underscore('FooBarBazFooBar') == 'foo_bar_baz_foo_bar'\ntest_76()\n\ndef test_77():\n    assert camel_to_underscore('Foo2') == 'foo2'\ntest_77()\n\ndef test_78():\n    assert camel_to_underscore('FooBar1_') == 'foo_bar1_'\ntest_78()\n\ndef test_79():\n    assert camel_to_underscore('FooBar123Baz') == 'foo_bar123_baz'\ntest_79()\n\ndef test_80():\n    assert camel_to_underscore('fooBarBarBaz') == 'foo_bar_bar_baz'\ntest_80()\n\ndef test_81():\n    assert camel_to_underscore('fooBBarBaz') == 'foo_b_bar_baz'\ntest_81()\n\ndef test_82():\n    assert camel_to_underscore('FooBar1__') == 'foo_bar1__'\ntest_82()\n\ndef test_83():\n    assert camel_to_underscore('FooBar') != 'foo_bar1'\ntest_83()\n\ndef test_84():\n    assert camel_to_underscore('FooBar_') == 'foo_bar_'\ntest_84()\n\ndef test_85():\n    assert camel_to_underscore('FooBarBarBaz') == 'foo_bar_bar_baz'\ntest_85()\n\ndef test_86():\n    assert camel_to_underscore('FooBarBaz123') == 'foo_bar_baz123'\ntest_86()\n\ndef test_87():\n    assert camel_to_underscore('FooBar2Quux3') == 'foo_bar2_quux3'\ntest_87()\n\ndef test_88():\n    assert camel_to_underscore('foobar123') == 'foobar123'\ntest_88()\n\ndef test_89():\n    assert camel_to_underscore('fooBarBAZ') == 'foo_bar_baz'\ntest_89()\n\ndef test_90():\n    assert camel_to_underscore('FooBar23') == 'foo_bar23'\ntest_90()\n\ndef test_91():\n    assert camel_to_underscore('Foo2Bar') == 'foo2_bar'\ntest_91()\n\ndef test_93():\n    assert camel_to_underscore('Foo1Bar23') == 'foo1_bar23'\ntest_93()\n\ndef test_94():\n    assert camel_to_underscore('FooBAR') == 'foo_bar'\ntest_94()\n\ndef test_95():\n    assert camel_to_underscore('12FooBar12') == '12_foo_bar12'\ntest_95()\n\ndef test_96():\n    assert camel_to_underscore('fooBar__') == 'foo_bar__'\ntest_96()\n\ndef test_97():\n    assert camel_to_underscore('FooB2Bar') == 'foo_b2_bar'\ntest_97()\n\ndef test_98():\n    assert camel_to_underscore('FooBar24') == 'foo_bar24'\ntest_98()\n\ndef test_99():\n    assert camel_to_underscore('BazFooBar') == 'baz_foo_bar'\ntest_99()\n\ndef test_100():\n    assert camel_to_underscore('Foo1') == 'foo1'\ntest_100()\n\ndef test_101():\n    assert camel_to_underscore('F') == 'f'\ntest_101()\n\ndef test_103():\n    assert camel_to_underscore('Foo1Bar') == 'foo1_bar'\ntest_103()\n\ndef test_104():\n    assert camel_to_underscore('Foo123BarB4z') == 'foo123_bar_b4z'\ntest_104()\n\ndef test_105():\n    assert camel_to_underscore('FooBar1') == 'foo_bar1'\ntest_105()\n\ndef test_106():\n    assert camel_to_underscore('fooBarBazBar') == 'foo_bar_baz_bar'\ntest_106()\n\ndef test_107():\n    assert camel_to_underscore('oneTwoThree') == 'one_two_three'\ntest_107()\n\ndef test_108():\n    assert camel_to_underscore('foo_bar1') == 'foo_bar1'\ntest_108()\n\ndef test_109():\n    assert camel_to_underscore('Foo2Bar2') == 'foo2_bar2'\ntest_109()\n\ndef test_110():\n    assert camel_to_underscore('Foo1Bar12Baz') == 'foo1_bar12_baz'\ntest_110()\n\ndef test_111():\n    assert camel_to_underscore('FOO') == 'foo'\ntest_111()\n\ndef test_112():\n    assert camel_to_underscore('fooBar1__') == 'foo_bar1__'\ntest_112()\n\ndef test_113():\n    assert camel_to_underscore('FooB1arBaz') == 'foo_b1ar_baz'\ntest_113()\n\ndef test_114():\n    assert camel_to_underscore('12FooBar') == '12_foo_bar'\ntest_114()\n\ndef test_115():\n    assert camel_to_underscore('') == ''\ntest_115()\n\ndef test_116():\n    assert camel_to_underscore('fooBarBaz123HelloWorld') == 'foo_bar_baz123_hello_world'\ntest_116()\n\ndef test_117():\n    assert camel_to_underscore('1FooBar12') == '1_foo_bar12'\ntest_117()\n\ndef test_118():\n    assert camel_to_underscore('fooBarBaz') == 'foo_bar_baz'\ntest_118()\n\ndef test_119():\n    assert camel_to_underscore('FooBar123') == 'foo_bar123'\ntest_119()\n\ndef test_120():\n    assert camel_to_underscore('1FooBar') == '1_foo_bar'\ntest_120()\n\ndef test_121():\n    assert camel_to_underscore('FooBar0') == 'foo_bar0'\ntest_121()\n\ndef test_122():\n    assert camel_to_underscore('FooBar_12Baz') == 'foo_bar_12_baz'\ntest_122()\n\ndef test_123():\n    assert camel_to_underscore('0FooBar') == '0_foo_bar'\ntest_123()\n\ndef test_125():\n    assert camel_to_underscore('FooBar') == 'foo_bar'\ntest_125()\n\ndef test_126():\n    assert camel_to_underscore('F12') == 'f12'\ntest_126()\n\ndef test_127():\n    assert camel_to_underscore('fooBARBazBang') == 'foo_bar_baz_bang'\ntest_127()\n\ndef test_128():\n    assert camel_to_underscore('FooBarBar') == 'foo_bar_bar'\ntest_128()\n\ndef test_129():\n    assert 'foo' == camel_to_underscore('Foo')\ntest_129()\n\ndef test_131():\n    assert camel_to_underscore('FooBar234BAZ') == 'foo_bar234_baz'\ntest_131()\n\ndef test_133():\n    assert camel_to_underscore('fooBar1_1') == 'foo_bar1_1'\ntest_133()\n\ndef test_134():\n    assert camel_to_underscore('FooBar234Baz') == 'foo_bar234_baz'\ntest_134()\n\ndef test_136():\n    assert camel_to_underscore('FooBar1BazQux') == 'foo_bar1_baz_qux'\ntest_136()\n\ndef test_137():\n    assert camel_to_underscore('Foo') == 'foo'\ntest_137()\n\ndef test_138():\n    assert camel_to_underscore('Foo12Bar3') == 'foo12_bar3'\ntest_138()\n\ndef test_139():\n    assert camel_to_underscore('FooBARBaz') == 'foo_bar_baz'\ntest_139()\n\ndef test_140():\n    assert camel_to_underscore('FooBarBAZ234') == 'foo_bar_baz234'\ntest_140()\n\ndef test_141():\n    assert camel_to_underscore('F123Bar') == 'f123_bar'\ntest_141()\n\ndef test_142():\n    assert camel_to_underscore('FOOBar') == 'foo_bar'\ntest_142()\n\ndef test_144():\n    assert camel_to_underscore('FooBar12Baz') == 'foo_bar12_baz'\ntest_144()\n\ndef test_146():\n    assert camel_to_underscore('foo1Bar') == 'foo1_bar'\ntest_146()\n\ndef test_147():\n    assert camel_to_underscore('fooBar1_') == 'foo_bar1_'\ntest_147()\n\ndef test_148():\n    assert camel_to_underscore('fooBarBazBar1') == 'foo_bar_baz_bar1'\ntest_148()\n\ndef test_150():\n    assert camel_to_underscore('fooBBarB') == 'foo_b_bar_b'\ntest_150()\n\ndef test_151():\n    assert camel_to_underscore('Foo1BarBaz') == 'foo1_bar_baz'\ntest_151()\n\ndef test_152():\n    assert camel_to_underscore('foobar ') == 'foobar '\ntest_152()\n\ndef test_153():\n    assert camel_to_underscore('Foo2BBar2') == 'foo2_b_bar2'\ntest_153()\n\ndef test_154():\n    assert camel_to_underscore('foo_bar') == 'foo_bar'\ntest_154()\n\ndef test_155():\n    assert camel_to_underscore('Foo1Bar1') == 'foo1_bar1'\ntest_155()\n\ndef test_156():\n    assert camel_to_underscore('fooB') == 'foo_b'\ntest_156()\n\ndef test_157():\n    assert camel_to_underscore('F12BarBaz') == 'f12_bar_baz'\ntest_157()\n\ndef test_158():\n    assert camel_to_underscore('FooBar') != 'foo_bar1_'\ntest_158()\n\ndef test_159():\n    assert camel_to_underscore('FooBarBaz12') == 'foo_bar_baz12'\ntest_159()\n\ndef test_160():\n    assert camel_to_underscore('Foo12Bar') == 'foo12_bar'\ntest_160()\n\ndef test_163():\n    assert camel_to_underscore('FooBarFooBarFooBarFooBar') == 'foo_bar_foo_bar_foo_bar_foo_bar'\ntest_163()\n\ndef test_165():\n    assert camel_to_underscore('fooBBar') == 'foo_b_bar'\ntest_165()\n\ndef test_167():\n    assert camel_to_underscore('F123ooBarBaz') == 'f123oo_bar_baz'\ntest_167()\n\ndef test_168():\n    assert camel_to_underscore('MyCamel') == 'my_camel'\ntest_168()\n\ndef test_169():\n    assert camel_to_underscore('FoobarBaz') == 'foobar_baz'\ntest_169()\n\ndef test_171():\n    assert camel_to_underscore('FooBar2Quux') == 'foo_bar2_quux'\ntest_171()\n\ndef test_172():\n    assert camel_to_underscore('FooB123arBaz') == 'foo_b123ar_baz'\ntest_172()\n\ndef test_175():\n    assert camel_to_underscore('foo1Bar1') == 'foo1_bar1'\ntest_175()\n\ndef test_178():\n    assert camel_to_underscore('fooBarBazBang') == 'foo_bar_baz_bang'\ntest_178()\n\ndef test_179():\n    assert 'foo_bar_baz' == camel_to_underscore('FooBarBaz')\ntest_179()\n\ndef test_180():\n    assert camel_to_underscore('FooBar1Baz') == 'foo_bar1_baz'\ntest_180()\n\ndef test_181():\n    assert camel_to_underscore('abc') == 'abc'\ntest_181()\n\ndef test_182():\n    assert camel_to_underscore('fooBarB42az') == 'foo_bar_b42az'\ntest_182()\n\ndef test_183():\n    assert camel_to_underscore('FooBar') != 'foo_bar_'\ntest_183()\n\ndef test_184():\n    assert camel_to_underscore('FooBarBAZ') == 'foo_bar_baz'\ntest_184()\n\ndef test_185():\n    assert camel_to_underscore('fooBarBaz123') == 'foo_bar_baz123'\ntest_185()\n\ndef test_187():\n    assert camel_to_underscore('Foo2BBar') == 'foo2_b_bar'\ntest_187()\n\ndef test_188():\n    assert camel_to_underscore('fooBar1') == 'foo_bar1'\ntest_188()\n\ndef test_190():\n    assert camel_to_underscore('_fooBar') == '_foo_bar'\ntest_190()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar_Baz') == output\ntest_4()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo2B2ar') == output\ntest_11()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('  ') == output\ntest_27()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar__Baz') == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_') == output\ntest_38()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo123Bar') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo') == output\ntest_47()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_Baz') == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar123FooBar') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar1') == output\ntest_51()\n\ndef test_52():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_52\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar_Baz') == output\ntest_52()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('oneTwo_Three') == output\ntest_68()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_2Foo_Bar_') == output\ntest_92()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_') == output\ntest_102()\n\ndef test_124():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_124\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_124()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_130()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('2Foo_Bar') == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_135()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar_') == output\ntest_143()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar_') == output\ntest_145()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_149()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBAR123') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar2') == output\ntest_162()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('__Foo_Bar__') == output\ntest_164()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_2_Bar_') == output\ntest_166()\n\ndef test_170():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_170\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo_Bar') == output\ntest_170()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('foo_Bar') == output\ntest_173()\n\ndef test_174():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_174\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('Foo__Bar') == output\ntest_174()\n\ndef test_176():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_176\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore(' ') == output\ntest_176()\n\ndef test_177():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_177\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_Foo_Bar') == output\ntest_177()\n\ndef test_186():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_186\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('FooBar234_Baz') == output\ntest_186()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/camel_to_underscore/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert camel_to_underscore('_FooBar') == output\ntest_189()\n\n\n"]}
{"task_id": 135, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\n\n# Pre-compile the regular expression for efficiency.\n# This regex is designed to match three types of escaped Unicode literals:\n# 1. '\\\\x' followed by exactly two hexadecimal digits (e.g., '\\x31')\n# 2. '\\\\u' followed by exactly four hexadecimal digits (e.g., '\\u2605')\n# 3. '\\\\U' followed by exactly eight hexadecimal digits (e.g., '\\U0001f6d1')\n# Each pattern's hexadecimal digits are captured in a distinct group (1, 2, or 3).\n_UNICODE_ESCAPE_RE = re.compile(\n    r'\\\\x([0-9a-fA-F]{2})|'\n    r'\\\\u([0-9a-fA-F]{4})|'\n    r'\\\\U([0-9a-fA-F]{8})'\n)\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    def _replacer(match: re.Match) -> str:\n        \"\"\"\n        Replacement function for re.sub. It receives a match object and\n        determines which of the three capture groups (for \\x, \\u, or \\U)\n        contains the hexadecimal string. It then converts this hex string\n        to an integer and returns the corresponding Unicode character.\n        \"\"\"\n        hex_str = None\n        # Check which group captured the hexadecimal string based on\n        # which one is not None.\n        if match.group(1) is not None:  # Matched \\xXX\n            hex_str = match.group(1)\n        elif match.group(2) is not None:  # Matched \\uXXXX\n            hex_str = match.group(2)\n        elif match.group(3) is not None:  # Matched \\UXXXXXXXX\n            hex_str = match.group(3)\n        \n        # Convert the identified hexadecimal string to an integer\n        # and then to its corresponding Unicode character.\n        # This assumes valid Unicode code points will be passed.\n        if hex_str is not None:\n            return chr(int(hex_str, 16))\n        \n        # This fallback case should ideally not be reached if the regex\n        # correctly identifies and captures one of the hexadecimal sequences.\n        return match.group(0)\n\n    # Use re.sub to find all occurrences of the defined Unicode escape patterns\n    # and replace them with the actual characters using the _replacer function.\n    return _UNICODE_ESCAPE_RE.sub(_replacer, text)", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # The input 'text' is a string where characters like '\\', 'x', '3', '1'\n    # are literal characters forming escape sequences like '\\x31'.\n    # To interpret these as actual Python string literal escapes, we first\n    # encode the string to bytes using 'latin-1'. This encoding is chosen\n    # because it maps each Unicode character in the input string to a single\n    # byte without attempting to interpret any escape sequences, preserving\n    # the literal backslashes and hex characters.\n    # Then, we decode these bytes using the 'unicode_escape' codec. This\n    # codec specifically interprets Python's standard string literal escape\n    # sequences (like \\x, \\u, \\U) and converts them into their\n    # corresponding Unicode characters.\n    return text.encode('latin-1').decode('unicode_escape')", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Python's built-in 'unicode_escape' codec is designed to interpret\n    # backslash-escaped sequences like \\xNN, \\uNNNN, and \\UNNNNNNNN\n    # within a string and convert them into their corresponding Unicode characters.\n\n    # First, encode the input string 'text' to bytes using an encoding\n    # that preserves the literal backslashes and hexadecimal digits.\n    # 'latin1' (also known as 'iso-8859-1') is suitable because it maps\n    # the first 256 Unicode codepoints directly to byte values, meaning\n    # characters like 'x', 'u', 'U', digits, and backslashes will be\n    # encoded as their corresponding byte values.\n    encoded_text_bytes = text.encode('latin1')\n\n    # Then, decode these bytes using the 'unicode_escape' codec.\n    # This codec will interpret the sequences (e.g., b'\\\\x31') and\n    # convert them into the actual Unicode characters (e.g., '1').\n    decoded_text = encoded_text_bytes.decode('unicode_escape')\n\n    return decoded_text", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # The input 'text' is a string where backslashes are literal characters.\n    # For instance, if the original input in Python code was `r'\\x31'`, the\n    # string value would be exactly `'\\x31'` (a backslash followed by 'x', '3', '1').\n    # To interpret these sequences as actual Python Unicode escape sequences,\n    # we can use Python's built-in 'unicode_escape' codec.\n\n    # Step 1: Encode the input string into a byte string.\n    # We use 'latin-1' because it provides a direct mapping from each character's\n    # Unicode ordinal value (0-255) to its corresponding byte value.\n    # All characters typically found in these escape sequences (digits, hex letters,\n    # 'x', 'u', 'U', and the backslash itself) are within the ASCII range (0-127),\n    # which 'latin-1' handles without modification, making it suitable for this purpose.\n    encoded_bytes = text.encode('latin-1')\n\n    # Step 2: Decode the resulting byte string using the 'unicode_escape' codec.\n    # This codec is specifically designed to interpret byte sequences that\n    # represent Python string literal escapes (like `\\xXX`, `\\uXXXX`, `\\UXXXXXXXX`)\n    # and convert them into the actual Unicode characters.\n    decoded_text = encoded_bytes.decode('unicode_escape')\n\n    return decoded_text", "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # The input 'text' is a string where backslashes are already escaped\n    # (e.g., '\\\\x31' means the string contains a literal backslash,\n    # followed by 'x', '3', '1').\n    # The goal is to interpret these as actual Unicode escape sequences\n    # and convert them to their corresponding characters.\n\n    # Step 1: Encode the input string 'text' to bytes using 'raw_unicode_escape'.\n    # This codec is crucial because it converts the string's literal characters,\n    # including backslashes and escape sequence components (like 'x', 'u', 'U',\n    # and hex digits), into their byte representations.\n    # For example, the string '\\\\x31' becomes the bytes b'\\\\x31'.\n    # The string '\\\\u2605' becomes the bytes b'\\\\u2605'.\n    # This prepares the bytes object in the exact format expected by the\n    # 'unicode_escape' decoder in the next step.\n    encoded_bytes = text.encode('raw_unicode_escape')\n\n    # Step 2: Decode the resulting bytes using 'unicode_escape'.\n    # The 'unicode_escape' decoder is designed to interpret byte sequences\n    # that represent Unicode escapes (like b'\\\\x31', b'\\\\u2605', b'\\\\U0001f6d1')\n    # and convert them into the actual Unicode characters in a string.\n    # For example, b'\\\\x31' is decoded to the character '1'.\n    # b'\\\\u2605' is decoded to '★'.\n    # b'\\\\U0001f6d1' is decoded to '🛑'.\n    decoded_string = encoded_bytes.decode('unicode_escape')\n\n    return decoded_string"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\nimport re\n\n# Pre-compile the regular expression for efficiency.\n# This regex is designed to match three types of escaped Unicode literals:\n# 1. '\\\\x' followed by exactly two hexadecimal digits (e.g., '\\x31')\n# 2. '\\\\u' followed by exactly four hexadecimal digits (e.g., '\\u2605')\n# 3. '\\\\U' followed by exactly eight hexadecimal digits (e.g., '\\U0001f6d1')\n# Each pattern's hexadecimal digits are captured in a distinct group (1, 2, or 3).\n_UNICODE_ESCAPE_RE = re.compile(\n    r'\\\\x([0-9a-fA-F]{2})|'\n    r'\\\\u([0-9a-fA-F]{4})|'\n    r'\\\\U([0-9a-fA-F]{8})'\n)\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    def _replacer(match: re.Match) -> str:\n        \"\"\"\n        Replacement function for re.sub. It receives a match object and\n        determines which of the three capture groups (for \\x, \\u, or \\U)\n        contains the hexadecimal string. It then converts this hex string\n        to an integer and returns the corresponding Unicode character.\n        \"\"\"\n        hex_str = None\n        # Check which group captured the hexadecimal string based on\n        # which one is not None.\n        if match.group(1) is not None:  # Matched \\xXX\n            hex_str = match.group(1)\n        elif match.group(2) is not None:  # Matched \\uXXXX\n            hex_str = match.group(2)\n        elif match.group(3) is not None:  # Matched \\UXXXXXXXX\n            hex_str = match.group(3)\n        \n        # Convert the identified hexadecimal string to an integer\n        # and then to its corresponding Unicode character.\n        # This assumes valid Unicode code points will be passed.\n        if hex_str is not None:\n            return chr(int(hex_str, 16))\n        \n        # This fallback case should ideally not be reached if the regex\n        # correctly identifies and captures one of the hexadecimal sequences.\n        return match.group(0)\n\n    # Use re.sub to find all occurrences of the defined Unicode escape patterns\n    # and replace them with the actual characters using the _replacer function.\n    return _UNICODE_ESCAPE_RE.sub(_replacer, text)\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # The input 'text' is a string where characters like '\\', 'x', '3', '1'\n    # are literal characters forming escape sequences like '\\x31'.\n    # To interpret these as actual Python string literal escapes, we first\n    # encode the string to bytes using 'latin-1'. This encoding is chosen\n    # because it maps each Unicode character in the input string to a single\n    # byte without attempting to interpret any escape sequences, preserving\n    # the literal backslashes and hex characters.\n    # Then, we decode these bytes using the 'unicode_escape' codec. This\n    # codec specifically interprets Python's standard string literal escape\n    # sequences (like \\x, \\u, \\U) and converts them into their\n    # corresponding Unicode characters.\n    return text.encode('latin-1').decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # Python's built-in 'unicode_escape' codec is designed to interpret\n    # backslash-escaped sequences like \\xNN, \\uNNNN, and \\UNNNNNNNN\n    # within a string and convert them into their corresponding Unicode characters.\n\n    # First, encode the input string 'text' to bytes using an encoding\n    # that preserves the literal backslashes and hexadecimal digits.\n    # 'latin1' (also known as 'iso-8859-1') is suitable because it maps\n    # the first 256 Unicode codepoints directly to byte values, meaning\n    # characters like 'x', 'u', 'U', digits, and backslashes will be\n    # encoded as their corresponding byte values.\n    encoded_text_bytes = text.encode('latin1')\n\n    # Then, decode these bytes using the 'unicode_escape' codec.\n    # This codec will interpret the sequences (e.g., b'\\\\x31') and\n    # convert them into the actual Unicode characters (e.g., '1').\n    decoded_text = encoded_text_bytes.decode('unicode_escape')\n\n    return decoded_text\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # The input 'text' is a string where backslashes are literal characters.\n    # For instance, if the original input in Python code was `r'\\x31'`, the\n    # string value would be exactly `'\\x31'` (a backslash followed by 'x', '3', '1').\n    # To interpret these sequences as actual Python Unicode escape sequences,\n    # we can use Python's built-in 'unicode_escape' codec.\n\n    # Step 1: Encode the input string into a byte string.\n    # We use 'latin-1' because it provides a direct mapping from each character's\n    # Unicode ordinal value (0-255) to its corresponding byte value.\n    # All characters typically found in these escape sequences (digits, hex letters,\n    # 'x', 'u', 'U', and the backslash itself) are within the ASCII range (0-127),\n    # which 'latin-1' handles without modification, making it suitable for this purpose.\n    encoded_bytes = text.encode('latin-1')\n\n    # Step 2: Decode the resulting byte string using the 'unicode_escape' codec.\n    # This codec is specifically designed to interpret byte sequences that\n    # represent Python string literal escapes (like `\\xXX`, `\\uXXXX`, `\\UXXXXXXXX`)\n    # and convert them into the actual Unicode characters.\n    decoded_text = encoded_bytes.decode('unicode_escape')\n\n    return decoded_text\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped Unicode\n    hexadecimal.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped Unicode hexadecimal character converted\n    into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n    \\\\x31\n    \\\\u0031\n    \\\\U00000031\n\n    Examples:\n\n    Basic usage::\n\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped Unicode literal characters that need to be\n    converted to proper characters::\n\n    $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_unicode_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    >>> convert_escaped_unicode_literal(a)\n    '1.★ 🛑'\n\n    \"\"\"\n    # The input 'text' is a string where backslashes are already escaped\n    # (e.g., '\\\\x31' means the string contains a literal backslash,\n    # followed by 'x', '3', '1').\n    # The goal is to interpret these as actual Unicode escape sequences\n    # and convert them to their corresponding characters.\n\n    # Step 1: Encode the input string 'text' to bytes using 'raw_unicode_escape'.\n    # This codec is crucial because it converts the string's literal characters,\n    # including backslashes and escape sequence components (like 'x', 'u', 'U',\n    # and hex digits), into their byte representations.\n    # For example, the string '\\\\x31' becomes the bytes b'\\\\x31'.\n    # The string '\\\\u2605' becomes the bytes b'\\\\u2605'.\n    # This prepares the bytes object in the exact format expected by the\n    # 'unicode_escape' decoder in the next step.\n    encoded_bytes = text.encode('raw_unicode_escape')\n\n    # Step 2: Decode the resulting bytes using 'unicode_escape'.\n    # The 'unicode_escape' decoder is designed to interpret byte sequences\n    # that represent Unicode escapes (like b'\\\\x31', b'\\\\u2605', b'\\\\U0001f6d1')\n    # and convert them into the actual Unicode characters in a string.\n    # For example, b'\\\\x31' is decoded to the character '1'.\n    # b'\\\\u2605' is decoded to '★'.\n    # b'\\\\U0001f6d1' is decoded to '🛑'.\n    decoded_string = encoded_bytes.decode('unicode_escape')\n\n    return decoded_string\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_0():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038') == '12345678'\ntest_0()\n\ndef test_1():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_1()\n\ndef test_3():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20'))\ntest_3()\n\ndef test_4():\n    assert convert_escaped_unicode_literal('\\\\U00000031') == '1'\ntest_4()\n\ndef test_5():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == '1234567'\ntest_5()\n\ndef test_6():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_6()\n\ndef test_8():\n    assert convert_escaped_unicode_literal(\n                \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n            ) == \"1.★ 🛑\"\ntest_8()\n\ndef test_11():\n    assert convert_escaped_unicode_literal(u'\\\\u0031') == '1'\ntest_11()\n\ndef test_12():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036') == '123456'\ntest_12()\n\ndef test_13():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034') == '1234'\ntest_13()\n\ndef test_15():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1\\\\x20'))\ntest_15()\n\ndef test_16():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\U00000031'))\ntest_16()\n\ndef test_17():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == '1.★ 🛑'\ntest_17()\n\ndef test_18():\n    assert convert_escaped_unicode_literal(u'\\\\u2605') == '★'\ntest_18()\n\ndef test_22():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605'))\ntest_22()\n\ndef test_23():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\u0031\\\\u2605'))\ntest_23()\n\ndef test_24():\n    assert \"1.★ 🛑\" == convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\")\ntest_24()\n\ndef test_25():\n    assert 5.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_25()\n\ndef test_26():\n    assert '1' == convert_escaped_unicode_literal('\\\\U00000031')\ntest_26()\n\ndef test_27():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\x32'\n            )\n            ==\n            '1.★ 🛑2'\n    )\ntest_27()\n\ndef test_28():\n    assert convert_escaped_unicode_literal('\\\\x2e') == '.'\ntest_28()\n\ndef test_29():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e'))\ntest_29()\n\ndef test_30():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032') == '12'\ntest_30()\n\ndef test_31():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            )\n            ==\n            '1.★ 🛑'\n    )\ntest_31()\n\ndef test_32():\n    assert '1.' == convert_escaped_unicode_literal('\\\\x31\\\\x2e')\ntest_32()\n\ndef test_33():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20'\n            )\n            ==\n            '1.★ 🛑★ '\n    )\ntest_33()\n\ndef test_34():\n    assert convert_escaped_unicode_literal('\\\\x31') == '1'\ntest_34()\n\ndef test_36():\n    assert convert_escaped_unicode_literal(u'\\\\U0001f6d1') == '🛑'\ntest_36()\n\ndef test_37():\n    assert convert_escaped_unicode_literal('\\\\u2605') == '★'\ntest_37()\n\ndef test_38():\n    assert convert_escaped_unicode_literal('Hello World!') == 'Hello World!'\ntest_38()\n\ndef test_39():\n    assert '1' == convert_escaped_unicode_literal('\\\\u0031')\ntest_39()\n\ndef test_42():\n    assert convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_42()\n\ndef test_43():\n    assert 2 == len(convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1'))\ntest_43()\n\ndef test_44():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32'\n            )\n            ==\n            '1.★ 🛑★ 2'\n    )\ntest_44()\n\ndef test_45():\n    assert 3.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\x20\\\\U0001f6d1'))\ntest_45()\n\ndef test_46():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033') == '123'\ntest_46()\n\ndef test_47():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_47()\n\ndef test_48():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\u2605\\\\x20\\\\x20'))\ntest_48()\n\ndef test_49():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    ) == '1.★ 🛑'\ntest_49()\n\ndef test_50():\n    assert '1' == convert_escaped_unicode_literal('\\\\x31')\ntest_50()\n\ndef test_51():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\u0031'))\ntest_51()\n\ndef test_52():\n    assert 2.0 == len(convert_escaped_unicode_literal('\\\\u2605\\\\U0001f6d1'))\ntest_52()\n\ndef test_54():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal(\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )\ntest_54()\n\ndef test_55():\n    assert convert_escaped_unicode_literal(\"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\") == '1.★ 🛑'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_unicode_literal('\\\\u0031') == '1'\ntest_56()\n\ndef test_57():\n    assert '1.★ 🛑' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')\ntest_57()\n\ndef test_58():\n    assert convert_escaped_unicode_literal(\n            \"\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\"\n    ) == '1.★ 🛑'\ntest_58()\n\ndef test_61():\n    assert 1.0 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_61()\n\ndef test_64():\n    assert convert_escaped_unicode_literal('\\\\x20') == ' '\ntest_64()\n\ndef test_65():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035') == '12345'\ntest_65()\n\ndef test_66():\n    assert (\n            convert_escaped_unicode_literal(\n                '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1\\\\u2605\\\\x20\\\\x32\\\\x2e'\n            )\n            ==\n            '1.★ 🛑★ 2.'\n    )\ntest_66()\n\ndef test_67():\n    assert 4.0 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_67()\n\ndef test_68():\n    assert convert_escaped_unicode_literal(  r'\\x31\\x2e\\u2605\\x20\\U0001f6d1'  ) == '1.★ 🛑'\ntest_68()\n\ndef test_70():\n    assert convert_escaped_unicode_literal('\\\\U0001f6d1') == '🛑'\ntest_70()\n\ndef test_71():\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == '1.'\ntest_71()\n\ndef test_74():\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\u2605\\x20\\U0001f6d1') == r'1.★ 🛑'\ntest_74()\n\ndef test_75():\n    assert 1 == len(convert_escaped_unicode_literal('\\\\x31'))\ntest_75()\n\ndef test_76():\n    assert convert_escaped_unicode_literal('') == ''\ntest_76()\n\ndef test_77():\n    assert convert_escaped_unicode_literal(\n            '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n        ) == '1.★ 🛑'\ntest_77()\n\ndef test_78():\n    assert convert_escaped_unicode_literal('\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1') == '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\ntest_78()\n\ndef test_81():\n    assert convert_escaped_unicode_literal(u'\\\\u0031\\\\u2605') == '1★'\ntest_81()\n\ndef test_82():\n    assert '1.★ ' == convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20')\ntest_82()\n\ndef test_83():\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037\\\\u0038\\\\u0039') == '123456789'\ntest_83()\n\ndef test_84():\n    assert 4 == len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20'))\ntest_84()\n\ndef test_85():\n    assert convert_escaped_unicode_literal(u'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == '1.★ 🛑'\ntest_85()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1')) == output\ntest_2()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'''\n        \\x31\\x2e\\u2605\\x20\\U0001f6d1\n    ''') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\x31\\x2e\\\\u2605\\x20\\\\U0001f6d1') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\U00000031')) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31') == output\ntest_14()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[1]) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31')) == output\ntest_21()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal('\\\\U0001f6d1\\\\U0001f6d1')) == output\ntest_35()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031') == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\u0031')) == output\ntest_41()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031') == output\ntest_53()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\u0031\\\\u2605') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\u2605') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\U00000031\\\\U0001f6d1') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'Hello,\\ \\U0001f6d1') == output\ntest_63()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal('\\\\x31\\\\x2e') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(convert_escaped_unicode_literal(  # pylint: disable=W1401\n        '\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n    )) == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_unicode_literal(r'\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1') == output\ntest_73()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_unicode_literal/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert ord(convert_escaped_unicode_literal('\\\\x31\\\\x2e')[0]) == output\ntest_79()\n\n\n"]}
{"task_id": 136, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["import re\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a string that contains escaped backslashes,\n    # e.g., 'test\\\\xc2\\\\xa9'.\n    # The 'decode' function from flutils.codecs.raw_utf8_escape expects its\n    # 'data' argument to be bytes where the backslashes are also escaped,\n    # e.g., b'test\\\\xc2\\\\xa9'.\n    # Encoding the input string 'text' with 'latin1' correctly converts\n    # the string representation of these escaped backslashes into the\n    # required byte representation for the 'decode' function.\n    encoded_text_bytes = text.encode('latin1')\n\n    # Call the 'decode' function which handles the conversion from\n    # escaped UTF-8 hexadecimal bytes to the proper string.\n    # The 'decode' function returns a tuple: (decoded_string, bytes_consumed).\n    # We only need the decoded string part.\n    decoded_string, _ = decode(encoded_text_bytes)\n\n    return decoded_string", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is expected to be a string where backslashes\n    # in escape sequences (e.g., '\\\\xc2') are literal.\n    # For example, if the source code contains 'test\\\\\\\\xc2\\\\\\\\xa9',\n    # the 'text' variable will be the string 'test\\xc2\\xa9'.\n    #\n    # The 'decode' function from flutils.codecs.raw_utf8_escape expects\n    # its byte input to also contain these literal backslashes for its\n    # internal 'unicode_escape' step.\n    # Therefore, we encode the input string 'text' to bytes.\n    # A simple .encode() (which typically defaults to 'utf-8') is sufficient\n    # as the characters in the escaped sequences (e.g., '\\', 'x', 'c', '2')\n    # are all ASCII and will be represented as their literal byte values.\n    text_bytes = text.encode()\n\n    # Call the imported 'decode' function to perform the actual conversion.\n    # This function handles interpreting the escaped hexadecimal bytes\n    # and then decoding them as UTF-8. It also raises UnicodeDecodeError\n    # as required if the bytes are not proper UTF-8.\n    decoded_string, _ = decode(text_bytes, errors='strict')\n    return decoded_string", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a string containing literal backslashes for the\n    # escaped hexadecimal sequences, e.g., 'test\\\\\\\\xc2\\\\\\\\xa9'.\n    # The 'decode' context function expects its 'data' argument to be bytes\n    # where these literal backslashes are preserved, e.g., b'test\\\\\\\\xc2\\\\\\\\xa9'.\n    # Encoding the input string to UTF-8 achieves this.\n    text_bytes = text.encode('utf8')\n\n    # The 'decode' function from flutils.codecs.raw_utf8_escape performs\n    # the necessary steps:\n    # 1. Decodes the input bytes using 'unicode_escape' to convert sequences\n    #    like '\\\\xHH' into actual byte representations ('\\xHH').\n    # 2. Re-encodes these intermediate characters using 'latin1' to get\n    #    the raw UTF-8 byte sequence.\n    # 3. Finally, decodes the raw UTF-8 bytes into a string.\n    # It also handles UnicodeDecodeError as required.\n    # The 'decode' function returns a tuple (decoded_string, bytes_consumed).\n    # We only need the decoded string.\n    decoded_text, _ = decode(text_bytes)\n\n    return decoded_text", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a string which may contain literal escaped\n    # hexadecimal sequences, e.g., 'test\\\\\\\\xc2\\\\\\\\xa9'.\n    # To pass this to the 'decode' function from flutils.codecs.raw_utf8_escape,\n    # which expects a bytes-like object where these backslashes are literal\n    # (e.g., b'test\\\\\\\\xc2\\\\\\\\xa9'), we first encode the input string.\n    # Using 'utf-8' is suitable as all characters in typical escaped inputs\n    # (digits, letters, backslashes, 'x') are ASCII.\n    encoded_input_bytes = text.encode('utf-8')\n\n    # The 'decode' function handles the complex conversion logic:\n    # 1. It interprets '\\\\xHH' sequences within the bytes.\n    # 2. It converts these interpreted sequences into actual UTF-8 characters.\n    # The 'errors' parameter of 'decode' defaults to 'strict', ensuring that\n    # a UnicodeDecodeError is raised for invalid UTF-8 byte sequences,\n    # as specified in this function's docstring.\n    decoded_string, _ = decode(encoded_input_bytes)\n\n    return decoded_string", "from flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a Python string. As per the examples (e.g.,\n    # 'test\\\\\\\\xc2\\\\\\\\xa9'), the string contains literal backslashes\n    # representing the escaped hexadecimal bytes. When Python parses\n    # '\\\\\\\\' it creates a single literal backslash. So, 'test\\\\\\\\xc2\\\\\\\\xa9'\n    # becomes the Python string 'test\\xc2\\xa9'.\n    #\n    # The 'decode' function from 'flutils.codecs.raw_utf8_escape' expects\n    # its 'data' argument to be a bytes-like object where the byte sequences\n    # (e.g., \\xHH) are *escaped* with a backslash.\n    #\n    # Encoding the Python string 'test\\xc2\\xa9' to bytes (e.g., using 'utf-8')\n    # will result in b'test\\\\xc2\\\\xa9'. This byte string format (with\n    # explicit '\\\\x' sequences) is precisely what 'decode' expects for its\n    # internal 'unicode_escape' processing.\n    text_bytes_for_decoding = text.encode('utf-8')\n\n    # The 'decode' function from flutils.codecs.raw_utf8_escape performs\n    # the necessary steps:\n    # 1. Decodes the input bytes using 'unicode_escape' to convert \\\\xHH to \\xHH.\n    # 2. Encodes the resulting Latin-1 string to bytes.\n    # 3. Decodes these bytes using 'utf-8' to produce the final string.\n    # It also handles `UnicodeDecodeError` as specified in the docstring.\n    decoded_string, _ = decode(text_bytes_for_decoding, errors='strict')\n    return decoded_string"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nimport re\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a string that contains escaped backslashes,\n    # e.g., 'test\\\\xc2\\\\xa9'.\n    # The 'decode' function from flutils.codecs.raw_utf8_escape expects its\n    # 'data' argument to be bytes where the backslashes are also escaped,\n    # e.g., b'test\\\\xc2\\\\xa9'.\n    # Encoding the input string 'text' with 'latin1' correctly converts\n    # the string representation of these escaped backslashes into the\n    # required byte representation for the 'decode' function.\n    encoded_text_bytes = text.encode('latin1')\n\n    # Call the 'decode' function which handles the conversion from\n    # escaped UTF-8 hexadecimal bytes to the proper string.\n    # The 'decode' function returns a tuple: (decoded_string, bytes_consumed).\n    # We only need the decoded string part.\n    decoded_string, _ = decode(encoded_text_bytes)\n\n    return decoded_string\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is expected to be a string where backslashes\n    # in escape sequences (e.g., '\\\\xc2') are literal.\n    # For example, if the source code contains 'test\\\\\\\\xc2\\\\\\\\xa9',\n    # the 'text' variable will be the string 'test\\xc2\\xa9'.\n    #\n    # The 'decode' function from flutils.codecs.raw_utf8_escape expects\n    # its byte input to also contain these literal backslashes for its\n    # internal 'unicode_escape' step.\n    # Therefore, we encode the input string 'text' to bytes.\n    # A simple .encode() (which typically defaults to 'utf-8') is sufficient\n    # as the characters in the escaped sequences (e.g., '\\', 'x', 'c', '2')\n    # are all ASCII and will be represented as their literal byte values.\n    text_bytes = text.encode()\n\n    # Call the imported 'decode' function to perform the actual conversion.\n    # This function handles interpreting the escaped hexadecimal bytes\n    # and then decoding them as UTF-8. It also raises UnicodeDecodeError\n    # as required if the bytes are not proper UTF-8.\n    decoded_string, _ = decode(text_bytes, errors='strict')\n    return decoded_string\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a string containing literal backslashes for the\n    # escaped hexadecimal sequences, e.g., 'test\\\\\\\\xc2\\\\\\\\xa9'.\n    # The 'decode' context function expects its 'data' argument to be bytes\n    # where these literal backslashes are preserved, e.g., b'test\\\\\\\\xc2\\\\\\\\xa9'.\n    # Encoding the input string to UTF-8 achieves this.\n    text_bytes = text.encode('utf8')\n\n    # The 'decode' function from flutils.codecs.raw_utf8_escape performs\n    # the necessary steps:\n    # 1. Decodes the input bytes using 'unicode_escape' to convert sequences\n    #    like '\\\\xHH' into actual byte representations ('\\xHH').\n    # 2. Re-encodes these intermediate characters using 'latin1' to get\n    #    the raw UTF-8 byte sequence.\n    # 3. Finally, decodes the raw UTF-8 bytes into a string.\n    # It also handles UnicodeDecodeError as required.\n    # The 'decode' function returns a tuple (decoded_string, bytes_consumed).\n    # We only need the decoded string.\n    decoded_text, _ = decode(text_bytes)\n\n    return decoded_text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a string which may contain literal escaped\n    # hexadecimal sequences, e.g., 'test\\\\\\\\xc2\\\\\\\\xa9'.\n    # To pass this to the 'decode' function from flutils.codecs.raw_utf8_escape,\n    # which expects a bytes-like object where these backslashes are literal\n    # (e.g., b'test\\\\\\\\xc2\\\\\\\\xa9'), we first encode the input string.\n    # Using 'utf-8' is suitable as all characters in typical escaped inputs\n    # (digits, letters, backslashes, 'x') are ASCII.\n    encoded_input_bytes = text.encode('utf-8')\n\n    # The 'decode' function handles the complex conversion logic:\n    # 1. It interprets '\\\\xHH' sequences within the bytes.\n    # 2. It converts these interpreted sequences into actual UTF-8 characters.\n    # The 'errors' parameter of 'decode' defaults to 'strict', ensuring that\n    # a UnicodeDecodeError is raised for invalid UTF-8 byte sequences,\n    # as specified in this function's docstring.\n    decoded_string, _ = decode(encoded_input_bytes)\n\n    return decoded_string\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\nfrom flutils.codecs.raw_utf8_escape import decode\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_escaped_utf8_literal\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n    # The input 'text' is a Python string. As per the examples (e.g.,\n    # 'test\\\\\\\\xc2\\\\\\\\xa9'), the string contains literal backslashes\n    # representing the escaped hexadecimal bytes. When Python parses\n    # '\\\\\\\\' it creates a single literal backslash. So, 'test\\\\\\\\xc2\\\\\\\\xa9'\n    # becomes the Python string 'test\\xc2\\xa9'.\n    #\n    # The 'decode' function from 'flutils.codecs.raw_utf8_escape' expects\n    # its 'data' argument to be a bytes-like object where the byte sequences\n    # (e.g., \\xHH) are *escaped* with a backslash.\n    #\n    # Encoding the Python string 'test\\xc2\\xa9' to bytes (e.g., using 'utf-8')\n    # will result in b'test\\\\xc2\\\\xa9'. This byte string format (with\n    # explicit '\\\\x' sequences) is precisely what 'decode' expects for its\n    # internal 'unicode_escape' processing.\n    text_bytes_for_decoding = text.encode('utf-8')\n\n    # The 'decode' function from flutils.codecs.raw_utf8_escape performs\n    # the necessary steps:\n    # 1. Decodes the input bytes using 'unicode_escape' to convert \\\\xHH to \\xHH.\n    # 2. Encodes the resulting Latin-1 string to bytes.\n    # 3. Decodes these bytes using 'utf-8' to produce the final string.\n    # It also handles `UnicodeDecodeError` as specified in the docstring.\n    decoded_string, _ = decode(text_bytes_for_decoding, errors='strict')\n    return decoded_string\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out\n\n\nimport pickle\ndef test_1():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test☠'\ntest_1()\n\ndef test_2():\n    assert convert_escaped_utf8_literal('test\\\\xe2\\\\x82\\\\xac') == 'test€'\ntest_2()\n\ndef test_3():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b2') == 'ò'\ntest_3()\n\ndef test_4():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9\\\\xc2\\\\xa9') == 'test©©'\ntest_4()\n\ndef test_9():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\u00a9') == 'test©'\ntest_9()\n\ndef test_10():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00A9') == 'test©'\ntest_10()\n\ndef test_11():\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\"\n        ) == \"test\\t\\t\\t\"\ntest_11()\n\ndef test_14():\n    assert convert_escaped_utf8_literal('test\\\\u00C2\\\\u00a9') == 'test©'\ntest_14()\n\ndef test_16():\n    assert convert_escaped_utf8_literal(\n            \"test\"\n        ) == \"test\"\ntest_16()\n\ndef test_18():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testâ'\ntest_18()\n\ndef test_21():\n    assert convert_escaped_utf8_literal(\n            \"\"\n        ) == \"\"\ntest_21()\n\ndef test_22():\n    assert convert_escaped_utf8_literal('test\\\\xc3\\\\xa9') == 'testé'\ntest_22()\n\ndef test_24():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\u00c2\\u00a9'\ntest_24()\n\ndef test_28():\n    assert 'test©' == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_28()\n\ndef test_29():\n    assert convert_escaped_utf8_literal('test\\\\xf0\\\\x9f\\\\x98\\\\x80') == 'test😀'\ntest_29()\n\ndef test_31():\n    assert 'test©'.encode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test©').encode('raw_utf8_escape')\ntest_31()\n\ndef test_36():\n    assert b'test\\\\xc2\\\\xa9'.decode('raw_utf8_escape') \\\n            == convert_escaped_utf8_literal('test\\\\xc2\\\\xa9')\ntest_36()\n\ndef test_38():\n    assert convert_escaped_utf8_literal(r'\\u00c2\\u00a9') == '©'\ntest_38()\n\ndef test_39():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\\\xc2\\\\xa9'\ntest_39()\n\ndef test_41():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testxc2xa9'\ntest_41()\n\ndef test_42():\n    assert convert_escaped_utf8_literal('test\\\\u00c2\\\\xa9') == 'test©'\ntest_42()\n\ndef test_43():\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00b1') == 'ñ'\ntest_43()\n\ndef test_44():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xc2\\xa9'\ntest_44()\n\ndef test_47():\n    assert (\n        convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\n    )\ntest_47()\n\ndef test_49():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'test\\xC2\\xA9'\ntest_49()\n\ndef test_50():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9'\n    ) == 'test©'\ntest_50()\n\ndef test_51():\n    assert convert_escaped_utf8_literal(\n        'test\\\\xc2\\\\xa9') == 'test©'\ntest_51()\n\ndef test_55():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') == 'test©'\ntest_55()\n\ndef test_56():\n    assert convert_escaped_utf8_literal('test\\\\xc2\\\\xa9') != 'testÃ©'\ntest_56()\n\ndef test_57():\n    assert convert_escaped_utf8_literal('test\\\\x1b') == 'test\\x1b'\ntest_57()\n\ndef test_58():\n    assert convert_escaped_utf8_literal('test\\\\x0A') == 'test\\n'\ntest_58()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\t\\\\t\\\\t\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_8()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\c2\\\\a9') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_13()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b2') == output\ntest_17()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c2\\\\u00a9') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"test\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_25()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\ce') == output\ntest_27()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00b1') == output\ntest_32()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\\\u00c3\\\\u00a9') == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\"\n        ) == output\ntest_35()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal('test\\\\\\\\xc2\\\\\\\\xa9\\\\\\\\xc2\\\\\\\\xa9') == output\ntest_46()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(\n            \"\\\\\\\\xc2\\\\\\\\xa9\\\\t\\\\t\\\\t\"\n        ) == output\ntest_54()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/convert_escaped_utf8_literal/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert convert_escaped_utf8_literal(r'\\u00c3\\u00a9') == output\ntest_59()\n\n\n"]}
{"task_id": 137, "project": "test-apps/flutils", "module": "flutils.strutils", "predictions": ["def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscore and filter out any empty strings\n    words = [part for part in text.split('_') if part]\n\n    if not words:\n        return ''\n\n    camel_cased_parts = []\n\n    if lower_first:\n        # The first word remains as is (or ensures its first letter is lower,\n        # but typically it's already lower in underscore case)\n        camel_cased_parts.append(words[0])\n        # Subsequent words have their first letter capitalized\n        for word in words[1:]:\n            camel_cased_parts.append(word.capitalize())\n    else:\n        # All words have their first letter capitalized\n        for word in words:\n            camel_cased_parts.append(word.capitalize())\n\n    return ''.join(camel_cased_parts)", "import re\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    if not text:\n        return ''\n\n    # Split the text by underscore and filter out any empty strings that might\n    # result from consecutive underscores or leading/trailing underscores.\n    words = [word for word in text.split('_') if word]\n\n    if not words:\n        # If after splitting and filtering, there are no words (e.g., input was '___'),\n        # return an empty string.\n        return ''\n\n    camel_cased_parts = []\n\n    # Handle the first word based on the 'lower_first' flag.\n    # The first word is either lowercased (for true camelCase) or capitalized (for PascalCase).\n    first_word_processed = words[0].lower() if lower_first else words[0].capitalize()\n    camel_cased_parts.append(first_word_processed)\n\n    # For all subsequent words, capitalize their first letter.\n    for word in words[1:]:\n        camel_cased_parts.append(word.capitalize())\n\n    # Join all the processed parts to form the final camel-cased string.\n    return \"\".join(camel_cased_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    if not text:\n        return ''\n\n    # Split the text by underscores and filter out any empty strings\n    # that result from multiple underscores or leading/trailing underscores.\n    parts = [part for part in text.split('_') if part]\n\n    if not parts:\n        return ''  # Return empty string if input was only underscores or empty\n\n    camel_parts = []\n\n    # Process the first word\n    first_word = parts[0]\n    if lower_first:\n        camel_parts.append(first_word.lower())\n    else:\n        camel_parts.append(first_word.capitalize())\n\n    # Process the remaining words\n    for word in parts[1:]:\n        camel_parts.append(word.capitalize())\n\n    return ''.join(camel_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    if not text:\n        return ''\n\n    parts = text.split('_')\n    camel_parts = []\n    is_first_word_to_process = True\n\n    for part in parts:\n        if not part:  # Skip empty strings resulting from multiple underscores or leading/trailing underscores\n            continue\n\n        if is_first_word_to_process:\n            if lower_first:\n                camel_parts.append(part)\n            else:\n                camel_parts.append(part.capitalize())\n            is_first_word_to_process = False\n        else:\n            camel_parts.append(part.capitalize())\n\n    return \"\".join(camel_parts)", "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = text.split('_')\n    # Filter out empty strings that result from multiple consecutive underscores\n    # or leading/trailing underscores.\n    filtered_parts = [part for part in parts if part]\n\n    if not filtered_parts:\n        return ''\n\n    camel_parts = []\n    for i, part in enumerate(filtered_parts):\n        if i == 0:\n            if lower_first:\n                camel_parts.append(part.lower())\n            else:\n                camel_parts.append(part.capitalize())\n        else:\n            camel_parts.append(part.capitalize())\n\n    return \"\".join(camel_parts)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    # Split the text by underscore and filter out any empty strings\n    words = [part for part in text.split('_') if part]\n\n    if not words:\n        return ''\n\n    camel_cased_parts = []\n\n    if lower_first:\n        # The first word remains as is (or ensures its first letter is lower,\n        # but typically it's already lower in underscore case)\n        camel_cased_parts.append(words[0])\n        # Subsequent words have their first letter capitalized\n        for word in words[1:]:\n            camel_cased_parts.append(word.capitalize())\n    else:\n        # All words have their first letter capitalized\n        for word in words:\n            camel_cased_parts.append(word.capitalize())\n\n    return ''.join(camel_cased_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\nimport re\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    if not text:\n        return ''\n\n    # Split the text by underscore and filter out any empty strings that might\n    # result from consecutive underscores or leading/trailing underscores.\n    words = [word for word in text.split('_') if word]\n\n    if not words:\n        # If after splitting and filtering, there are no words (e.g., input was '___'),\n        # return an empty string.\n        return ''\n\n    camel_cased_parts = []\n\n    # Handle the first word based on the 'lower_first' flag.\n    # The first word is either lowercased (for true camelCase) or capitalized (for PascalCase).\n    first_word_processed = words[0].lower() if lower_first else words[0].capitalize()\n    camel_cased_parts.append(first_word_processed)\n\n    # For all subsequent words, capitalize their first letter.\n    for word in words[1:]:\n        camel_cased_parts.append(word.capitalize())\n\n    # Join all the processed parts to form the final camel-cased string.\n    return \"\".join(camel_cased_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    if not text:\n        return ''\n\n    # Split the text by underscores and filter out any empty strings\n    # that result from multiple underscores or leading/trailing underscores.\n    parts = [part for part in text.split('_') if part]\n\n    if not parts:\n        return ''  # Return empty string if input was only underscores or empty\n\n    camel_parts = []\n\n    # Process the first word\n    first_word = parts[0]\n    if lower_first:\n        camel_parts.append(first_word.lower())\n    else:\n        camel_parts.append(first_word.capitalize())\n\n    # Process the remaining words\n    for word in parts[1:]:\n        camel_parts.append(word.capitalize())\n\n    return ''.join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    if not text:\n        return ''\n\n    parts = text.split('_')\n    camel_parts = []\n    is_first_word_to_process = True\n\n    for part in parts:\n        if not part:  # Skip empty strings resulting from multiple underscores or leading/trailing underscores\n            continue\n\n        if is_first_word_to_process:\n            if lower_first:\n                camel_parts.append(part)\n            else:\n                camel_parts.append(part.capitalize())\n            is_first_word_to_process = False\n        else:\n            camel_parts.append(part.capitalize())\n\n    return \"\".join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport re\n\n__all__ = [\n    'as_escaped_unicode_literal',\n    'as_escaped_utf8_literal',\n    'camel_to_underscore',\n    'convert_escaped_unicode_literal',\n    'convert_escaped_utf8_literal',\n    'underscore_to_camel',\n]\n\n\ndef as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.★ 🛑'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out\n\n\ndef as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.★ 🛑'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out\n\n\n_CAMEL_TO_UNDERSCORE_RE = re.compile(\n    '((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))'\n)\n\n\ndef camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()\n\n\ndef convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.★ 🛑'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')\n\n\ndef convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test©'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text\n\n\ndef underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n    text (:obj:`str`): The camel-cased string to convert.\n    lower_first (:obj:`bool`, optional): Lowercase the first character.\n    Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n    >>> from flutils.strutils import underscore_to_camel\n    >>> underscore_to_camel('foo_bar')\n    'fooBar'\n    >>> underscore_to_camel('_one__two___',lower_first=False)\n    'OneTwo'\n    \"\"\"\n    parts = text.split('_')\n    # Filter out empty strings that result from multiple consecutive underscores\n    # or leading/trailing underscores.\n    filtered_parts = [part for part in parts if part]\n\n    if not filtered_parts:\n        return ''\n\n    camel_parts = []\n    for i, part in enumerate(filtered_parts):\n        if i == 0:\n            if lower_first:\n                camel_parts.append(part.lower())\n            else:\n                camel_parts.append(part.capitalize())\n        else:\n            camel_parts.append(part.capitalize())\n\n    return \"\".join(camel_parts)\n\n\nimport pickle\ndef test_0():\n    assert underscore_to_camel('_one__two___') == 'oneTwo'\ntest_0()\n\ndef test_1():\n    assert underscore_to_camel('foo_Bar_Baz') == 'fooBarBaz'\ntest_1()\n\ndef test_2():\n    assert underscore_to_camel('__Hello_World__',lower_first=False) == 'HelloWorld'\ntest_2()\n\ndef test_3():\n    assert underscore_to_camel('foo__bar__baz') == 'fooBarBaz'\ntest_3()\n\ndef test_4():\n    assert isinstance(underscore_to_camel('_one__two___', lower_first=False), str)\ntest_4()\n\ndef test_5():\n    assert underscore_to_camel('_hello_World_') == 'helloWorld'\ntest_5()\n\ndef test_6():\n    assert underscore_to_camel('_one__two___', lower_first=False) == 'OneTwo'\ntest_6()\n\ndef test_7():\n    assert \"fooBar\" == underscore_to_camel(\"foo_bar\")\ntest_7()\n\ndef test_8():\n    assert underscore_to_camel('hello_World') == 'helloWorld'\ntest_8()\n\ndef test_9():\n    assert underscore_to_camel('foo', lower_first=False) == 'Foo'\ntest_9()\n\ndef test_10():\n    assert underscore_to_camel('___') == ''\ntest_10()\n\ndef test_11():\n    assert underscore_to_camel('foo_bar_baz_') == 'fooBarBaz'\ntest_11()\n\ndef test_13():\n    assert underscore_to_camel('_Hello_World') == 'helloWorld'\ntest_13()\n\ndef test_16():\n    assert underscore_to_camel('_Hello_World__') == 'helloWorld'\ntest_16()\n\ndef test_17():\n    assert underscore_to_camel('__foo__') == 'foo'\ntest_17()\n\ndef test_19():\n    assert underscore_to_camel('__foo_bar__') == 'fooBar'\ntest_19()\n\ndef test_20():\n    assert underscore_to_camel('__foo') == 'foo'\ntest_20()\n\ndef test_23():\n    assert underscore_to_camel('__foo_bar__baz__') == 'fooBarBaz'\ntest_23()\n\ndef test_24():\n    assert underscore_to_camel('_Hello_World_') == 'helloWorld'\ntest_24()\n\ndef test_25():\n    assert underscore_to_camel('__Hello_World__') == 'helloWorld'\ntest_25()\n\ndef test_30():\n    assert underscore_to_camel('foo_bar__baz') == 'fooBarBaz'\ntest_30()\n\ndef test_31():\n    assert underscore_to_camel('_hello__world_') == 'helloWorld'\ntest_31()\n\ndef test_32():\n    assert \"OneTwo\" == underscore_to_camel(\"_one__two___\", lower_first=False)\ntest_32()\n\ndef test_33():\n    assert isinstance(underscore_to_camel('_one__two___'), str)\ntest_33()\n\ndef test_34():\n    assert underscore_to_camel('_bar', lower_first=False) == 'Bar'\ntest_34()\n\ndef test_36():\n    assert isinstance(underscore_to_camel('foo_bar'), str)\ntest_36()\n\ndef test_37():\n    assert 'fooBar' == underscore_to_camel('foo__Bar', lower_first=True)\ntest_37()\n\ndef test_40():\n    assert underscore_to_camel('one_two_three_four', lower_first=True) == 'oneTwoThreeFour'\ntest_40()\n\ndef test_41():\n    assert underscore_to_camel('_one__two___',lower_first=True) == 'oneTwo'\ntest_41()\n\ndef test_42():\n    assert underscore_to_camel('_baz_', lower_first=False) == 'Baz'\ntest_42()\n\ndef test_44():\n    assert underscore_to_camel('__foo_Bar__') == 'fooBar'\ntest_44()\n\ndef test_46():\n    assert underscore_to_camel('foo__') == 'foo'\ntest_46()\n\ndef test_48():\n    assert underscore_to_camel('foo') == 'foo'\ntest_48()\n\ndef test_49():\n    assert underscore_to_camel('HELLO_WORLD') == 'helloWorld'\ntest_49()\n\ndef test_51():\n    assert underscore_to_camel('hello') == 'hello'\ntest_51()\n\ndef test_52():\n    assert underscore_to_camel('hello_world') == 'helloWorld'\ntest_52()\n\ndef test_53():\n    assert underscore_to_camel('__foo_bar_baz__') == 'fooBarBaz'\ntest_53()\n\ndef test_54():\n    assert underscore_to_camel('Foo__bar__baz') == 'fooBarBaz'\ntest_54()\n\ndef test_55():\n    assert 'OneTwo' == underscore_to_camel('_one__two___',lower_first=False)\ntest_55()\n\ndef test_56():\n    assert underscore_to_camel('foo_bar') == 'fooBar'\ntest_56()\n\ndef test_57():\n    assert underscore_to_camel('_') == ''\ntest_57()\n\ndef test_59():\n    assert 'OneTwo' == underscore_to_camel('_one__two___', lower_first=False)\ntest_59()\n\ndef test_60():\n    assert underscore_to_camel('_hello_world_') == 'helloWorld'\ntest_60()\n\ndef test_62():\n    assert 'fooBar' == underscore_to_camel('foo_Bar', lower_first=True)\ntest_62()\n\ndef test_63():\n    assert underscore_to_camel('__foo_') == 'foo'\ntest_63()\n\ndef test_65():\n    assert underscore_to_camel('foo_Bar') == 'fooBar'\ntest_65()\n\ndef test_66():\n    assert 'fooBar' == underscore_to_camel('_foo__Bar', lower_first=True)\ntest_66()\n\ndef test_67():\n    assert underscore_to_camel('_foo_Bar_Baz_') == 'fooBarBaz'\ntest_67()\n\ndef test_68():\n    assert 'fooBar' == underscore_to_camel('foo_bar')\ntest_68()\n\ndef test_69():\n    assert underscore_to_camel('_foo') == 'foo'\ntest_69()\n\ndef test_71():\n    assert underscore_to_camel('foo___')\ntest_71()\n\ndef test_72():\n    assert underscore_to_camel('foo_bar_baz') == 'fooBarBaz'\ntest_72()\n\ndef test_74():\n    assert underscore_to_camel('') == ''\ntest_74()\n\ndef test_75():\n    assert underscore_to_camel('_one__two___',lower_first=False) == 'OneTwo'\ntest_75()\n\ndef test_78():\n    assert underscore_to_camel('One__two___',lower_first=False) == 'OneTwo'\ntest_78()\n\ndef test_79():\n    assert underscore_to_camel('foo__bar') == 'fooBar'\ntest_79()\n\ndef test_80():\n    assert underscore_to_camel('foo_') == 'foo'\ntest_80()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_BAR_baz') == output\ntest_12()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('one_two_three_four', lower_first=False) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar', lower_first=False) == output\ntest_15()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld_') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo__bAr__bAz__') == output\ntest_22()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('_one__two___', lower_first=False)) == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo_bar') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=True) == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo_bar_BAZ') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('foo__bar', lower_first=False) == output\ntest_35()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBarBaz') == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel(\"fooBar\") == output\ntest_39()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo__bar__baz_') == output\ntest_43()\n\ndef test_45():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_45\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__Foo__Bar__Baz__') == output\ntest_45()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('FooBar') == output\ntest_50()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_HelloWorld') == output\ntest_58()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBarBaz') == output\ntest_61()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('_foo_bar_baz_') == output\ntest_64()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('fooBar', lower_first=False) == output\ntest_70()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__foo__bar__baz__') == output\ntest_73()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert re.match(r'[a-z][a-zA-Z]*[A-Z][a-z]*[A-Z][a-zA-Z]*', underscore_to_camel('foo_bar')) == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+strutils/underscore_to_camel/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert underscore_to_camel('__fOo_Bar__') == output\ntest_77()\n\n\n"]}
{"task_id": 138, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["import functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n    \n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # Get the current user's information to find their primary group ID\n        # Leveraging the get_os_user context function.\n        current_user_info = get_os_user()\n        current_user_gid = current_user_info.pw_gid\n        try:\n            return grp.getgrgid(current_user_gid)\n        except KeyError:\n            # This case is highly unlikely if get_os_user succeeded,\n            # as a user should always have a valid primary group.\n            raise OSError(\n                'The current user\\'s primary group with gid: %r, does not '\n                'exist on this operating system.' % current_user_gid\n            )\n    elif isinstance(name, str):\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n    else:\n        # This case should ideally be caught by type hints, but included as a fallback\n        raise TypeError(\n            'The \"name\" argument must be a string, integer, or None.'\n        )", "import functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # Get the current user's primary group using get_os_user\n        current_user = get_os_user()\n        try:\n            return grp.getgrgid(current_user.pw_gid)\n        except KeyError:\n            # This case should ideally not happen if get_os_user succeeds\n            # and the system is consistent with its GIDs.\n            raise OSError(\n                'Could not find the primary group for the current user '\n                '(GID: %r).' % current_user.pw_gid\n            )\n    else: # name is a string\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )", "import grp\nimport getpass\nimport pwd\nfrom typing import Optional, Union\n\n# Assuming _STR_OR_INT_OR_NONE is defined in the file as:\n# _STR_OR_INT_OR_NONE = Union[str, int, None]\n\n# Assuming get_os_user is defined in the same module as:\n# def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n#     # ... (implementation provided in context) ...\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this '\n                'operating system.' % name\n            )\n    elif name is None:\n        # Get the current user's primary group GID using get_os_user\n        # This function is available in the context and handles current user\n        # lookup.\n        try:\n            user_info = get_os_user(None)\n            group_id = user_info.pw_gid\n            return grp.getgrgid(group_id)\n        except KeyError:\n            # This specific KeyError indicates the group ID obtained from\n            # the current user's info does not map to a group.\n            # This is highly unlikely in a functional OS but handled for robustness.\n            raise OSError(\n                'The current user\\'s primary group (gid: %r) does not '\n                'exist on this operating system.' % group_id\n            )\n        except OSError as e:\n            # If get_os_user itself failed to find the current user,\n            # propagate that OSError.\n            raise OSError(f\"Could not determine current user's group: {e}\") from e\n    else:  # name is a string\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )", "import getpass\nimport grp\nimport pwd\nfrom typing import (\n    Optional,\n    Union,\n)\n\n# _STR_OR_INT_OR_NONE and other types are defined in the file content\n# _STR_OR_INT_OR_NONE = Union[str, int, None]\n\n# Assuming get_os_user is available in the current scope as per context functions\n# It's explicitly defined as a context function, so it's treated as if it were\n# part of the same module or accessible.\ndef get_os_user(name: Union[str, int, None] = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # Get the current user's primary group GID\n        user_info = get_os_user()\n        try:\n            return grp.getgrgid(user_info.pw_gid)\n        except KeyError:\n            # This case should ideally not happen if get_os_user is successful\n            # and the system is consistent, but included for robustness.\n            raise OSError(\n                'Could not determine the primary group for the current user.'\n            )\n    elif isinstance(name, str):\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n    else:\n        # This case should not be reachable due to _STR_OR_INT_OR_NONE type hint\n        # but added for completeness.\n        raise TypeError(\n            f\"Invalid type for 'name'. Expected str, int, or None, got {type(name).__name__}.\"\n        )", "import functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        # If 'name' is an integer, it's treated as a GID.\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            # Raise OSError if the GID does not exist.\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # If 'name' is None, default to the current user's primary group.\n        # Use the get_os_user context function to get the current user's info.\n        try:\n            user_info = get_os_user()\n            gid = user_info.pw_gid\n            return grp.getgrgid(gid)\n        except KeyError:\n            # This case would occur if the GID obtained from the current user\n            # info does not exist in the system's group database.\n            raise OSError(\n                'Could not find group for current user (gid: %r).' % gid\n            )\n        except OSError as e:\n            # If get_os_user itself fails (e.g., current user not found),\n            # propagate that OSError.\n            raise e\n    else:  # name must be a string (group name)\n        # If 'name' is a string, it's treated as a group name.\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            # Raise OSError if the group name does not exist.\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n    \n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # Get the current user's information to find their primary group ID\n        # Leveraging the get_os_user context function.\n        current_user_info = get_os_user()\n        current_user_gid = current_user_info.pw_gid\n        try:\n            return grp.getgrgid(current_user_gid)\n        except KeyError:\n            # This case is highly unlikely if get_os_user succeeded,\n            # as a user should always have a valid primary group.\n            raise OSError(\n                'The current user\\'s primary group with gid: %r, does not '\n                'exist on this operating system.' % current_user_gid\n            )\n    elif isinstance(name, str):\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n    else:\n        # This case should ideally be caught by type hints, but included as a fallback\n        raise TypeError(\n            'The \"name\" argument must be a string, integer, or None.'\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # Get the current user's primary group using get_os_user\n        current_user = get_os_user()\n        try:\n            return grp.getgrgid(current_user.pw_gid)\n        except KeyError:\n            # This case should ideally not happen if get_os_user succeeds\n            # and the system is consistent with its GIDs.\n            raise OSError(\n                'Could not find the primary group for the current user '\n                '(GID: %r).' % current_user.pw_gid\n            )\n    else: # name is a string\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport grp\nimport getpass\nimport pwd\nfrom typing import Optional, Union\n\n# Assuming _STR_OR_INT_OR_NONE is defined in the file as:\n# _STR_OR_INT_OR_NONE = Union[str, int, None]\n\n# Assuming get_os_user is defined in the same module as:\n# def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n#     # ... (implementation provided in context) ...\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this '\n                'operating system.' % name\n            )\n    elif name is None:\n        # Get the current user's primary group GID using get_os_user\n        # This function is available in the context and handles current user\n        # lookup.\n        try:\n            user_info = get_os_user(None)\n            group_id = user_info.pw_gid\n            return grp.getgrgid(group_id)\n        except KeyError:\n            # This specific KeyError indicates the group ID obtained from\n            # the current user's info does not map to a group.\n            # This is highly unlikely in a functional OS but handled for robustness.\n            raise OSError(\n                'The current user\\'s primary group (gid: %r) does not '\n                'exist on this operating system.' % group_id\n            )\n        except OSError as e:\n            # If get_os_user itself failed to find the current user,\n            # propagate that OSError.\n            raise OSError(f\"Could not determine current user's group: {e}\") from e\n    else:  # name is a string\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport getpass\nimport grp\nimport pwd\nfrom typing import (\n    Optional,\n    Union,\n)\n\n# _STR_OR_INT_OR_NONE and other types are defined in the file content\n# _STR_OR_INT_OR_NONE = Union[str, int, None]\n\n# Assuming get_os_user is available in the current scope as per context functions\n# It's explicitly defined as a context function, so it's treated as if it were\n# part of the same module or accessible.\ndef get_os_user(name: Union[str, int, None] = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # Get the current user's primary group GID\n        user_info = get_os_user()\n        try:\n            return grp.getgrgid(user_info.pw_gid)\n        except KeyError:\n            # This case should ideally not happen if get_os_user is successful\n            # and the system is consistent, but included for robustness.\n            raise OSError(\n                'Could not determine the primary group for the current user.'\n            )\n    elif isinstance(name, str):\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n    else:\n        # This case should not be reachable due to _STR_OR_INT_OR_NONE type hint\n        # but added for completeness.\n        raise TypeError(\n            f\"Invalid type for 'name'. Expected str, int, or None, got {type(name).__name__}.\"\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n    if isinstance(name, int):\n        # If 'name' is an integer, it's treated as a GID.\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            # Raise OSError if the GID does not exist.\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    elif name is None:\n        # If 'name' is None, default to the current user's primary group.\n        # Use the get_os_user context function to get the current user's info.\n        try:\n            user_info = get_os_user()\n            gid = user_info.pw_gid\n            return grp.getgrgid(gid)\n        except KeyError:\n            # This case would occur if the GID obtained from the current user\n            # info does not exist in the system's group database.\n            raise OSError(\n                'Could not find group for current user (gid: %r).' % gid\n            )\n        except OSError as e:\n            # If get_os_user itself fails (e.g., current user not found),\n            # propagate that OSError.\n            raise e\n    else:  # name must be a string (group name)\n        # If 'name' is a string, it's treated as a group name.\n        try:\n            return grp.getgrnam(name)\n        except KeyError:\n            # Raise OSError if the group name does not exist.\n            raise OSError(\n                'The given name: %r, is not a valid \"group name\" '\n                'for this operating system.' % name\n            )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid == get_os_group().gr_gid\ntest_3()\n\ndef test_12():\n    assert get_os_user().pw_gid == get_os_group().gr_gid\ntest_12()\n\ndef test_13():\n    assert grp.getgrnam('root').gr_gid == get_os_group('root').gr_gid\ntest_13()\n\ndef test_18():\n    assert get_os_group(get_os_user().pw_name).gr_gid == get_os_user().pw_gid\ntest_18()\n\ndef test_20():\n    assert get_os_group(get_os_group()[0])[0] == get_os_group()[0]\ntest_20()\n\ndef test_21():\n    assert pwd.getpwuid(get_os_group().gr_gid) == get_os_user()\ntest_21()\n\ndef test_24():\n    assert 0 == get_os_group('root').gr_gid\ntest_24()\n\ndef test_29():\n    assert get_os_group() == grp.getgrgid(os.getgid())\ntest_29()\n\ndef test_32():\n    assert (get_os_user().pw_gid == get_os_group().gr_gid)\ntest_32()\n\ndef test_36():\n    assert get_os_group(get_os_user().pw_gid).gr_gid == get_os_user().pw_gid\ntest_36()\n\ndef test_37():\n    assert 0 == get_os_group().gr_gid\ntest_37()\n\ndef test_38():\n    assert 0 == get_os_group(get_os_user().pw_uid).gr_gid\ntest_38()\n\ndef test_40():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_gid  == get_os_group().gr_gid\ntest_40()\n\ndef test_41():\n    assert pwd.getpwnam(get_os_group().gr_name) == get_os_user()\ntest_41()\n\ndef test_42():\n    assert get_os_group() == grp.getgrgid(get_os_user().pw_gid)\ntest_42()\n\ndef test_43():\n    assert 0 == get_os_group(get_os_user().pw_name).gr_gid\ntest_43()\n\ndef test_44():\n    assert 'root' == get_os_group().gr_name\ntest_44()\n\ndef test_45():\n    assert get_os_user().pw_gid ==  get_os_group().gr_gid\ntest_45()\n\ndef test_48():\n    assert get_os_group()[0] == get_os_group()[0]\ntest_48()\n\ndef test_49():\n    assert 0 == grp.getgrgid(get_os_group().gr_gid)[2]\ntest_49()\n\ndef test_54():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem  == get_os_group().gr_mem\ntest_54()\n\ndef test_55():\n    assert 1 == grp.getgrnam(get_os_group(1).gr_name).gr_gid\ntest_55()\n\ndef test_56():\n    assert grp.getgrgid(get_os_group().gr_gid) == get_os_group()\ntest_56()\n\ndef test_59():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_name == get_os_group().gr_name\ntest_59()\n\ndef test_60():\n    assert grp.getgrnam(get_os_group().gr_name) == get_os_group()\ntest_60()\n\ndef test_67():\n    assert 0 == get_os_group(0).gr_gid\ntest_67()\n\ndef test_69():\n    assert grp.getgrgid(get_os_group().gr_gid).gr_mem == get_os_group().gr_mem\ntest_69()\n\ndef test_71():\n    assert grp.getgrgid(get_os_user().pw_gid) == get_os_group()\ntest_71()\n\ndef test_72():\n    assert grp.getgrnam(get_os_user().pw_name) == get_os_group()\ntest_72()\n\ndef test_73():\n    assert get_os_group(os.getgid()) == grp.getgrgid(os.getgid())\ntest_73()\n\ndef test_76():\n    assert 'root' == get_os_group(0).gr_name\ntest_76()\n\ndef test_79():\n    assert 'root' == get_os_group('root').gr_name\ntest_79()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('dialout').gr_mem) == output\ntest_0()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('root').gr_mem) == output\ntest_4()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_5()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('cdrom').gr_mem) == output\ntest_10()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_14()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group(1).gr_name) == output\ntest_15()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group().gr_mem) == output\ntest_22()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_28()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrnam(get_os_group().gr_name) == output\ntest_30()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_53()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('plugdev').gr_mem) == output\ntest_57()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group(None) == output\ntest_64()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_group() == output\ntest_68()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert grp.getgrgid(get_os_group().gr_gid) == output\ntest_75()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_group('adm').gr_mem) == output\ntest_78()\n\n\ndef test_extra_1():\n    try:\n        get_os_group('invalid_group_name')\n    except OSError as e:\n        assert str(e) == 'The given name: \\'invalid_group_name\\', is not a valid \"group name\" for this operating system.'\ntest_extra_1()\n\ndef test_extra_2():\n    try:\n        get_os_group(-1)\n    except OSError as e:\n        assert str(e) == 'The given gid: -1, is not a valid gid for this operating system.'\ntest_extra_2()\n\ndef test_extra_3():\n\twith open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_group/test_extra_3\", \"rb\") as f:\n\t\toutput = pickle.load(f)\n\t# Test default behavior\n\tassert isinstance(get_os_group(), grp.struct_group) == output\ntest_extra_3()"]}
{"task_id": 139, "project": "test-apps/flutils", "module": "flutils.pathutils", "predictions": ["import getpass\nimport pwd\nfrom typing import (\n    Optional,\n    Union,\n    cast,\n)\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n        name = cast(str, name)  # Cast for type checker as getpass.getuser() returns str\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )", "import getpass\nimport pwd\nfrom typing import (\n    Optional,\n)\n\n# _STR_OR_INT_OR_NONE and pwd are already imported in the file content.\n# No need to re-import them within the function.\n# The definition of _STR_OR_INT_OR_NONE is available from the file content.\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Get the current user's login name if no name is provided.\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    elif isinstance(name, str):\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"login name\" '\n                'for this operating system.' % name\n            )\n    # The type hints (_STR_OR_INT_OR_NONE) ensure that 'name' will always be\n    # str, int, or None. The 'None' case is handled first. Therefore, 'name'\n    # will always be either an int or a str at this point,\n    # so an 'else' branch for TypeError is not strictly necessary.", "import getpass\nimport pwd\nfrom typing import cast\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # If no name is provided, default to the current user's login name.\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            # If name is an integer, treat it as a UID.\n            return pwd.getpwuid(name)\n        except KeyError:\n            # Raise OSError if the UID does not exist.\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    # If not an integer, it must be a string (login name) based on the type hint.\n    try:\n        return pwd.getpwnam(cast(str, name))\n    except KeyError:\n        # Raise OSError if the login name does not exist.\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )", "import getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f'The given uid: {name!r}, is not a valid uid for this '\n                f'operating system.'\n            )\n    elif isinstance(name, str):\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name!r}, is not a valid \"login name\" '\n                f'for this operating system.'\n            )\n    else:\n        raise TypeError(\n            f'The argument \"name\" must be of type \"str\", \"int\", or \"None\", '\n            f'not {type(name)!r}.'\n        )", "import functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(group, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # If no name is provided, get the current user's login name.\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        # If an integer (UID) is provided, attempt to look up by UID.\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            # Raise an OSError if the UID does not exist.\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    # If it's not None and not an integer, it must be a string (login name).\n    try:\n        # Attempt to look up by login name.\n        return pwd.getpwnam(name)\n    except KeyError:\n        # Raise an OSError if the login name does not exist.\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import (\n    Optional,\n    Union,\n    cast,\n)\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n        name = cast(str, name)  # Cast for type checker as getpass.getuser() returns str\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import (\n    Optional,\n)\n\n# _STR_OR_INT_OR_NONE and pwd are already imported in the file content.\n# No need to re-import them within the function.\n# The definition of _STR_OR_INT_OR_NONE is available from the file content.\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # Get the current user's login name if no name is provided.\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    elif isinstance(name, str):\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                'The given name: %r, is not a valid \"login name\" '\n                'for this operating system.' % name\n            )\n    # The type hints (_STR_OR_INT_OR_NONE) ensure that 'name' will always be\n    # str, int, or None. The 'None' case is handled first. Therefore, 'name'\n    # will always be either an int or a str at this point,\n    # so an 'else' branch for TypeError is not strictly necessary.\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import cast\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # If no name is provided, default to the current user's login name.\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            # If name is an integer, treat it as a UID.\n            return pwd.getpwuid(name)\n        except KeyError:\n            # Raise OSError if the UID does not exist.\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    # If not an integer, it must be a string (login name) based on the type hint.\n    try:\n        return pwd.getpwnam(cast(str, name))\n    except KeyError:\n        # Raise OSError if the login name does not exist.\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport getpass\nimport pwd\nfrom typing import Union, Optional\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                f'The given uid: {name!r}, is not a valid uid for this '\n                f'operating system.'\n            )\n    elif isinstance(name, str):\n        try:\n            return pwd.getpwnam(name)\n        except KeyError:\n            raise OSError(\n                f'The given name: {name!r}, is not a valid \"login name\" '\n                f'for this operating system.'\n            )\n    else:\n        raise TypeError(\n            f'The argument \"name\" must be of type \"str\", \"int\", or \"None\", '\n            f'not {type(name)!r}.'\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\nimport functools\nimport getpass\nimport grp\nimport os\nimport pwd\nimport sys\nfrom collections import deque\nfrom os import PathLike\nfrom pathlib import (\n    Path,\n    PosixPath,\n    WindowsPath,\n)\nfrom typing import (\n    Deque,\n    Generator,\n    Optional,\n    Union,\n    cast,\n)\n\n\n__all__ = [\n    'chmod',\n    'chown',\n    'directory_present',\n    'exists_as',\n    'find_paths',\n    'get_os_group',\n    'get_os_user',\n    'normalize_path',\n    'path_absent',\n]\n\n\n_PATH = Union[\n    PathLike,\n    PosixPath,\n    WindowsPath,\n    bytes,\n    str,\n]\n\n_STR_OR_INT_OR_NONE = Union[\n    str,\n    int,\n    None\n]\n\n\ndef chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)\n\n\ndef chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(group, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)\n\n\ndef directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path\n\n\ndef exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''\n\n\ndef find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)\n\n\ndef get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )\n\n\ndef get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n    ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"login\n    name\" for this operating system.\n    OSError: If the given ``name`` is an ``uid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_passwd <pwd>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_user\n    >>> get_os_user('foo')\n    pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n    pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n    pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if name is None:\n        # If no name is provided, get the current user's login name.\n        name = getpass.getuser()\n\n    if isinstance(name, int):\n        # If an integer (UID) is provided, attempt to look up by UID.\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            # Raise an OSError if the UID does not exist.\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    # If it's not None and not an integer, it must be a string (login name).\n    try:\n        # Attempt to look up by login name.\n        return pwd.getpwnam(name)\n    except KeyError:\n        # Raise an OSError if the login name does not exist.\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )\n\n\n@functools.singledispatch\ndef normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user’s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)\n\n\n@normalize_path.register(bytes)\ndef _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)\n\n\n@normalize_path.register(Path)\ndef _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())\n\n\ndef path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)\n\n\nimport pickle\ndef test_3():\n    assert 3 == len(get_os_user(3).pw_name)\ntest_3()\n\ndef test_6():\n    assert get_os_user().pw_name == str(Path.home().owner())\ntest_6()\n\ndef test_8():\n    assert isinstance(\n        get_os_user('root'),\n        pwd.struct_passwd\n    )\ntest_8()\n\ndef test_9():\n    assert get_os_user('root') == pwd.getpwnam('root')\ntest_9()\n\ndef test_11():\n    assert get_os_user('bin') == pwd.getpwnam('bin')\ntest_11()\n\ndef test_13():\n    assert get_os_user(None).pw_name == getpass.getuser()\ntest_13()\n\ndef test_14():\n    assert get_os_user(None) == pwd.getpwuid(os.getuid())\ntest_14()\n\ndef test_17():\n    assert 0 == os.getuid() == get_os_user().pw_uid\ntest_17()\n\ndef test_21():\n    assert isinstance(get_os_user(os.getuid()), pwd.struct_passwd)\ntest_21()\n\ndef test_22():\n    assert get_os_group(None) == grp.getgrgid(get_os_user().pw_gid)\ntest_22()\n\ndef test_25():\n    assert isinstance(get_os_user(0), pwd.struct_passwd)\ntest_25()\n\ndef test_28():\n    assert 1 == get_os_user(1).pw_uid\ntest_28()\n\ndef test_29():\n    assert isinstance(get_os_user().pw_gid, int)\ntest_29()\n\ndef test_30():\n    assert get_os_user(get_os_user(0).pw_name) ==  get_os_user(0)\ntest_30()\n\ndef test_32():\n    assert os.path.exists(get_os_user().pw_shell)\ntest_32()\n\ndef test_36():\n    assert get_os_user(get_os_user(1).pw_uid)  ==  get_os_user(1)\ntest_36()\n\ndef test_39():\n    assert isinstance(get_os_user(None), pwd.struct_passwd)\ntest_39()\n\ndef test_40():\n    assert get_os_group().gr_name ==  get_os_user().pw_name\ntest_40()\n\ndef test_45():\n    assert 'root' == get_os_user(0).pw_name\ntest_45()\n\ndef test_47():\n    assert get_os_user().pw_name == getpass.getuser()\ntest_47()\n\ndef test_48():\n    assert isinstance(get_os_user().pw_shell, str)\ntest_48()\n\ndef test_49():\n    assert get_os_user('daemon') == pwd.getpwnam('daemon')\ntest_49()\n\ndef test_50():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_uid).pw_name\ntest_50()\n\ndef test_52():\n    assert get_os_user().pw_name ==  getpass.getuser()\ntest_52()\n\ndef test_53():\n    assert get_os_user(get_os_user(0).pw_uid)  ==  get_os_user(0)\ntest_53()\n\ndef test_54():\n    assert isinstance(get_os_user().pw_dir, str)\ntest_54()\n\ndef test_56():\n    assert get_os_user() == get_os_user(None)\ntest_56()\n\ndef test_57():\n    assert isinstance(get_os_user().pw_uid, int)\ntest_57()\n\ndef test_59():\n    assert get_os_user().pw_uid == os.getuid()\ntest_59()\n\ndef test_61():\n    assert get_os_user(getpass.getuser()) == pwd.getpwuid(os.getuid())\ntest_61()\n\ndef test_65():\n    assert str(get_os_user()[0]) == str(getpass.getuser())\ntest_65()\n\ndef test_72():\n    assert get_os_user() == get_os_user(getpass.getuser())\ntest_72()\n\ndef test_73():\n    assert isinstance(get_os_user('root'), pwd.struct_passwd)\ntest_73()\n\ndef test_77():\n    assert get_os_user('nobody') == pwd.getpwnam('nobody')\ntest_77()\n\ndef test_78():\n    assert 'root' == get_os_user('root').pw_name\ntest_78()\n\ndef test_81():\n    assert os.path.exists(get_os_user().pw_dir)\ntest_81()\n\ndef test_82():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name).pw_name\ntest_82()\n\ndef test_83():\n    assert get_os_user(get_os_user(1).pw_name) ==  get_os_user(1)\ntest_83()\n\ndef test_84():\n    assert get_os_user().pw_name == get_os_user(get_os_user().pw_name.lower()).pw_name\ntest_84()\n\ndef test_86():\n    assert isinstance(get_os_user(), pwd.struct_passwd)\ntest_86()\n\ndef test_87():\n    assert get_os_user() == get_os_user(None) == get_os_user(getpass.getuser())\ntest_87()\n\ndef test_89():\n    assert get_os_user(None) == get_os_user(getpass.getuser())\ntest_89()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_gecos.split(',')) == output\ntest_10()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user()) == output\ntest_12()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_name) == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_16()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user('root') == output\ntest_20()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(os.getuid())) == output\ntest_23()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(1)) == output\ntest_24()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(None)) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user() == output\ntest_34()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid + 1)) == output\ntest_37()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root').pw_gecos.split(',')) == output\ntest_44()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_uid)) == output\ntest_51()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_passwd) == output\ntest_55()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert get_os_user().pw_name.upper() == output\ntest_64()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name.lower())) == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(get_os_user().pw_name)) == output\ntest_68()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user().pw_name) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user(0)) == output\ntest_71()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+pathutils/get_os_user/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(get_os_user('root')) == output\ntest_75()\n\n\ndef test_extra_4():\n    try:\n        get_os_user('fakeuser')\n    except OSError as e:\n        assert str(e) == \"The given name: 'fakeuser', is not a valid \\\"login name\\\" for this operating system.\"\ntest_extra_4()\n\ndef test_extra_5():\n    try:\n        get_os_user(999999)\n    except OSError as e:\n        assert str(e) == \"The given uid: 999999, is not a valid uid for this operating system.\"\ntest_extra_5()"]}
{"task_id": 140, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\n# Imports from context functions, specifically for the `encode` function\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.codecs import register_codecs\n\n# Register the custom codecs. This is typically done once at module load\n# or during a codec registration process. Placing it here ensures it's\n# executed before `encode` is called, as `convert_escaped_utf8_literal`\n# relies on the 'raw_utf8_escape' codec being registered.\nregister_codecs()\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Ensure the input text is a standard string for processing functions\n    # that specifically expect 'str' (e.g., convert_escaped_utf8_literal).\n    # UserString objects are implicitly convertible.\n    input_str = str(text)\n    # Ensure the errors argument is a string for the final encode call.\n    errors_str = str(errors)\n\n    # Step 1: Normalize the input string.\n    # This step is crucial for handling the \"may contain escaped utf8 hexadecimal\"\n    # part of the docstring. It converts any literal '\\xNN' sequences (e.g., '\\\\xc2\\\\xa9')\n    # within the input string into their corresponding Unicode characters (e.g., '©').\n    # This process implicitly validates these escaped sequences: if they do not form\n    # valid UTF-8 bytes (e.g., '\\\\xff'), `convert_escaped_utf8_literal` will raise\n    # a `UnicodeDecodeError`.\n    try:\n        normalized_text = convert_escaped_utf8_literal(input_str)\n    except UnicodeDecodeError as exc:\n        # As per the docstring, if invalid UTF-8 bytes are found within escaped\n        # hexadecimal sequences in the input, a `UnicodeEncodeError` must be raised.\n        # This specific error condition implies a 'strict' validation for the\n        # input's format, irrespective of the general 'errors' parameter for\n        # the overall encoding process. Thus, we re-raise for this scenario.\n        raise UnicodeEncodeError(\n            'raw_utf8_escape_codec',  # Conventional name for the codec.\n            input_str,                # The original object being processed.\n            exc.start,                # Start index of the problematic part.\n            exc.end,                  # End index of the problematic part.\n            f\"invalid utf8 bytes found in escaped hexadecimal sequence: {exc.reason}\"\n        ) from exc\n\n    # Step 2: Convert the normalized string into its escaped UTF-8 hexadecimal\n    # representation. The `_each_utf8_hex` generator (defined earlier in this file)\n    # is ideal for this. It yields individual printable ASCII characters as they are,\n    # and converts non-ASCII or non-printable ASCII characters into their UTF-8\n    # byte equivalents, formatted as '\\\\xNN' strings.\n    parts = []\n    for part in _each_utf8_hex(normalized_text):\n        parts.append(part)\n\n    # Join the generated string parts into a single string.\n    # The resulting string should exclusively contain ASCII characters\n    # (printable ASCII, and the literal characters '\\' and 'x' followed by hex digits).\n    output_str = \"\".join(parts)\n\n    # Step 3: Encode the resulting ASCII string to bytes.\n    # The 'ascii' encoding is appropriate and safe here, as `_each_utf8_hex`\n    # is designed to produce an output string composed solely of ASCII characters.\n    # The `errors_str` parameter is passed to this final encoding step, though for\n    # `_each_utf8_hex`'s output, it typically won't trigger errors unless the output\n    # contained unexpected non-ASCII characters.\n    encoded_bytes = output_str.encode('ascii', errors=errors_str)\n\n    # The number of characters consumed is the length of the original input string,\n    # as the entire string is processed for encoding.\n    chars_consumed = len(text)\n\n    return encoded_bytes, chars_consumed", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n# Context function imports:\n# From Context Function 1:\nfrom flutils.strutils import convert_escaped_utf8_literal\n# From Context Function 4:\nfrom flutils.strutils import as_escaped_utf8_literal\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    if not isinstance(text, (str, UserString)):\n        raise TypeError('\\'text\\' must be a str or UserString.')\n    if not isinstance(errors, (str, UserString)):\n        raise TypeError('\\'errors\\' must be a str or UserString.')\n\n    # Step 1: Normalize the input string by converting any literal escaped\n    # UTF-8 hexadecimal sequences (e.g., \\\\xc2\\\\xa9) into their\n    # corresponding Unicode characters.\n    # The convert_escaped_utf8_literal function internally uses a 'raw_utf8_escape'\n    # codec, which implicitly handles errors in a 'strict' manner.\n    # If invalid UTF-8 byte sequences are found within the escaped hex,\n    # it will raise a UnicodeDecodeError.\n    try:\n        normalized_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # As per the docstring, if the input text contains escaped utf8 hexadecimal\n        # that references invalid utf8 bytes, a UnicodeEncodeError should be raised.\n        # We catch the UnicodeDecodeError and re-raise it as UnicodeEncodeError.\n        raise UnicodeEncodeError(\n            e.encoding,\n            e.object,\n            e.start,\n            e.end,\n            \"Invalid escaped UTF-8 hexadecimal sequence found in the input string.\"\n        ) from e\n\n    # Step 2: Convert the normalized string into its escaped UTF-8 hexadecimal\n    # string representation. This produces a string composed solely of\n    # ASCII characters (e.g., '\\', 'x', '0'-'9', 'a'-'f').\n    escaped_str_representation = as_escaped_utf8_literal(normalized_text)\n\n    # Step 3: Encode this ASCII-only string representation into bytes.\n    # The 'errors' parameter from the function signature is applied here.\n    # Since 'escaped_str_representation' is expected to be pure ASCII,\n    # this 'errors' handling will typically only be relevant if 'errors'\n    # is not 'strict' and an unexpected non-ASCII character were somehow\n    # present (which should not occur with as_escaped_utf8_literal's output).\n    output_bytes = escaped_str_representation.encode('ascii', errors=str(errors))\n\n    # The number of characters consumed is the length of the original input string.\n    consumed_chars = len(text)\n\n    return output_bytes, consumed_chars", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n# _Str is already defined in File Content\n_Str = Union[str, UserString]\n\n# Context function imports\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.strutils import as_escaped_utf8_literal\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Ensure text is a standard str for compatibility with context functions\n    if isinstance(text, UserString):\n        text_str = str(text)\n    else:\n        text_str = text\n\n    # Ensure errors is a standard str\n    if isinstance(errors, UserString):\n        errors_str = str(errors)\n    else:\n        errors_str = errors\n\n    # Step 1: Normalize the input string.\n    # The `text` input might contain literal escaped UTF-8 hexadecimal sequences\n    # (e.g., \"\\\\xc2\\\\xa9\"). `convert_escaped_utf8_literal` interprets these\n    # sequences and converts them into their actual Unicode characters (e.g., \"©\").\n    # This ensures we work with the semantic content of the string.\n    #\n    # This function operates strictly regarding invalid UTF-8 sequences. If an\n    # escaped sequence refers to invalid UTF-8 bytes, it will raise a\n    # UnicodeDecodeError. As per the query function's docstring, if `errors`\n    # is 'strict', this specific error should be re-raised as a UnicodeEncodeError.\n    try:\n        normalized_text = convert_escaped_utf8_literal(text_str)\n    except UnicodeDecodeError as e:\n        if errors_str == 'strict':\n            # Re-raise as UnicodeEncodeError as specified in the docstring.\n            # The 'raw_utf8_escape' is the name of the codec involved in the decoding.\n            raise UnicodeEncodeError(\n                'raw_utf8_escape',\n                text_str,\n                e.start,\n                e.end,\n                f\"Invalid UTF-8 escaped hexadecimal sequence in input: {e}\"\n            ) from e\n        else:\n            # If `errors_str` is not 'strict' (e.g., 'ignore', 'replace'),\n            # the `convert_escaped_utf8_literal` function does not support\n            # those error modes for its internal decoding. Therefore, the\n            # original UnicodeDecodeError will propagate. This is a limitation\n            # imposed by the behavior of the provided context function.\n            raise # Re-raise the original UnicodeDecodeError\n\n    # Step 2: Convert the normalized string into its escaped UTF-8 hexadecimal\n    # string representation. This means every character in `normalized_text`\n    # will be converted into its '\\xNN' UTF-8 byte sequence string form.\n    # For example, 'A' becomes '\\\\x41', '©' becomes '\\\\xc2\\\\xa9'.\n    escaped_hex_string = as_escaped_utf8_literal(normalized_text)\n\n    # Step 3: Convert the resulting `escaped_hex_string` to bytes.\n    # Since `escaped_hex_string` only contains printable ASCII characters\n    # (letters, digits, '\\', 'x'), it can be safely encoded using 'latin-1'\n    # (which maps ASCII characters directly to their byte values).\n    # This step should not raise a UnicodeEncodeError as the string is ASCII-safe.\n    result_bytes = escaped_hex_string.encode('latin-1')\n\n    # Step 4: Determine the number of characters consumed from the original input.\n    # This is simply the length of the original input string.\n    consumed_characters = len(text_str)\n\n    return result_bytes, consumed_characters", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n# Context function imports\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.strutils import as_escaped_utf8_literal\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Validate the 'errors' parameter. As per the docstring and context,\n    # only 'strict' mode is explicitly supported for error handling that\n    # results in UnicodeEncodeError. Other modes would require custom codec\n    # implementations not detailed in the provided context.\n    if errors != 'strict':\n        raise ValueError(\n            f\"Unknown error handling mode: '{errors}'. Only 'strict' is supported.\"\n        )\n\n    # Step 1: Convert any existing escaped UTF-8 hexadecimal sequences\n    # (e.g., '\\\\xc2\\\\xa9') in the input `text` to their corresponding\n    # Unicode characters (e.g., '©').\n    # This addresses the \"may contain escaped utf8 hexadecimal\" part of the query.\n    try:\n        # Cast `text` to `str` to ensure compatibility with `convert_escaped_utf8_literal`\n        # which expects a `str` argument, though `UserString` often behaves like `str`.\n        intermediate_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # The docstring for the `encode` function specifies raising `UnicodeEncodeError`\n        # for invalid UTF-8 bytes within escaped hexadecimal sequences.\n        # We catch the `UnicodeDecodeError` thrown by `convert_escaped_utf8_literal`\n        # and re-raise it as `UnicodeEncodeError` to match the specified behavior.\n        raise UnicodeEncodeError(\n            e.encoding,  # The encoding that failed ('raw_utf8_escape' in this case)\n            e.object,    # The bytes object being decoded\n            e.start,     # The index into the object where the error occurred\n            e.end,       # The index after the problematic sequence\n            e.reason     # The reason for the error\n        ) from e\n\n    # Step 2: Convert the now normalized `intermediate_text` into a string\n    # where all characters (including ASCII characters) are represented as\n    # '\\xNN' hexadecimal escapes.\n    # For example:\n    # - 'hello' becomes '\\\\x68\\\\x65\\\\x6c\\\\x6c\\\\x6f'\n    # - '©' becomes '\\\\xc2\\\\xa9'\n    # - 'hello©' becomes '\\\\x68\\\\x65\\\\x6c\\\\x6c\\\\x6f\\\\xc2\\\\xa9'\n    final_escaped_str = as_escaped_utf8_literal(intermediate_text)\n\n    # Step 3: Convert this `final_escaped_str` (which is a string of\n    # '\\xNN' sequences) into a `bytes` object.\n    # This results in a byte string that literally contains the '\\xNN'\n    # sequences. For example, the string '\\\\x68' becomes the bytes b'\\\\x68'\n    # (where each character `\\` `x` `6` `8` is represented by its UTF-8 byte).\n    output_bytes = final_escaped_str.encode('utf-8')\n\n    # The number of characters consumed is simply the length of the original input text.\n    characters_consumed = len(text)\n\n    return output_bytes, characters_consumed", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n# Necessary imports from context functions\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.strutils import as_escaped_utf8_literal\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    if not isinstance(text, (str, UserString)):\n        raise TypeError('Expected text to be str or UserString')\n    if not isinstance(errors, (str, UserString)):\n        raise TypeError('Expected errors to be str or UserString')\n\n    # Convert UserString inputs to plain str for consistent handling with context functions.\n    _text_str = str(text)\n    # The 'errors' parameter is standard for codecs. However, based on the\n    # docstring's 'Raises' section, the only explicit error condition described\n    # (invalid escaped UTF-8 bytes in the input) is handled strictly.\n    # Other error modes like 'ignore' or 'replace' are not directly applicable\n    # to this specific parsing error as per the context functions' behavior.\n    # The final encoding step (string of hex escapes to bytes) will always succeed.\n    _errors_str = str(errors) # Keep for signature, but its effect is limited here.\n\n\n    # Step 1: Interpret any escaped UTF-8 hexadecimal sequences (e.g., '\\\\xc2\\\\xa9')\n    # in the input string, converting them into their corresponding Unicode characters (e.g., '©').\n    # This function is crucial for inputs that contain raw byte escapes that need to be decoded.\n    try:\n        interpreted_text = convert_escaped_utf8_literal(_text_str)\n    except UnicodeDecodeError as e:\n        # As per the `Raises` section in the docstring, if the input `text` contains\n        # escaped UTF-8 hexadecimal that references invalid UTF-8 bytes, a\n        # UnicodeEncodeError must be raised.\n        # `convert_escaped_utf8_literal` uses a codec that is strict by default for\n        # invalid byte sequences, so it raises `UnicodeDecodeError` in such cases.\n        # We re-raise this as `UnicodeEncodeError` to match the query function's specification.\n        raise UnicodeEncodeError(\n            'escaped_utf8_hex', # A descriptive name for this custom encoding process\n            _text_str,\n            e.start,\n            e.end,\n            f\"invalid utf8 bytes in escaped hexadecimal: {e.reason}\"\n        ) from e\n\n    # Step 2: Convert the now interpreted Unicode string (e.g., 'test©')\n    # into a string representation where all characters are converted to\n    # escaped UTF-8 hexadecimal (e.g., '\\\\x74\\\\x65\\\\x73\\\\x74\\\\xc2\\\\xa9').\n    # The `as_escaped_utf8_literal` function handles the internal UTF-8 encoding\n    # and subsequent hexadecimal formatting.\n    escaped_hex_string = as_escaped_utf8_literal(interpreted_text)\n\n    # Step 3: Encode this string of escaped hexadecimal characters into bytes.\n    # Since `escaped_hex_string` is composed solely of ASCII characters\n    # (backslashes, 'x', and hexadecimal digits), encoding it with 'utf-8'\n    # (or 'ascii') will produce the literal byte representation of that string.\n    # For example, the string '\\\\x74\\\\x65' becomes the bytes b'\\\\x74\\\\x65'.\n    result_bytes = escaped_hex_string.encode('utf-8')\n\n    # The number of characters consumed is simply the length of the original input string.\n    chars_consumed = len(_text_str)\n\n    return result_bytes, chars_consumed"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\n# Imports from context functions, specifically for the `encode` function\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.codecs import register_codecs\n\n# Register the custom codecs. This is typically done once at module load\n# or during a codec registration process. Placing it here ensures it's\n# executed before `encode` is called, as `convert_escaped_utf8_literal`\n# relies on the 'raw_utf8_escape' codec being registered.\nregister_codecs()\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Ensure the input text is a standard string for processing functions\n    # that specifically expect 'str' (e.g., convert_escaped_utf8_literal).\n    # UserString objects are implicitly convertible.\n    input_str = str(text)\n    # Ensure the errors argument is a string for the final encode call.\n    errors_str = str(errors)\n\n    # Step 1: Normalize the input string.\n    # This step is crucial for handling the \"may contain escaped utf8 hexadecimal\"\n    # part of the docstring. It converts any literal '\\xNN' sequences (e.g., '\\\\xc2\\\\xa9')\n    # within the input string into their corresponding Unicode characters (e.g., '©').\n    # This process implicitly validates these escaped sequences: if they do not form\n    # valid UTF-8 bytes (e.g., '\\\\xff'), `convert_escaped_utf8_literal` will raise\n    # a `UnicodeDecodeError`.\n    try:\n        normalized_text = convert_escaped_utf8_literal(input_str)\n    except UnicodeDecodeError as exc:\n        # As per the docstring, if invalid UTF-8 bytes are found within escaped\n        # hexadecimal sequences in the input, a `UnicodeEncodeError` must be raised.\n        # This specific error condition implies a 'strict' validation for the\n        # input's format, irrespective of the general 'errors' parameter for\n        # the overall encoding process. Thus, we re-raise for this scenario.\n        raise UnicodeEncodeError(\n            'raw_utf8_escape_codec',  # Conventional name for the codec.\n            input_str,                # The original object being processed.\n            exc.start,                # Start index of the problematic part.\n            exc.end,                  # End index of the problematic part.\n            f\"invalid utf8 bytes found in escaped hexadecimal sequence: {exc.reason}\"\n        ) from exc\n\n    # Step 2: Convert the normalized string into its escaped UTF-8 hexadecimal\n    # representation. The `_each_utf8_hex` generator (defined earlier in this file)\n    # is ideal for this. It yields individual printable ASCII characters as they are,\n    # and converts non-ASCII or non-printable ASCII characters into their UTF-8\n    # byte equivalents, formatted as '\\\\xNN' strings.\n    parts = []\n    for part in _each_utf8_hex(normalized_text):\n        parts.append(part)\n\n    # Join the generated string parts into a single string.\n    # The resulting string should exclusively contain ASCII characters\n    # (printable ASCII, and the literal characters '\\' and 'x' followed by hex digits).\n    output_str = \"\".join(parts)\n\n    # Step 3: Encode the resulting ASCII string to bytes.\n    # The 'ascii' encoding is appropriate and safe here, as `_each_utf8_hex`\n    # is designed to produce an output string composed solely of ASCII characters.\n    # The `errors_str` parameter is passed to this final encoding step, though for\n    # `_each_utf8_hex`'s output, it typically won't trigger errors unless the output\n    # contained unexpected non-ASCII characters.\n    encoded_bytes = output_str.encode('ascii', errors=errors_str)\n\n    # The number of characters consumed is the length of the original input string,\n    # as the entire string is processed for encoding.\n    chars_consumed = len(text)\n\n    return encoded_bytes, chars_consumed\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n# Context function imports:\n# From Context Function 1:\nfrom flutils.strutils import convert_escaped_utf8_literal\n# From Context Function 4:\nfrom flutils.strutils import as_escaped_utf8_literal\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    if not isinstance(text, (str, UserString)):\n        raise TypeError('\\'text\\' must be a str or UserString.')\n    if not isinstance(errors, (str, UserString)):\n        raise TypeError('\\'errors\\' must be a str or UserString.')\n\n    # Step 1: Normalize the input string by converting any literal escaped\n    # UTF-8 hexadecimal sequences (e.g., \\\\xc2\\\\xa9) into their\n    # corresponding Unicode characters.\n    # The convert_escaped_utf8_literal function internally uses a 'raw_utf8_escape'\n    # codec, which implicitly handles errors in a 'strict' manner.\n    # If invalid UTF-8 byte sequences are found within the escaped hex,\n    # it will raise a UnicodeDecodeError.\n    try:\n        normalized_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # As per the docstring, if the input text contains escaped utf8 hexadecimal\n        # that references invalid utf8 bytes, a UnicodeEncodeError should be raised.\n        # We catch the UnicodeDecodeError and re-raise it as UnicodeEncodeError.\n        raise UnicodeEncodeError(\n            e.encoding,\n            e.object,\n            e.start,\n            e.end,\n            \"Invalid escaped UTF-8 hexadecimal sequence found in the input string.\"\n        ) from e\n\n    # Step 2: Convert the normalized string into its escaped UTF-8 hexadecimal\n    # string representation. This produces a string composed solely of\n    # ASCII characters (e.g., '\\', 'x', '0'-'9', 'a'-'f').\n    escaped_str_representation = as_escaped_utf8_literal(normalized_text)\n\n    # Step 3: Encode this ASCII-only string representation into bytes.\n    # The 'errors' parameter from the function signature is applied here.\n    # Since 'escaped_str_representation' is expected to be pure ASCII,\n    # this 'errors' handling will typically only be relevant if 'errors'\n    # is not 'strict' and an unexpected non-ASCII character were somehow\n    # present (which should not occur with as_escaped_utf8_literal's output).\n    output_bytes = escaped_str_representation.encode('ascii', errors=str(errors))\n\n    # The number of characters consumed is the length of the original input string.\n    consumed_chars = len(text)\n\n    return output_bytes, consumed_chars\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n# _Str is already defined in File Content\n_Str = Union[str, UserString]\n\n# Context function imports\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.strutils import as_escaped_utf8_literal\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Ensure text is a standard str for compatibility with context functions\n    if isinstance(text, UserString):\n        text_str = str(text)\n    else:\n        text_str = text\n\n    # Ensure errors is a standard str\n    if isinstance(errors, UserString):\n        errors_str = str(errors)\n    else:\n        errors_str = errors\n\n    # Step 1: Normalize the input string.\n    # The `text` input might contain literal escaped UTF-8 hexadecimal sequences\n    # (e.g., \"\\\\xc2\\\\xa9\"). `convert_escaped_utf8_literal` interprets these\n    # sequences and converts them into their actual Unicode characters (e.g., \"©\").\n    # This ensures we work with the semantic content of the string.\n    #\n    # This function operates strictly regarding invalid UTF-8 sequences. If an\n    # escaped sequence refers to invalid UTF-8 bytes, it will raise a\n    # UnicodeDecodeError. As per the query function's docstring, if `errors`\n    # is 'strict', this specific error should be re-raised as a UnicodeEncodeError.\n    try:\n        normalized_text = convert_escaped_utf8_literal(text_str)\n    except UnicodeDecodeError as e:\n        if errors_str == 'strict':\n            # Re-raise as UnicodeEncodeError as specified in the docstring.\n            # The 'raw_utf8_escape' is the name of the codec involved in the decoding.\n            raise UnicodeEncodeError(\n                'raw_utf8_escape',\n                text_str,\n                e.start,\n                e.end,\n                f\"Invalid UTF-8 escaped hexadecimal sequence in input: {e}\"\n            ) from e\n        else:\n            # If `errors_str` is not 'strict' (e.g., 'ignore', 'replace'),\n            # the `convert_escaped_utf8_literal` function does not support\n            # those error modes for its internal decoding. Therefore, the\n            # original UnicodeDecodeError will propagate. This is a limitation\n            # imposed by the behavior of the provided context function.\n            raise # Re-raise the original UnicodeDecodeError\n\n    # Step 2: Convert the normalized string into its escaped UTF-8 hexadecimal\n    # string representation. This means every character in `normalized_text`\n    # will be converted into its '\\xNN' UTF-8 byte sequence string form.\n    # For example, 'A' becomes '\\\\x41', '©' becomes '\\\\xc2\\\\xa9'.\n    escaped_hex_string = as_escaped_utf8_literal(normalized_text)\n\n    # Step 3: Convert the resulting `escaped_hex_string` to bytes.\n    # Since `escaped_hex_string` only contains printable ASCII characters\n    # (letters, digits, '\\', 'x'), it can be safely encoded using 'latin-1'\n    # (which maps ASCII characters directly to their byte values).\n    # This step should not raise a UnicodeEncodeError as the string is ASCII-safe.\n    result_bytes = escaped_hex_string.encode('latin-1')\n\n    # Step 4: Determine the number of characters consumed from the original input.\n    # This is simply the length of the original input string.\n    consumed_characters = len(text_str)\n\n    return result_bytes, consumed_characters\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n# Context function imports\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.strutils import as_escaped_utf8_literal\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Validate the 'errors' parameter. As per the docstring and context,\n    # only 'strict' mode is explicitly supported for error handling that\n    # results in UnicodeEncodeError. Other modes would require custom codec\n    # implementations not detailed in the provided context.\n    if errors != 'strict':\n        raise ValueError(\n            f\"Unknown error handling mode: '{errors}'. Only 'strict' is supported.\"\n        )\n\n    # Step 1: Convert any existing escaped UTF-8 hexadecimal sequences\n    # (e.g., '\\\\xc2\\\\xa9') in the input `text` to their corresponding\n    # Unicode characters (e.g., '©').\n    # This addresses the \"may contain escaped utf8 hexadecimal\" part of the query.\n    try:\n        # Cast `text` to `str` to ensure compatibility with `convert_escaped_utf8_literal`\n        # which expects a `str` argument, though `UserString` often behaves like `str`.\n        intermediate_text = convert_escaped_utf8_literal(str(text))\n    except UnicodeDecodeError as e:\n        # The docstring for the `encode` function specifies raising `UnicodeEncodeError`\n        # for invalid UTF-8 bytes within escaped hexadecimal sequences.\n        # We catch the `UnicodeDecodeError` thrown by `convert_escaped_utf8_literal`\n        # and re-raise it as `UnicodeEncodeError` to match the specified behavior.\n        raise UnicodeEncodeError(\n            e.encoding,  # The encoding that failed ('raw_utf8_escape' in this case)\n            e.object,    # The bytes object being decoded\n            e.start,     # The index into the object where the error occurred\n            e.end,       # The index after the problematic sequence\n            e.reason     # The reason for the error\n        ) from e\n\n    # Step 2: Convert the now normalized `intermediate_text` into a string\n    # where all characters (including ASCII characters) are represented as\n    # '\\xNN' hexadecimal escapes.\n    # For example:\n    # - 'hello' becomes '\\\\x68\\\\x65\\\\x6c\\\\x6c\\\\x6f'\n    # - '©' becomes '\\\\xc2\\\\xa9'\n    # - 'hello©' becomes '\\\\x68\\\\x65\\\\x6c\\\\x6c\\\\x6f\\\\xc2\\\\xa9'\n    final_escaped_str = as_escaped_utf8_literal(intermediate_text)\n\n    # Step 3: Convert this `final_escaped_str` (which is a string of\n    # '\\xNN' sequences) into a `bytes` object.\n    # This results in a byte string that literally contains the '\\xNN'\n    # sequences. For example, the string '\\\\x68' becomes the bytes b'\\\\x68'\n    # (where each character `\\` `x` `6` `8` is represented by its UTF-8 byte).\n    output_bytes = final_escaped_str.encode('utf-8')\n\n    # The number of characters consumed is simply the length of the original input text.\n    characters_consumed = len(text)\n\n    return output_bytes, characters_consumed\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n# Necessary imports from context functions\nfrom flutils.strutils import convert_escaped_utf8_literal\nfrom flutils.strutils import as_escaped_utf8_literal\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    if not isinstance(text, (str, UserString)):\n        raise TypeError('Expected text to be str or UserString')\n    if not isinstance(errors, (str, UserString)):\n        raise TypeError('Expected errors to be str or UserString')\n\n    # Convert UserString inputs to plain str for consistent handling with context functions.\n    _text_str = str(text)\n    # The 'errors' parameter is standard for codecs. However, based on the\n    # docstring's 'Raises' section, the only explicit error condition described\n    # (invalid escaped UTF-8 bytes in the input) is handled strictly.\n    # Other error modes like 'ignore' or 'replace' are not directly applicable\n    # to this specific parsing error as per the context functions' behavior.\n    # The final encoding step (string of hex escapes to bytes) will always succeed.\n    _errors_str = str(errors) # Keep for signature, but its effect is limited here.\n\n\n    # Step 1: Interpret any escaped UTF-8 hexadecimal sequences (e.g., '\\\\xc2\\\\xa9')\n    # in the input string, converting them into their corresponding Unicode characters (e.g., '©').\n    # This function is crucial for inputs that contain raw byte escapes that need to be decoded.\n    try:\n        interpreted_text = convert_escaped_utf8_literal(_text_str)\n    except UnicodeDecodeError as e:\n        # As per the `Raises` section in the docstring, if the input `text` contains\n        # escaped UTF-8 hexadecimal that references invalid UTF-8 bytes, a\n        # UnicodeEncodeError must be raised.\n        # `convert_escaped_utf8_literal` uses a codec that is strict by default for\n        # invalid byte sequences, so it raises `UnicodeDecodeError` in such cases.\n        # We re-raise this as `UnicodeEncodeError` to match the query function's specification.\n        raise UnicodeEncodeError(\n            'escaped_utf8_hex', # A descriptive name for this custom encoding process\n            _text_str,\n            e.start,\n            e.end,\n            f\"invalid utf8 bytes in escaped hexadecimal: {e.reason}\"\n        ) from e\n\n    # Step 2: Convert the now interpreted Unicode string (e.g., 'test©')\n    # into a string representation where all characters are converted to\n    # escaped UTF-8 hexadecimal (e.g., '\\\\x74\\\\x65\\\\x73\\\\x74\\\\xc2\\\\xa9').\n    # The `as_escaped_utf8_literal` function handles the internal UTF-8 encoding\n    # and subsequent hexadecimal formatting.\n    escaped_hex_string = as_escaped_utf8_literal(interpreted_text)\n\n    # Step 3: Encode this string of escaped hexadecimal characters into bytes.\n    # Since `escaped_hex_string` is composed solely of ASCII characters\n    # (backslashes, 'x', and hexadecimal digits), encoding it with 'utf-8'\n    # (or 'ascii') will produce the literal byte representation of that string.\n    # For example, the string '\\\\x74\\\\x65' becomes the bytes b'\\\\x74\\\\x65'.\n    result_bytes = escaped_hex_string.encode('utf-8')\n\n    # The number of characters consumed is simply the length of the original input string.\n    chars_consumed = len(_text_str)\n\n    return result_bytes, chars_consumed\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_17():\n    assert encode('é', 'strict') == (b'\\\\xc3\\\\xa9', 1)\ntest_17()\n\ndef test_37():\n    assert encode(u'abcde') == (b'abcde', 5)\ntest_37()\n\ndef test_42():\n    assert encode('ⴚ') == (b'\\\\xe2\\\\xb4\\\\x9a', 1)\ntest_42()\n\ndef test_45():\n    assert encode('abc', 'strict') == (b'abc', 3)\ntest_45()\n\ndef test_46():\n    assert encode('123') == (b'123', 3)\ntest_46()\n\ndef test_55():\n    assert encode('♫') == (b'\\\\xe2\\\\x99\\\\xab', 1)\ntest_55()\n\ndef test_62():\n    assert encode('abc\\x10', 'strict') == (b'abc\\\\x10', 4)\ntest_62()\n\ndef test_117():\n    assert encode('♡') == (b'\\\\xe2\\\\x99\\\\xa1', 1)\ntest_117()\n\ndef test_121():\n    assert decode(encode(\"a\")[0], 'strict') == (\"a\", 1)\ntest_121()\n\ndef test_122():\n    assert decode(encode(u\"\\x7e\")[0]) == (u\"\\x7e\", 1)\ntest_122()\n\ndef test_124():\n    assert encode('abc') == (b'abc', 3)\ntest_124()\n\ndef test_145():\n    assert 3 == len(encode(\"abc\")[0])\ntest_145()\n\ndef test_155():\n    assert encode('⛄') == (b'\\\\xe2\\\\x9b\\\\x84', 1)\ntest_155()\n\ndef test_182():\n    assert encode('This is an example.')\ntest_182()\n\ndef test_208():\n    assert encode('123abc') == (b'123abc', 6)\ntest_208()\n\ndef test_214():\n    assert encode('⚣') == (b'\\\\xe2\\\\x9a\\\\xa3', 1)\ntest_214()\n\ndef test_216():\n    assert encode('𝄞') == (b'\\\\xf0\\\\x9d\\\\x84\\\\x9e', 1)\ntest_216()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_0()\n\ndef test_2():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('😀', errors='strict') == output\ntest_2()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'©') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('“') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\")[0]) == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'surrogateescape') == output\ntest_7()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000\") == output\ntest_8()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'backslashreplace') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Добрый вечер') == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab') == output\ntest_11()\n\ndef test_12():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_12\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == output\ntest_12()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"asdf\\u0034\\u0035asdf\")[0]) == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'replace') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x23') == output\ntest_16()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'€', 'strict') == output\ntest_18()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a', 'strict') == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is a test of the emergency broadcast system. This is only a test.') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x02', 'strict') == output\ntest_22()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\\\xE2\\\\x82\\\\xAC', 'strict') == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('A test string') == output\ntest_25()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'xmlcharrefreplace') == output\ntest_27()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐈\") == output\ntest_29()\n\ndef test_31():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_31\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('têst') == output\ntest_31()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('·') == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\") == output\ntest_36()\n\ndef test_38():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_38\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\\xff\") == output\ntest_38()\n\ndef test_39():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_39\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"…\") == output\ntest_39()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"’\") == output\ntest_40()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\n\") == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'surrogateescape') == output\ntest_43()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x09', 'strict') == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_50()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000\") == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\xff\") == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03\\x04\\x05') == output\ntest_56()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'namereplace') == output\ntest_57()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\u00A9B\\u00A9C\") == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\xA9B\\xA9C\") == output\ntest_59()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\x7f\")[0]) == output\ntest_64()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('𝙥') == output\ntest_66()\n\ndef test_67():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_67\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00\") == output\ntest_67()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc4\\x90\\xc4\\x91\\xc4\\x92\\xc4\\x93') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xfc') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"Привет\") == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02') == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"‘\") == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('³') == output\ntest_74()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓔ') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('©') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\n        'abcde',\n        'strict',\n    ) == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000\") == output\ntest_78()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'replace') == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('café') == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\t\") == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x06', 'strict') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000000000\") == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'backslashreplace') == output\ntest_85()\n\ndef test_86():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_86\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'replace')[0], 'strict') == output\ntest_86()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"abc\\u00e3\")[0]) == output\ntest_88()\n\ndef test_89():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_89\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓕ') == output\ntest_89()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′′') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"å\")[0], 'strict') == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'namereplace') == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('é', 'ignore') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\N{COPYRIGHT SIGN}B\\N{COPYRIGHT SIGN}\") == output\ntest_94()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000000000\") == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('абв') == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"He said, «hé».\") == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\\\xe2\\\\x80\\\\xa6\") == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\000000\") == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab') == output\ntest_102()\n\ndef test_103():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_103\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abcdé', 'strict') == output\ntest_103()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¢') == output\ntest_104()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\f\") == output\ntest_105()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(encode(\"\\u00e3\")[0]) == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Добрый вечер', 'strict') == output\ntest_107()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¹') == output\ntest_110()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0\") == output\ntest_111()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x89') == output\ntest_113()\n\ndef test_114():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_114\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0c', 'strict') == output\ntest_114()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7e\") == output\ntest_115()\n\ndef test_116():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_116\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"你好\") == output\ntest_116()\n\ndef test_118():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_118\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000000\") == output\ntest_118()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\")[0], 'strict') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x0a\") == output\ntest_125()\n\ndef test_126():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_126\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ABCD 0123 4567 89EF') == output\ntest_126()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\00000\") == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"strict\") == output\ntest_128()\n\ndef test_130():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_130\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('Mélanie') == output\ntest_130()\n\ndef test_131():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_131\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝐀\") == output\ntest_131()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"asdf\\u0034\\u0035asdf\") == output\ntest_132()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('☿') == output\ntest_133()\n\ndef test_134():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_134\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab') == output\ntest_134()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\b\") == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x67') == output\ntest_137()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x9a') == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0b', 'strict') == output\ntest_139()\n\ndef test_140():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_140\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"å\") == output\ntest_140()\n\ndef test_141():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_141\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x05', 'strict') == output\ntest_141()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓑ') == output\ntest_142()\n\ndef test_143():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_143\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x34\") == output\ntest_143()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x01', 'strict') == output\ntest_144()\n\ndef test_146():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_146\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"A\\x8e\\xaa\\xa1\") == output\ntest_146()\n\ndef test_147():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_147\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7A', 'strict') == output\ntest_147()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('123абв') == output\ntest_148()\n\ndef test_149():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_149\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('․') == output\ntest_149()\n\ndef test_150():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_150\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000\") == output\ntest_150()\n\ndef test_151():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_151\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('¼') == output\ntest_151()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"abc\\u00e3\") == output\ntest_152()\n\ndef test_153():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_153\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x78') == output\ntest_153()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(' ', 'strict') == output\ntest_154()\n\ndef test_156():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_156\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(b'\\xc3\\xa4\\xc3\\xb6\\xc3\\xa9') == output\ntest_156()\n\ndef test_157():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_157\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('®') == output\ntest_157()\n\ndef test_160():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_160\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x01') == output\ntest_160()\n\ndef test_161():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_161\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x34') == output\ntest_161()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"𝟎\") == output\ntest_162()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x03', 'strict') == output\ntest_163()\n\ndef test_164():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_164\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"\\u00e3\") == output\ntest_164()\n\ndef test_165():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_165\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'\\x7a', 'strict') == output\ntest_165()\n\ndef test_166():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_166\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x04', 'strict') == output\ntest_166()\n\ndef test_167():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_167\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7a\\x7a', 'strict') == output\ntest_167()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x45') == output\ntest_168()\n\ndef test_169():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_169\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xef') == output\ntest_169()\n\ndef test_173():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_173\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x12') == output\ntest_173()\n\ndef test_175():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_175\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'strict') == output\ntest_175()\n\ndef test_179():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_179\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo\\x7A', 'strict') == output\ntest_179()\n\ndef test_180():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_180\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'Hello') == output\ntest_180()\n\ndef test_181():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_181\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0d', 'strict') == output\ntest_181()\n\ndef test_183():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_183\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000\") == output\ntest_183()\n\ndef test_184():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_184\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\u05e0b\") == output\ntest_184()\n\ndef test_187():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_187\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'abcd\\xe9') == output\ntest_187()\n\ndef test_188():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_188\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓒ') == output\ntest_188()\n\ndef test_189():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_189\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('′') == output\ntest_189()\n\ndef test_190():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_190\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\") == output\ntest_190()\n\ndef test_191():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_191\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\v\") == output\ntest_191()\n\ndef test_193():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_193\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('”') == output\ntest_193()\n\ndef test_194():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_194\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('ⓤ') == output\ntest_194()\n\ndef test_195():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_195\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'xmlcharrefreplace') == output\ntest_195()\n\ndef test_196():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_196\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x56') == output\ntest_196()\n\ndef test_197():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_197\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab\\xab\\xab\\xab\\xab') == output\ntest_197()\n\ndef test_198():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_198\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('This is an example.') == output\ntest_198()\n\ndef test_200():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_200\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'replace') == output\ntest_200()\n\ndef test_201():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_201\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0a', 'strict') == output\ntest_201()\n\ndef test_202():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_202\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xde') == output\ntest_202()\n\ndef test_204():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_204\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('²') == output\ntest_204()\n\ndef test_206():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_206\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(\"åäö\", 'ignore')[0], 'strict') == output\ntest_206()\n\ndef test_207():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_207\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'日本語') == output\ntest_207()\n\ndef test_210():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_210\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x08', 'strict') == output\ntest_210()\n\ndef test_211():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_211\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x00', 'strict') == output\ntest_211()\n\ndef test_212():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_212\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0e', 'strict') == output\ntest_212()\n\ndef test_213():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_213\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"ABC\\u00A2\\u00A3\\u00A4\", errors=\"ignore\") == output\ntest_213()\n\ndef test_215():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_215\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xcd') == output\ntest_215()\n\ndef test_217():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_217\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xbc') == output\ntest_217()\n\ndef test_218():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_218\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"a\\0000000000\") == output\ntest_218()\n\ndef test_219():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_219\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('½') == output\ntest_219()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x0f', 'strict') == output\ntest_220()\n\ndef test_221():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_221\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u\"\\x7f\") == output\ntest_221()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab') == output\ntest_222()\n\ndef test_223():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_223\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('°') == output\ntest_223()\n\ndef test_224():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_224\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'foo', 'strict') == output\ntest_224()\n\ndef test_225():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_225\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(chr(233)) == output\ntest_225()\n\ndef test_226():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_226\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\xab\\xab') == output\ntest_226()\n\ndef test_227():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_227\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(\"русский\", errors=\"strict\") == output\ntest_227()\n\ndef test_228():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_228\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('\\x00\\x01\\x02\\x03') == output\ntest_228()\n\ndef test_229():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_229\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('aa') == output\ntest_229()\n\ndef test_230():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_230\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(encode(u\"\\xff\")[0]) == output\ntest_230()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode(u'你好', 'ignore') == output\ntest_232()\n\ndef test_233():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/encode/test_233\", \"rb\") as f:\n        output = pickle.load(f)\n    assert encode('abc\\x07', 'strict') == output\ntest_233()\n\n\ndef test_extra_1():\n    try:\n        encode(b'\\xff')\n    except UnicodeEncodeError as e:\n        assert str(e.reason) == \"invalid start byte\"\ntest_extra_1()"]}
{"task_id": 141, "project": "test-apps/flutils", "module": "flutils.codecs.raw_utf8_escape", "predictions": ["import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n# Import necessary function from context\nfrom flutils.strutils import convert_escaped_utf8_literal\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Ensure data is bytes for consistent processing\n    data_input = bytes(data)\n\n    # Convert errors to str if it's UserString\n    errors_input = str(errors)\n\n    # The 'encode' function's last step is 'out_str.encode('utf-8')'.\n    # This implies that the input 'data' bytes are the UTF-8 encoding of a\n    # string that contains literal escaped hexadecimal sequences (e.g., '\\xHH').\n    # So, the first step in decoding is to decode the input bytes from 'utf-8'\n    # to reconstruct this intermediate string.\n    try:\n        # Example: If data_input is b'test\\\\xc2\\\\xa9' (actual UTF-8 bytes for that string),\n        # this step will convert it to the string 'test\\\\xc2\\\\xa9'.\n        escaped_hex_str = data_input.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Re-raise with appropriate context, mirroring the error raising pattern\n        # from the 'encode' function, which uses 'eutf8h' as the encoding name.\n        raise UnicodeDecodeError(\n            'eutf8h',  # Encoding name for the error (consistent with 'encode')\n            data_input,  # The object being decoded (the bytes)\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now, we have a string like 'test\\\\xc2\\\\xa9' where '\\\\xHH' represents\n    # escaped UTF-8 hexadecimal characters.\n    # The 'convert_escaped_utf8_literal' function is designed to take such\n    # a string and convert these escaped sequences into their actual Unicode\n    # characters. It handles the internal decoding using the 'raw_utf8_escape' codec.\n    try:\n        decoded_str = convert_escaped_utf8_literal(escaped_hex_str)\n    except UnicodeDecodeError:\n        # The 'convert_escaped_utf8_literal' function already raises\n        # a UnicodeDecodeError with relevant details if the escaped bytes\n        # do not form valid UTF-8 sequences. We can simply re-raise it.\n        raise\n\n    # Return the final decoded string and the number of bytes consumed (length of original data).\n    return decoded_str, len(data_input)", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # The input 'data' is bytes, e.g., b'\\\\xc2\\\\xa9'.\n    # We need to interpret these bytes as a string that *literally* contains\n    # '\\', 'x', 'c', '2', etc. 'latin-1' encoding is suitable for this as\n    # it maps each byte value directly to a Unicode code point.\n    # Result: str, e.g., '\\\\xc2\\\\xa9'\n    data_str_literal_escapes = data.decode('latin-1')\n\n    # Convert the string of literal escapes back into bytes. This step\n    # is crucial because the 'unicode_escape' codec for bytes.decode()\n    # expects a byte string where '\\x' represents a backslash followed by 'x'.\n    # e.g., '\\\\xc2\\\\xa9'.encode('latin-1') -> b'\\\\xc2\\\\xa9'\n    bytes_with_literal_escapes = data_str_literal_escapes.encode('latin-1')\n\n    # Decode the bytes using 'unicode_escape'. This codec will interpret\n    # '\\xHH' sequences within the byte string as actual hexadecimal characters\n    # and convert them into a string of corresponding Unicode characters.\n    # e.g., b'\\\\xc2\\\\xa9'.decode('unicode_escape') -> '\\xc2\\xa9'\n    # (This is a string containing the characters represented by the hex values 0xC2 and 0xA9)\n    str_with_raw_bytes_chars = bytes_with_literal_escapes.decode('unicode_escape')\n\n    # Encode this string of raw byte characters back into actual bytes using 'latin-1'.\n    # This reverses the previous step, yielding the raw UTF-8 bytes that the\n    # escaped hexadecimal sequences originally represented.\n    # e.g., '\\xc2\\xa9'.encode('latin-1') -> b'\\xc2\\xa9' (actual UTF-8 bytes)\n    raw_utf8_bytes = str_with_raw_bytes_chars.encode('latin-1')\n\n    # Finally, decode these raw UTF-8 bytes into the desired Python string.\n    # This step applies the specified error handling.\n    try:\n        decoded_str = raw_utf8_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Re-raise the UnicodeDecodeError, maintaining consistency with\n        # the 'encode' function's error handling.\n        # The 'object' parameter of UnicodeDecodeError typically represents\n        # the original data that caused the error. Here, we use its string\n        # representation for better context in the error message.\n        raise UnicodeDecodeError(\n            'eutf8h',  # The encoding name, matching 'encode'\n            data_str_literal_escapes,  # The string form of the input bytes\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # The number of bytes consumed is simply the length of the input 'data'.\n    return decoded_str, len(data)", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    errors_input = str(errors)\n    consumed_bytes = len(data)\n\n    # Convert data to bytes for consistent processing\n    data_bytes = bytes(data)\n\n    # Buffer to store the actual UTF-8 bytes after parsing '\\\\xHH' sequences\n    actual_utf8_bytes = bytearray()\n\n    i = 0\n    while i < len(data_bytes):\n        # Check for '\\\\x' escape sequence\n        if i + 1 < len(data_bytes) and data_bytes[i:i+2] == b'\\\\x':\n            # Potential '\\\\xHH' sequence: requires 2 more bytes for hex digits\n            if i + 3 < len(data_bytes):\n                hex_digits = data_bytes[i+2:i+4]\n                try:\n                    # Decode hex digits to ASCII string, then parse as integer\n                    byte_val = int(hex_digits.decode('ascii'), 16)\n                    actual_utf8_bytes.append(byte_val)\n                    i += 4  # Consumed '\\\\xHH'\n                except (ValueError, UnicodeDecodeError):\n                    # Invalid hex format (e.g., '\\\\xGx') or non-ascii in hex digits.\n                    # Treat the \\\\x as literal characters and let final decode handle errors.\n                    actual_utf8_bytes.append(data_bytes[i])    # Append '\\'\n                    actual_utf8_bytes.append(data_bytes[i+1])  # Append 'x'\n                    i += 2  # Consumed '\\\\x'\n            else:\n                # Not enough bytes for a full '\\\\xHH' sequence, treat '\\\\x' literally\n                actual_utf8_bytes.append(data_bytes[i])    # Append '\\'\n                actual_utf8_bytes.append(data_bytes[i+1])  # Append 'x'\n                i += 2  # Consumed '\\\\x'\n        else:\n            # Not an escape sequence, append the byte as is\n            actual_utf8_bytes.append(data_bytes[i])\n            i += 1\n\n    # Now, decode the collected actual UTF-8 bytes to a string, applying the 'errors' policy\n    try:\n        final_str = actual_utf8_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Re-raise to match the error format used by the 'encode' function\n        raise UnicodeDecodeError(\n            'eutf8h',  # The codec name, consistent with 'encode'\n            data_bytes,  # The original input bytes\n            e.start,     # Start of the invalid sequence in actual_utf8_bytes\n            e.end,       # End of the invalid sequence in actual_utf8_bytes\n            e.reason,    # Reason for the decode error\n        )\n\n    return final_str, consumed_bytes", "import codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\n# The `convert_escaped_utf8_literal` function is provided as a context function.\n# It is essential for decoding the escaped UTF-8 hexadecimal sequences.\nfrom flutils.strutils import convert_escaped_utf8_literal\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n        UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # 1. Ensure the input 'data' is in a `bytes` type for consistent processing.\n    # The `_ByteString` type hint allows bytes, bytearray, or memoryview.\n    # The `bytes()` constructor handles conversion from bytearray and memoryview.\n    data_input = bytes(data)\n\n    # 2. Convert the 'errors' parameter to a string type, as it can be a\n    # `UserString`. This ensures compatibility with standard string methods\n    # and codec error handling.\n    errors_input = str(errors)\n\n    # 3. First, decode the `data_input` bytes into a string.\n    # The `encode` function in the file content generates `out_bytes` by\n    # `out_str.encode('utf-8')`. This implies that `data` (the input to\n    # `decode`) is a UTF-8 encoded string where backslashes and hex characters\n    # (e.g., `\\\\xc2\\\\xa9`) are literal characters within that UTF-8 string.\n    # So, `data_input.decode('utf-8')` will convert `b'\\\\xc2\\\\xa9'` to `'\\\\xc2\\\\xa9'`.\n    try:\n        s = data_input.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # If the initial bytes are not valid UTF-8, a UnicodeDecodeError is raised.\n        # We re-raise it, using 'eutf8h' as the encoding name for consistency\n        # with the error handling in the `encode` function.\n        raise UnicodeDecodeError(\n            'eutf8h',        # Custom encoding name for this codec pair\n            data_input,      # The original bytes object that caused the error\n            e.start,         # The position in the bytes where the error occurred\n            e.end,           # The position where the error ended\n            e.reason,        # The reason for the decoding error\n        ) from e\n\n    # 4. Now that we have a string `s` (e.g., `'\\\\xc2\\\\xa9'`), we use the\n    # `convert_escaped_utf8_literal` context function to convert the literal\n    # escaped hexadecimal sequences into their actual Unicode characters.\n    # This function handles the conversion of `\\\\xHH` to actual bytes and then\n    # decodes those bytes as UTF-8.\n    try:\n        decoded_str = convert_escaped_utf8_literal(s)\n    except UnicodeDecodeError as e:\n        # If `convert_escaped_utf8_literal` encounters an invalid UTF-8 byte\n        # sequence within the escaped hex (e.g., `\\\\xff`), it will raise a\n        # `UnicodeDecodeError`. We catch it and re-raise to maintain the\n        # function's specified error handling. The `data_input` is passed\n        # as the object, as it represents the full input to this function.\n        raise UnicodeDecodeError(\n            'eutf8h',        # Custom encoding name\n            data_input,      # The original bytes that led to this error\n            e.start,         # Position in the intermediate string `s` that caused the error\n            e.end,           # Position where the error ended in `s`\n            e.reason,        # Reason for the error from the underlying codec\n        ) from e\n\n    # 5. Return the final decoded string and the number of bytes consumed.\n    # The number of bytes consumed is simply the length of the input data.\n    return decoded_str, len(data_input)", "import codecs\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Tuple,\n    Union,\n)\n\n# Import necessary utilities/codecs from the project's flutils package.\n# The `register_codecs` function is essential for making the 'raw_utf8_escape'\n# codec available, which is used internally for decoding.\nfrom flutils.codecs import register_codecs\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the 'errors' argument to a standard string, as it might be\n    # a UserString instance.\n    errors_input = str(errors)\n\n    # Ensure that the custom codecs, including 'raw_utf8_escape', are\n    # registered with Python's codecs system. This is crucial for the\n    # decoding process to recognize and correctly interpret the escaped\n    # UTF-8 hexadecimal sequences. The `register_codecs` function handles\n    # checking if they're already registered, so it's safe to call.\n    register_codecs()\n\n    try:\n        # The 'raw_utf8_escape' codec is specifically designed to interpret\n        # bytes that represent literal '\\xHH' sequences (e.g., b'\\\\xc3\\\\xa9')\n        # and convert them into the corresponding actual Unicode characters\n        # (e.g., 'é'), while respecting the UTF-8 encoding rules for those\n        # sequences.\n        # The 'errors' argument is passed directly to handle decoding errors\n        # according to the specified error checking level (e.g., 'strict',\n        # 'ignore', 'replace').\n        decoded_str = data.decode('raw_utf8_escape', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # If a UnicodeDecodeError occurs during the decoding process,\n        # it indicates that the input 'data' contained escaped hexadecimal\n        # sequences that do not form valid UTF-8 bytes (e.g., '\\xff').\n        # We re-raise this exception, ensuring its 'encoding' attribute\n        # is set to 'eutf8h', consistent with the custom codec name implied\n        # by the 'encode' function in this module.\n        raise UnicodeDecodeError(\n            'eutf8h',        # The name of the encoding where the error occurred\n            e.object,        # The original bytes object that caused the error (i.e., 'data')\n            e.start,         # The start index in 'data' where the error was found\n            e.end,           # The end index in 'data' where the error was found\n            e.reason,        # A descriptive reason for the decoding failure\n        )\n\n    # The function consumed all of the input 'data' bytes to produce the\n    # decoded string.\n    return decoded_str, len(data)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n# Import necessary function from context\nfrom flutils.strutils import convert_escaped_utf8_literal\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # Ensure data is bytes for consistent processing\n    data_input = bytes(data)\n\n    # Convert errors to str if it's UserString\n    errors_input = str(errors)\n\n    # The 'encode' function's last step is 'out_str.encode('utf-8')'.\n    # This implies that the input 'data' bytes are the UTF-8 encoding of a\n    # string that contains literal escaped hexadecimal sequences (e.g., '\\xHH').\n    # So, the first step in decoding is to decode the input bytes from 'utf-8'\n    # to reconstruct this intermediate string.\n    try:\n        # Example: If data_input is b'test\\\\xc2\\\\xa9' (actual UTF-8 bytes for that string),\n        # this step will convert it to the string 'test\\\\xc2\\\\xa9'.\n        escaped_hex_str = data_input.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Re-raise with appropriate context, mirroring the error raising pattern\n        # from the 'encode' function, which uses 'eutf8h' as the encoding name.\n        raise UnicodeDecodeError(\n            'eutf8h',  # Encoding name for the error (consistent with 'encode')\n            data_input,  # The object being decoded (the bytes)\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Now, we have a string like 'test\\\\xc2\\\\xa9' where '\\\\xHH' represents\n    # escaped UTF-8 hexadecimal characters.\n    # The 'convert_escaped_utf8_literal' function is designed to take such\n    # a string and convert these escaped sequences into their actual Unicode\n    # characters. It handles the internal decoding using the 'raw_utf8_escape' codec.\n    try:\n        decoded_str = convert_escaped_utf8_literal(escaped_hex_str)\n    except UnicodeDecodeError:\n        # The 'convert_escaped_utf8_literal' function already raises\n        # a UnicodeDecodeError with relevant details if the escaped bytes\n        # do not form valid UTF-8 sequences. We can simply re-raise it.\n        raise\n\n    # Return the final decoded string and the number of bytes consumed (length of original data).\n    return decoded_str, len(data_input)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # The input 'data' is bytes, e.g., b'\\\\xc2\\\\xa9'.\n    # We need to interpret these bytes as a string that *literally* contains\n    # '\\', 'x', 'c', '2', etc. 'latin-1' encoding is suitable for this as\n    # it maps each byte value directly to a Unicode code point.\n    # Result: str, e.g., '\\\\xc2\\\\xa9'\n    data_str_literal_escapes = data.decode('latin-1')\n\n    # Convert the string of literal escapes back into bytes. This step\n    # is crucial because the 'unicode_escape' codec for bytes.decode()\n    # expects a byte string where '\\x' represents a backslash followed by 'x'.\n    # e.g., '\\\\xc2\\\\xa9'.encode('latin-1') -> b'\\\\xc2\\\\xa9'\n    bytes_with_literal_escapes = data_str_literal_escapes.encode('latin-1')\n\n    # Decode the bytes using 'unicode_escape'. This codec will interpret\n    # '\\xHH' sequences within the byte string as actual hexadecimal characters\n    # and convert them into a string of corresponding Unicode characters.\n    # e.g., b'\\\\xc2\\\\xa9'.decode('unicode_escape') -> '\\xc2\\xa9'\n    # (This is a string containing the characters represented by the hex values 0xC2 and 0xA9)\n    str_with_raw_bytes_chars = bytes_with_literal_escapes.decode('unicode_escape')\n\n    # Encode this string of raw byte characters back into actual bytes using 'latin-1'.\n    # This reverses the previous step, yielding the raw UTF-8 bytes that the\n    # escaped hexadecimal sequences originally represented.\n    # e.g., '\\xc2\\xa9'.encode('latin-1') -> b'\\xc2\\xa9' (actual UTF-8 bytes)\n    raw_utf8_bytes = str_with_raw_bytes_chars.encode('latin-1')\n\n    # Finally, decode these raw UTF-8 bytes into the desired Python string.\n    # This step applies the specified error handling.\n    try:\n        decoded_str = raw_utf8_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Re-raise the UnicodeDecodeError, maintaining consistency with\n        # the 'encode' function's error handling.\n        # The 'object' parameter of UnicodeDecodeError typically represents\n        # the original data that caused the error. Here, we use its string\n        # representation for better context in the error message.\n        raise UnicodeDecodeError(\n            'eutf8h',  # The encoding name, matching 'encode'\n            data_str_literal_escapes,  # The string form of the input bytes\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # The number of bytes consumed is simply the length of the input 'data'.\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    errors_input = str(errors)\n    consumed_bytes = len(data)\n\n    # Convert data to bytes for consistent processing\n    data_bytes = bytes(data)\n\n    # Buffer to store the actual UTF-8 bytes after parsing '\\\\xHH' sequences\n    actual_utf8_bytes = bytearray()\n\n    i = 0\n    while i < len(data_bytes):\n        # Check for '\\\\x' escape sequence\n        if i + 1 < len(data_bytes) and data_bytes[i:i+2] == b'\\\\x':\n            # Potential '\\\\xHH' sequence: requires 2 more bytes for hex digits\n            if i + 3 < len(data_bytes):\n                hex_digits = data_bytes[i+2:i+4]\n                try:\n                    # Decode hex digits to ASCII string, then parse as integer\n                    byte_val = int(hex_digits.decode('ascii'), 16)\n                    actual_utf8_bytes.append(byte_val)\n                    i += 4  # Consumed '\\\\xHH'\n                except (ValueError, UnicodeDecodeError):\n                    # Invalid hex format (e.g., '\\\\xGx') or non-ascii in hex digits.\n                    # Treat the \\\\x as literal characters and let final decode handle errors.\n                    actual_utf8_bytes.append(data_bytes[i])    # Append '\\'\n                    actual_utf8_bytes.append(data_bytes[i+1])  # Append 'x'\n                    i += 2  # Consumed '\\\\x'\n            else:\n                # Not enough bytes for a full '\\\\xHH' sequence, treat '\\\\x' literally\n                actual_utf8_bytes.append(data_bytes[i])    # Append '\\'\n                actual_utf8_bytes.append(data_bytes[i+1])  # Append 'x'\n                i += 2  # Consumed '\\\\x'\n        else:\n            # Not an escape sequence, append the byte as is\n            actual_utf8_bytes.append(data_bytes[i])\n            i += 1\n\n    # Now, decode the collected actual UTF-8 bytes to a string, applying the 'errors' policy\n    try:\n        final_str = actual_utf8_bytes.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # Re-raise to match the error format used by the 'encode' function\n        raise UnicodeDecodeError(\n            'eutf8h',  # The codec name, consistent with 'encode'\n            data_bytes,  # The original input bytes\n            e.start,     # Start of the invalid sequence in actual_utf8_bytes\n            e.end,       # End of the invalid sequence in actual_utf8_bytes\n            e.reason,    # Reason for the decode error\n        )\n\n    return final_str, consumed_bytes\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\n# The `convert_escaped_utf8_literal` function is provided as a context function.\n# It is essential for decoding the escaped UTF-8 hexadecimal sequences.\nfrom flutils.strutils import convert_escaped_utf8_literal\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n        UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n    # 1. Ensure the input 'data' is in a `bytes` type for consistent processing.\n    # The `_ByteString` type hint allows bytes, bytearray, or memoryview.\n    # The `bytes()` constructor handles conversion from bytearray and memoryview.\n    data_input = bytes(data)\n\n    # 2. Convert the 'errors' parameter to a string type, as it can be a\n    # `UserString`. This ensures compatibility with standard string methods\n    # and codec error handling.\n    errors_input = str(errors)\n\n    # 3. First, decode the `data_input` bytes into a string.\n    # The `encode` function in the file content generates `out_bytes` by\n    # `out_str.encode('utf-8')`. This implies that `data` (the input to\n    # `decode`) is a UTF-8 encoded string where backslashes and hex characters\n    # (e.g., `\\\\xc2\\\\xa9`) are literal characters within that UTF-8 string.\n    # So, `data_input.decode('utf-8')` will convert `b'\\\\xc2\\\\xa9'` to `'\\\\xc2\\\\xa9'`.\n    try:\n        s = data_input.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # If the initial bytes are not valid UTF-8, a UnicodeDecodeError is raised.\n        # We re-raise it, using 'eutf8h' as the encoding name for consistency\n        # with the error handling in the `encode` function.\n        raise UnicodeDecodeError(\n            'eutf8h',        # Custom encoding name for this codec pair\n            data_input,      # The original bytes object that caused the error\n            e.start,         # The position in the bytes where the error occurred\n            e.end,           # The position where the error ended\n            e.reason,        # The reason for the decoding error\n        ) from e\n\n    # 4. Now that we have a string `s` (e.g., `'\\\\xc2\\\\xa9'`), we use the\n    # `convert_escaped_utf8_literal` context function to convert the literal\n    # escaped hexadecimal sequences into their actual Unicode characters.\n    # This function handles the conversion of `\\\\xHH` to actual bytes and then\n    # decodes those bytes as UTF-8.\n    try:\n        decoded_str = convert_escaped_utf8_literal(s)\n    except UnicodeDecodeError as e:\n        # If `convert_escaped_utf8_literal` encounters an invalid UTF-8 byte\n        # sequence within the escaped hex (e.g., `\\\\xff`), it will raise a\n        # `UnicodeDecodeError`. We catch it and re-raise to maintain the\n        # function's specified error handling. The `data_input` is passed\n        # as the object, as it represents the full input to this function.\n        raise UnicodeDecodeError(\n            'eutf8h',        # Custom encoding name\n            data_input,      # The original bytes that led to this error\n            e.start,         # Position in the intermediate string `s` that caused the error\n            e.end,           # Position where the error ended in `s`\n            e.reason,        # Reason for the error from the underlying codec\n        ) from e\n\n    # 5. Return the final decoded string and the number of bytes consumed.\n    # The number of bytes consumed is simply the length of the input data.\n    return decoded_str, len(data_input)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nimport codecs\nfrom collections import UserString\nfrom functools import reduce\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Generator,\n    Optional,\n    Tuple,\n    Union,\n    cast,\n)\n\n_Str = Union[str, UserString]\n\n\ndef _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex\n\n\ndef encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)\n\n\nimport codecs\nfrom collections import UserString\nfrom typing import ByteString as _ByteString\nfrom typing import (\n    Tuple,\n    Union,\n)\n\n# Import necessary utilities/codecs from the project's flutils package.\n# The `register_codecs` function is essential for making the 'raw_utf8_escape'\n# codec available, which is used internally for decoding.\nfrom flutils.codecs import register_codecs\n\n_Str = Union[str, UserString]\n\n\ndef decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n    data (bytes or bytearray or memoryview): The escaped utf8\n    hexadecimal bytes.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n    converted into a :obj:`str`.\n    int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n    UnicodeDecodeError: if the given ``data`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the 'errors' argument to a standard string, as it might be\n    # a UserString instance.\n    errors_input = str(errors)\n\n    # Ensure that the custom codecs, including 'raw_utf8_escape', are\n    # registered with Python's codecs system. This is crucial for the\n    # decoding process to recognize and correctly interpret the escaped\n    # UTF-8 hexadecimal sequences. The `register_codecs` function handles\n    # checking if they're already registered, so it's safe to call.\n    register_codecs()\n\n    try:\n        # The 'raw_utf8_escape' codec is specifically designed to interpret\n        # bytes that represent literal '\\xHH' sequences (e.g., b'\\\\xc3\\\\xa9')\n        # and convert them into the corresponding actual Unicode characters\n        # (e.g., 'é'), while respecting the UTF-8 encoding rules for those\n        # sequences.\n        # The 'errors' argument is passed directly to handle decoding errors\n        # according to the specified error checking level (e.g., 'strict',\n        # 'ignore', 'replace').\n        decoded_str = data.decode('raw_utf8_escape', errors=errors_input)\n    except UnicodeDecodeError as e:\n        # If a UnicodeDecodeError occurs during the decoding process,\n        # it indicates that the input 'data' contained escaped hexadecimal\n        # sequences that do not form valid UTF-8 bytes (e.g., '\\xff').\n        # We re-raise this exception, ensuring its 'encoding' attribute\n        # is set to 'eutf8h', consistent with the custom codec name implied\n        # by the 'encode' function in this module.\n        raise UnicodeDecodeError(\n            'eutf8h',        # The name of the encoding where the error occurred\n            e.object,        # The original bytes object that caused the error (i.e., 'data')\n            e.start,         # The start index in 'data' where the error was found\n            e.end,           # The end index in 'data' where the error was found\n            e.reason,        # A descriptive reason for the decoding failure\n        )\n\n    # The function consumed all of the input 'data' bytes to produce the\n    # decoded string.\n    return decoded_str, len(data)\n\n\nNAME = __name__.split('.')[-1]\n\n\ndef _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None\n\n\ndef register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)   # type: ignore\n\n\nimport pickle\ndef test_12():\n    assert decode(b\"ab\\\\xF0\\\\x9F\\\\x98\\\\x80cd\")[0] == \"ab\\U0001F600cd\"\ntest_12()\n\ndef test_14():\n    assert \"toto\" == decode(b\"toto\")[0]\ntest_14()\n\ndef test_16():\n    assert decode(b'\\xf0\\x9f\\x98\\x80') == ('\\U0001f600', 4)\ntest_16()\n\ndef test_19():\n    assert decode(b'', 'strict') == ('', 0)\ntest_19()\n\ndef test_25():\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81') == ('\\U0001f600\\U0001f601', 8)\ntest_25()\n\ndef test_39():\n    assert decode(b\"\\\\xF0\\\\x9F\\\\x98\\\\x80\")[0] == \"\\U0001F600\"\ntest_39()\n\ndef test_45():\n    assert \"toto\\ntoto\" == decode(b\"toto\\\\ntoto\")[0]\ntest_45()\n\ndef test_46():\n    assert \"toto\\n\" == decode(b\"toto\\\\n\")[0]\ntest_46()\n\ndef test_47():\n    assert b'\\xc3\\xb6'.decode('utf-8') == decode(b'\\\\xc3\\\\xb6')[0]\ntest_47()\n\ndef test_48():\n    assert b'\\\\xfc' == b'\\\\xfc'.decode('utf8').encode('utf8')\ntest_48()\n\ndef test_56():\n    assert b'\\xc3\\xa4'.decode('utf-8') == decode(b'\\\\xc3\\\\xa4')[0]\ntest_56()\n\ndef test_68():\n    assert decode(b\"ab\")[0] == \"ab\"\ntest_68()\n\ndef test_74():\n    assert decode(b'J\\\\x4a', errors='strict')[0] ==  'JJ'\ntest_74()\n\ndef test_96():\n    assert decode(b'01234567') == ('01234567', 8)\ntest_96()\n\ndef test_97():\n    assert decode(b'Test', errors='strict') == ('Test', 4)\ntest_97()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'strict') == output\ntest_1()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'strict') == output\ntest_3()\n\ndef test_4():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'xmlcharrefreplace') == output\ntest_4()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'backslashreplace') == output\ntest_6()\n\ndef test_7():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'ignore') == output\ntest_7()\n\ndef test_9():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'surrogateescape') == output\ntest_9()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'strict') == output\ntest_10()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='namereplace') == output\ntest_15()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert codecs.decode(b'h\\\\x65llo', 'latin1') == output\ntest_17()\n\ndef test_18():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'ignore') == output\ntest_18()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'backslashreplace') == output\ntest_21()\n\ndef test_22():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_22\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'surrogateescape') == output\ntest_22()\n\ndef test_24():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_24\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'ignore') == output\ntest_24()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'ignore') == output\ntest_26()\n\ndef test_27():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_27\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1', 'ignore') == output\ntest_27()\n\ndef test_30():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_30\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'namereplace') == output\ntest_30()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert b'\\\\xce\\\\xba\\\\xe1\\\\xbd\\\\xb9\\\\xcf\\\\x83\\\\xce\\\\xbc\\\\xce\\\\xb5'.decode('utf-8') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'replace') == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'backslashreplace') == output\ntest_41()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'replace') == output\ntest_43()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'backslashreplace') == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='xmlcharrefreplace') == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0', 'replace') == output\ntest_53()\n\ndef test_54():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_54\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1a', 'xmlcharrefreplace') == output\ntest_54()\n\ndef test_55():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_55\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'hello\\xe2\\x82\\xacthere') == output\ntest_55()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'xmlcharrefreplace') == output\ntest_58()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02', 'xmlcharrefreplace') == output\ntest_59()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\u0030\\\\u0031\\\\u0032\\\\u0033\\\\u0034\\\\u0035\\\\u0036\\\\u0037') == output\ntest_60()\n\ndef test_62():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_62\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('\\\\x616263'.encode('utf8'), 'xmlcharrefreplace') == output\ntest_62()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xC3\\xB1\\xC3\\xB1', 'strict') == output\ntest_63()\n\ndef test_64():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_64\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'xmlcharrefreplace') == output\ntest_64()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE9\\\\xE9', errors='replace') == output\ntest_65()\n\ndef test_66():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_66\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01\\\\x02') == output\ntest_66()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'H\\xc3\\xa9llo, \\xe2\\x98\\x83\\xe2\\x9d\\x97 world') == output\ntest_69()\n\ndef test_72():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_72\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc\\\\x80\\\\x81\\\\x82\\\\x83\\\\x84\\\\x85\\\\x86\\\\x87\\\\x88\\\\x89defgh', 'ignore') == output\ntest_72()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'Hola \\xc2\\xa1', 'replace') == output\ntest_73()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xf0\\x9f\\x98\\x80\\xf0\\x9f\\x98\\x81', 'replace') == output\ntest_75()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xe3\\\\x83\\\\x97', errors='ignore') == output\ntest_76()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abcd\\\\xC3\\\\xA91234') == output\ntest_77()\n\ndef test_78():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_78\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x30\\\\x31\\\\x32\\\\x33\\\\x34\\\\x35\\\\x36\\\\x37') == output\ntest_78()\n\ndef test_79():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_79\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_79()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x4a', errors='strict') == output\ntest_82()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'M\\xc3\\xb6\\xc3\\xb6') == output\ntest_84()\n\ndef test_85():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_85\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C\\\\xF0\\\\x9F\\\\x91\\\\x8C') == output\ntest_85()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'abc', 'ignore') == output\ntest_90()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'strict') == output\ntest_91()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode('616263'.encode('utf8'), 'strict') == output\ntest_93()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\x00\\\\x01', 'ignore') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\xe3\\x83\\x97\\xe3\\x83\\xac', 'ignore') == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+codecs+raw_utf8_escape/decode/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert decode(b'\\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3 = \\\\xE2\\\\x82\\\\xAC 100 \\\\xC2\\\\xA3', 'namereplace') == output\ntest_99()\n\n\ndef test_extra_0():\n    try:\n        decode(b'\\\\xc3\\\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_0()\n\ndef test_extra_2():\n    try:\n        decode(b'\\\\xc3')\n    except UnicodeDecodeError as e:\n        assert e.reason == \"unexpected end of data\"\n        assert e.start == 0\n        assert e.end == 1\ntest_extra_2()\n\ndef test_extra_6():\n    try:\n        decode(b'\\xc3\\x28')\n    except UnicodeDecodeError as e:\n        assert e.reason == 'invalid continuation byte'\ntest_extra_6()"]}
{"task_id": 142, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["import typing as _t\n\n\ndef has_any_attrs(obj: _t.Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "import collections\nimport collections.abc\nimport typing\n\ndef has_any_attrs(obj: typing.Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nimport typing as _t\n\n\ndef has_any_attrs(obj: _t.Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nimport collections\nimport collections.abc\nimport typing\n\ndef has_any_attrs(obj: typing.Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if any of the given ``*attrs`` exist on the given\n    ``obj``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_attrs\n    >>> has_any_attrs(dict(),'get','keys','items','values','something')\n    True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr):\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_attrs(int(), 'get', 'keys', 'items', 'values', 'something') is False\ntest_0()\n\ndef test_3():\n    assert has_any_attrs(dict(),'something', 'somethingelse') is False\ntest_3()\n\ndef test_6():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') == True\ntest_6()\n\ndef test_7():\n    assert has_any_attrs(deque(),'appendleft','append')\ntest_7()\n\ndef test_9():\n    assert has_any_attrs(int(),'get','keys','items','values') is False\ntest_9()\n\ndef test_10():\n    assert has_any_attrs(dict(a=1,b=2),'something', 'keys')\ntest_10()\n\ndef test_11():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values', 'something') is True\ntest_11()\n\ndef test_13():\n    assert has_any_attrs(dict(), 'something', 'something') is False\ntest_13()\n\ndef test_15():\n    assert has_any_attrs(dict(),'something','__setstate__') is False\ntest_15()\n\ndef test_16():\n    assert not has_any_attrs(deque(),'get','keys','items','values','something') is True\ntest_16()\n\ndef test_18():\n    assert has_any_attrs(dict(), 'something', 'something_else') is False\ntest_18()\n\ndef test_20():\n    assert has_any_attrs(dict(),'get','items') is True\ntest_20()\n\ndef test_21():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something', '__class__') is True\ntest_21()\n\ndef test_22():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values') is True\ntest_22()\n\ndef test_24():\n    assert has_any_attrs(dict(), 'something1', 'something2') is False\ntest_24()\n\ndef test_25():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values')\ntest_25()\n\ndef test_30():\n    assert has_any_attrs(dict(),'keys','items','values','something') == True\ntest_30()\n\ndef test_31():\n    assert has_any_attrs(dict(),'get','keys','values') is True\ntest_31()\n\ndef test_34():\n    assert has_any_attrs(dict(), 'something', 'something', 'something') is False\ntest_34()\n\ndef test_35():\n    assert has_any_attrs(dict(),'get','keys','keys') == True\ntest_35()\n\ndef test_38():\n    assert has_any_attrs(list(),'get','keys','items','values') is False\ntest_38()\n\ndef test_39():\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2') \\\n            == False\ntest_39()\n\ndef test_41():\n    assert has_any_attrs(dict(),'get','keys','items','values') == True\ntest_41()\n\ndef test_42():\n    assert has_any_attrs(dict(),'get','keys','items','values') is True\ntest_42()\n\ndef test_44():\n    assert has_any_attrs(dict(), 'something') is False\ntest_44()\n\ndef test_45():\n    assert has_any_attrs(dict(),'something','somethingelse') == False\ntest_45()\n\ndef test_46():\n    assert has_any_attrs(dict(),'keys', 'values') is True\ntest_46()\n\ndef test_48():\n    assert has_any_attrs(dict(),'items','something') is True\ntest_48()\n\ndef test_49():\n    assert has_any_attrs(dict(),'get','keys','items','values','__iter__') is True\ntest_49()\n\ndef test_51():\n    assert has_any_attrs(dict(),'something1','something2') \\\n        == False\ntest_51()\n\ndef test_52():\n    assert has_any_attrs(dict(),'get','keys') is True\ntest_52()\n\ndef test_53():\n    assert not has_any_attrs(KeysView(dict()), 'something')\ntest_53()\n\ndef test_54():\n    assert has_any_attrs(dict(),'keys','keys') == True\ntest_54()\n\ndef test_55():\n    assert has_any_attrs(dict(),'something','') == False\ntest_55()\n\ndef test_56():\n    assert not has_any_attrs(KeysView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_56()\n\ndef test_57():\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2') \\\n            == False\ntest_57()\n\ndef test_58():\n    assert has_any_attrs(dict(a=1,b=2),'a', 'keys')\ntest_58()\n\ndef test_60():\n    assert has_any_attrs(dict(),'something','keys','items','values') is True\ntest_60()\n\ndef test_61():\n    assert has_any_attrs(dict(),'get','keys','items','something') is True\ntest_61()\n\ndef test_62():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','a')\ntest_62()\n\ndef test_63():\n    assert has_any_attrs(dict(),'something','another','thing') is False\ntest_63()\n\ndef test_64():\n    assert has_any_attrs(dict(),'get','get') == True\ntest_64()\n\ndef test_65():\n    assert has_any_attrs(dict(),'get','values') is True\ntest_65()\n\ndef test_66():\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values', 'something'\n        )\ntest_66()\n\ndef test_67():\n    assert has_any_attrs(\n        deque(),'something1','something2') \\\n            == False\ntest_67()\n\ndef test_70():\n    assert has_any_attrs(dict(),'keys','something') is True\ntest_70()\n\ndef test_71():\n    assert has_any_attrs(dict(),'values','something','__setstate__') is True\ntest_71()\n\ndef test_72():\n    assert not has_any_attrs(UserList(),'get','keys','items','values','something') is True\ntest_72()\n\ndef test_73():\n    assert not has_any_attrs(dict(),'nothing')\ntest_73()\n\ndef test_74():\n    assert has_any_attrs(\n        dict(),\n        'get', 'keys', 'items', 'values', 'something',\n    ) is True\ntest_74()\n\ndef test_78():\n    assert has_any_attrs(dict(),'something','somethingelse','get','values') is True\ntest_78()\n\ndef test_79():\n    assert not has_any_attrs(ValuesView(dict()), 'something')\ntest_79()\n\ndef test_80():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'something') is True\ntest_80()\n\ndef test_81():\n    assert has_any_attrs(dict(),'something','keys','items','values','something') is True\ntest_81()\n\ndef test_85():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something')\ntest_85()\n\ndef test_86():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values')\ntest_86()\n\ndef test_87():\n    assert has_any_attrs(object(),'get','keys','items','values') is False\ntest_87()\n\ndef test_88():\n    assert has_any_attrs(dict(),'get','keys','values','something') is True\ntest_88()\n\ndef test_89():\n    assert has_any_attrs(dict(),'get','items','values','something') is True\ntest_89()\n\ndef test_91():\n    assert has_any_attrs(dict(),'something') == False\ntest_91()\n\ndef test_92():\n    assert has_any_attrs(dict(),'get','keys','items','values','something')\ntest_92()\n\ndef test_93():\n    assert has_any_attrs(dict(), 'something', 'get') is True\ntest_93()\n\ndef test_94():\n    assert has_any_attrs(dict(), 'something', 'keys', 'items', 'values') is True\ntest_94()\n\ndef test_95():\n    assert has_any_attrs(dict(), 'something', 'somethingelse', 'other', 'otherelse') is False\ntest_95()\n\ndef test_96():\n    assert has_any_attrs(dict(),'something','get','keys') == True\ntest_96()\n\ndef test_98():\n    assert has_any_attrs(dict(),'something','get') == True\ntest_98()\n\ndef test_99():\n    assert has_any_attrs(dict(),'something','keys','items','values','nothing') is True\ntest_99()\n\ndef test_101():\n    assert not has_any_attrs(dict(), 'nothing')\ntest_101()\n\ndef test_103():\n    assert not has_any_attrs(dict(), 'some', 'other', 'attrs')\ntest_103()\n\ndef test_105():\n    assert has_any_attrs(dict(),'values','something') == True\ntest_105()\n\ndef test_106():\n    assert has_any_attrs(dict(get=lambda x:None),'get','keys','items','values')\ntest_106()\n\ndef test_107():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_107()\n\ndef test_108():\n    assert has_any_attrs(dict(),'values') is True\ntest_108()\n\ndef test_110():\n    assert has_any_attrs(dict(),'something') is False\ntest_110()\n\ndef test_112():\n    assert has_any_attrs(\n        deque(),'something1','something2', '__getitem__') \\\n            == True\ntest_112()\n\ndef test_114():\n    assert has_any_attrs(dict(),'items') is True\ntest_114()\n\ndef test_117():\n    assert has_any_attrs(dict(),'get','items','values') is True\ntest_117()\n\ndef test_118():\n    assert not has_any_attrs(ValuesView({'foo': 'bar'}),'get','keys','items','values','something') is True\ntest_118()\n\ndef test_119():\n    assert has_any_attrs(dict(),'keys') is True\ntest_119()\n\ndef test_121():\n    assert has_any_attrs(dict(),'something1','something2', '__getitem__') \\\n        == True\ntest_121()\n\ndef test_122():\n    assert has_any_attrs(dict(),'items','values','something') is True\ntest_122()\n\ndef test_124():\n    assert not has_any_attrs(dict(),'something')\ntest_124()\n\ndef test_126():\n    assert has_any_attrs(dict(a=1,b=2),'get','keys','items','values','something')\ntest_126()\n\ndef test_129():\n    assert has_any_attrs(dict(),'get') is True\ntest_129()\n\ndef test_130():\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') \\\n            is True\ntest_130()\n\ndef test_131():\n    assert not has_any_attrs(dict(),'something','somethingelse')\ntest_131()\n\ndef test_132():\n    assert has_any_attrs(dict(),'get', 'values') is True\ntest_132()\n\ndef test_134():\n    assert has_any_attrs(dict(),'something','somethingelse','items','values') is True\ntest_134()\n\ndef test_135():\n    assert has_any_attrs(int(10), 'get', 'keys', 'items', 'values', 'something') \\\n            is False\ntest_135()\n\ndef test_136():\n    assert has_any_attrs(dict(), 'something1', 'something2', 'something3') is False\ntest_136()\n\ndef test_138():\n    assert not has_any_attrs(dict())\ntest_138()\n\ndef test_139():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') \\\n        == True\ntest_139()\n\ndef test_140():\n    assert has_any_attrs(dict(),'get','keys','items','values','something') is True\ntest_140()\n\ndef test_141():\n    assert not has_any_attrs(UserList(), 'something')\ntest_141()\n\ndef test_143():\n    assert has_any_attrs(dict(),'items','values','something') == True\ntest_143()\n\ndef test_144():\n    assert has_any_attrs(dict(),'get','keys','items') is True\ntest_144()\n\ndef test_145():\n    assert has_any_attrs(dict(),'keys','items','values','something') is True\ntest_145()\n\ndef test_146():\n    assert has_any_attrs(dict(),'values','something') is True\ntest_146()\n\ndef test_147():\n    assert has_any_attrs(UserList(),'append','extend')\ntest_147()\n\ndef test_149():\n    assert has_any_attrs(dict(),'get','something') is True\ntest_149()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','items','something') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values', '__init__') == output\ntest_5()\n\ndef test_8():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_8\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','something') == output\ntest_8()\n\ndef test_14():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','values') == output\ntest_14()\n\ndef test_17():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_17\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'something1','something2', '__getitem__') == output\ntest_17()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n            {'get': 'something'}, 'get', 'keys', 'items', 'values'\n        ) == output\ntest_19()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_23()\n\ndef test_28():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_28()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items') == output\ntest_29()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        dict(),\n        '__getitem__', '__setitem__', '__delitem__', '__iter__', '__len__'\n    ) == output\ntest_32()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values','__getitem__') == output\ntest_33()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'keys', 'items', 'values') == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get') == output\ntest_37()\n\ndef test_40():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_40\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','items') == output\ntest_40()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        UserList(),'get','keys','items','values','something') == output\ntest_43()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'something','somethingelse','get','something') == output\ntest_47()\n\ndef test_50():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_50\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'something1','something2', '__getitem__') == output\ntest_50()\n\ndef test_59():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_59\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        ValuesView(dict()),'get','keys','items','values','something') == output\ntest_59()\n\ndef test_68():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_68\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','something') == output\ntest_68()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','values','something') == output\ntest_69()\n\ndef test_75():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_75\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_75()\n\ndef test_77():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_77\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','values') == output\ntest_77()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'items','values') == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        deque(),'get','keys','items','values','something') == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(\n        KeysView(dict()),'get','keys','items','values','something') == output\ntest_84()\n\ndef test_90():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_90\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_90()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','items','something') == output\ntest_100()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'something') == output\ntest_102()\n\ndef test_104():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_104\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict(a=1,b=2)), 'something') == output\ntest_104()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_109()\n\ndef test_111():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_111\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(KeysView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_111()\n\ndef test_115():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_115\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys') == output\ntest_115()\n\ndef test_120():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_120\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get') == output\ntest_120()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'get','keys','something') == output\ntest_123()\n\ndef test_125():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_125\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'nothing','items','values','something') == output\ntest_125()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict()), 'get', 'keys', 'items', 'values', 'something') == output\ntest_127()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(), 'get', 'keys', 'items', 'values', '__slots__') == output\ntest_133()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(ValuesView(dict(a=1,b=2)), 'get', 'keys', 'items', 'values', 'something') == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(dict(),'keys','something') == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_attrs/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_attrs(UserList(range(5)), 'something') == output\ntest_148()\n\n\n"]}
{"task_id": 143, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False", "from typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False", "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        # First, check if the object has the attribute\n        if hasattr(obj, attr):\n            # If it has the attribute, get it\n            attribute = getattr(obj, attr)\n            # Then, check if the retrieved attribute is callable\n            if callable(attribute):\n                return True\n    return False", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr in attrs:\n        # First, check if the object has the attribute\n        if hasattr(obj, attr):\n            # If it has the attribute, get it\n            attribute = getattr(obj, attr)\n            # Then, check if the retrieved attribute is callable\n            if callable(attribute):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n    for attr_name in attrs:\n        if hasattr(obj, attr_name):\n            attr_value = getattr(obj, attr_name)\n            if callable(attr_value):\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert has_any_callables(list(),'__contains__') is True\ntest_0()\n\ndef test_3():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','__getitem__') is True\ntest_3()\n\ndef test_4():\n    assert has_any_callables(list(),'append','extend','insert') is True\ntest_4()\n\ndef test_7():\n    assert has_any_callables(list(),'append','pop','reverse','clear') is True\ntest_7()\n\ndef test_8():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append') is True\ntest_8()\n\ndef test_9():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__','__delitem__') is True\ntest_9()\n\ndef test_12():\n    assert has_any_callables(dict(),'foo','bar','baz','something') is False\ntest_12()\n\ndef test_14():\n    assert has_any_callables(dict(),'get','keys','items','values','foo','bar') is True\ntest_14()\n\ndef test_19():\n    assert has_any_callables(dict(),'foo','something') is False\ntest_19()\n\ndef test_20():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something') is False\ntest_20()\n\ndef test_22():\n    assert has_any_callables(dict(),'get','keys','items','values')\ntest_22()\n\ndef test_24():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop') is True\ntest_24()\n\ndef test_25():\n    assert has_any_callables(dict(),'items') is True\ntest_25()\n\ndef test_27():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') is True\ntest_27()\n\ndef test_28():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar') is True\ntest_28()\n\ndef test_30():\n    assert has_any_callables(dict(),'keys') is True\ntest_30()\n\ndef test_34():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__delitem__') is True\ntest_34()\n\ndef test_37():\n    assert has_any_callables(list(),'foo','bar','baz') is False\ntest_37()\n\ndef test_38():\n    assert has_any_callables(dict(),'get','keys','items','values','foo')\ntest_38()\n\ndef test_41():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__') is True\ntest_41()\n\ndef test_44():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == True\ntest_44()\n\ndef test_45():\n    assert has_any_callables(list(),'append','extend','insert','pop','remove','reverse','sort') is True\ntest_45()\n\ndef test_47():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') is True\ntest_47()\n\ndef test_48():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_48()\n\ndef test_49():\n    assert has_any_callables(dict(),'something') is False\ntest_49()\n\ndef test_50():\n    assert has_any_callables(dict(),'foo','bar','baz','fizz','buzz') is False\ntest_50()\n\ndef test_51():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') is True\ntest_51()\n\ndef test_55():\n    assert has_any_callables(deque(), '__iter__', 'append', 'appendleft', 'clear', 'pop') == True\ntest_55()\n\ndef test_56():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__') is True\ntest_56()\n\ndef test_57():\n    assert has_any_callables(dict(),'get','keys','foo') is True\ntest_57()\n\ndef test_61():\n    assert has_any_callables(dict(),'foo', 'bar') is False\ntest_61()\n\ndef test_62():\n    assert has_any_callables(dict(),'get','keys','items','values') is True\ntest_62()\n\ndef test_63():\n    assert has_any_callables(list(),'append','extend','insert','pop') is True\ntest_63()\n\ndef test_66():\n    assert has_any_callables(deque(), 'append', 'appendleft', 'clear') is True\ntest_66()\n\ndef test_67():\n    assert has_any_callables(list(),'pop','popitem') is True\ntest_67()\n\ndef test_68():\n    assert has_any_callables(list(),'__getitem__','__setitem__','__delitem__')\ntest_68()\n\ndef test_71():\n    assert has_any_callables(list(),'append','extend','insert','foo') is True\ntest_71()\n\ndef test_72():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') is True\ntest_72()\n\ndef test_73():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'get',\n            'foo',\n    ) is True\ntest_73()\n\ndef test_75():\n    assert has_any_callables(dict(),'keys','items','values','foo','bar',\n                              'baz') is True\ntest_75()\n\ndef test_76():\n    assert has_any_callables(deque(), 'append', 'clear') is True\ntest_76()\n\ndef test_77():\n    assert has_any_callables(dict(),'get','keys','items','values','pop') is True\ntest_77()\n\ndef test_78():\n    assert has_any_callables(dict(),'bar') is False\ntest_78()\n\ndef test_80():\n    assert has_any_callables(dict(),'keys','items') is True\ntest_80()\n\ndef test_82():\n    assert has_any_callables(deque(),'append','appendleft','clear') is True\ntest_82()\n\ndef test_86():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') is True\ntest_86()\n\ndef test_89():\n    assert has_any_callables(\n            dict(),\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_89()\n\ndef test_90():\n    assert has_any_callables(dict(),'get','keys','items','values','__getitem__','bar') is True\ntest_90()\n\ndef test_92():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','foo') is True\ntest_92()\n\ndef test_95():\n    assert has_any_callables(deque(),'foo','bar','baz') is False\ntest_95()\n\ndef test_96():\n    assert has_any_callables(set(),'add','clear','copy','difference','difference_update','discard','intersection','intersection_update','isdisjoint','issubset','issuperset','pop','remove','symmetric_difference','symmetric_difference_update','union') is True\ntest_96()\n\ndef test_97():\n    assert has_any_callables(dict(),'__contains__') is True\ntest_97()\n\ndef test_103():\n    assert has_any_callables(dict(),'get','foo') is True\ntest_103()\n\ndef test_104():\n    assert has_any_callables(dict(),'keys','items','values') is True\ntest_104()\n\ndef test_111():\n    assert has_any_callables(dict(),'foo','bar','baz') is False\ntest_111()\n\ndef test_112():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse') is True\ntest_112()\n\ndef test_113():\n    assert has_any_callables(dict(),'get','keys','items','values','__getattr__','__getitem__') is True\ntest_113()\n\ndef test_114():\n    assert not has_any_callables(\n        dict(),\n        'foo',\n        'bar',\n        'spam',\n        'baz',\n    )\ntest_114()\n\ndef test_115():\n    assert has_any_callables(dict(),'get','keys','items','values') == True\ntest_115()\n\ndef test_116():\n    assert not has_any_callables(dict(),'foo','bar','baz','qux','quux')\ntest_116()\n\ndef test_117():\n    assert has_any_callables(dict(),'something','somethingelse') is False\ntest_117()\n\ndef test_118():\n    assert has_any_callables(list(),'foo','bar','something','else') is False\ntest_118()\n\ndef test_119():\n    assert has_any_callables(UserList(),'append','clear','copy','extend','insert','pop','remove','reverse','sort') is True\ntest_119()\n\ndef test_120():\n    assert has_any_callables(dict(),'foo','bar','baz','qux','something') is False\ntest_120()\n\ndef test_121():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo')\ntest_121()\n\ndef test_122():\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__') is True\ntest_122()\n\ndef test_125():\n    assert has_any_callables(dict(),'foo','bar','baz','foo') is False\ntest_125()\n\ndef test_126():\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') is True\ntest_126()\n\ndef test_127():\n    assert has_any_callables(dict(),'get') is True\ntest_127()\n\ndef test_129():\n    assert has_any_callables(dict(), 'foo', 'bar', 'something') is False\ntest_129()\n\ndef test_130():\n    assert has_any_callables(deque(), '__reversed__', 'pop') == True\ntest_130()\n\ndef test_131():\n    assert has_any_callables(dict(),'pop','popitem') is True\ntest_131()\n\ndef test_132():\n    assert has_any_callables(dict(),'foo','bar','__getattr__') is False\ntest_132()\n\ndef test_134():\n    assert has_any_callables(dict(),'get','keys','items','values','foo') is True\ntest_134()\n\ndef test_135():\n    assert has_any_callables(deque(), 'foo') is False\ntest_135()\n\ndef test_136():\n    assert has_any_callables(\n            {'get': lambda x: None},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) is True\ntest_136()\n\ndef test_137():\n    assert has_any_callables(dict(),'baz') is False\ntest_137()\n\ndef test_140():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz', 'something', 'else') is False\ntest_140()\n\ndef test_142():\n    assert has_any_callables(deque(),'append','appendleft','clear','foo') is True\ntest_142()\n\ndef test_143():\n    assert has_any_callables(dict(), 'foo', 'bar', 'baz') is False\ntest_143()\n\ndef test_146():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') is True\ntest_146()\n\ndef test_147():\n    assert has_any_callables(tuple(),'__getitem__','__len__')\ntest_147()\n\ndef test_149():\n    assert has_any_callables(dict(),'foo','bar','baz','qaz') is False\ntest_149()\n\ndef test_150():\n    assert has_any_callables(deque(), 'append', 'clear', 'foo') is True\ntest_150()\n\ndef test_151():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__',\n            '__setitem__',\n            '__delitem__',\n        )\ntest_151()\n\ndef test_153():\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'pop') is True\ntest_153()\n\ndef test_155():\n    assert has_any_callables(dict(),'get','keys','items') is True\ntest_155()\n\ndef test_156():\n    assert has_any_callables(deque(),'append','appendleft','clear','copy','count') is True\ntest_156()\n\ndef test_157():\n    assert has_any_callables(dict(),'get','keys') is True\ntest_157()\n\ndef test_159():\n    assert has_any_callables(dict(),'get','keys','items','__iter__') is True\ntest_159()\n\ndef test_160():\n    assert has_any_callables(dict()) is False\ntest_160()\n\ndef test_161():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'something'\n    ) is True\ntest_161()\n\ndef test_162():\n    assert has_any_callables(list(),'append','clear','extend','insert','pop','remove','reverse','__setitem__') is True\ntest_162()\n\ndef test_164():\n    assert has_any_callables(dict(),'foo','bar','baz','barf','quux') is False\ntest_164()\n\ndef test_165():\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__getitem__'\n        )\ntest_165()\n\ndef test_166():\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo') == True\ntest_166()\n\ndef test_167():\n    assert has_any_callables(dict(),'foo') is False\ntest_167()\n\ndef test_169():\n    assert has_any_callables(dict(),'foo','bar','something') is False\ntest_169()\n\ndef test_170():\n    assert has_any_callables(dict(),'get','keys','items','values','something') is True\ntest_170()\n\ndef test_171():\n    assert has_any_callables(dict(),'foo','bar') is False\ntest_171()\n\ndef test_172():\n    assert has_any_callables(dict(),) is False\ntest_172()\n\ndef test_173():\n    assert has_any_callables(dict(), '__len__', '__iter__', 'keys') == True\ntest_173()\n\ndef test_174():\n    assert has_any_callables(dict(), 'bar', 'foo', 'foo', 'foo') is False\ntest_174()\n\ndef test_175():\n    assert has_any_callables(dict(),'values') is True\ntest_175()\n\ndef test_176():\n    assert has_any_callables(\n        dict(),\n        'get',\n        'keys',\n        'items',\n        'values',\n        'foo'\n    )\ntest_176()\n\ndef test_177():\n    assert has_any_callables(dict(),'something','other','foo') is False\ntest_177()\n\ndef test_178():\n    assert has_any_callables(dict(),'keys','items','values','foo') is True\ntest_178()\n\ndef test_179():\n    assert has_any_callables(dict(),'foo','bar','something','else') is False\ntest_179()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'bar') == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo', 'bar') == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__', '__iter__') == output\ntest_6()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values') == output\ntest_13()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','items','values','foo') == output\ntest_15()\n\ndef test_16():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_16\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', '__len__') == output\ntest_16()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), 'append', 'foo') == output\ntest_23()\n\ndef test_26():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_26\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get') == output\ntest_26()\n\ndef test_29():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_29\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'something') == output\ntest_29()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'foo', 'bar') == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','foo') == output\ntest_36()\n\ndef test_43():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_43\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values') == output\ntest_43()\n\ndef test_46():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_46\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values') == output\ntest_46()\n\ndef test_58():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_58\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__len__', '__iter__', '__next__') == output\ntest_58()\n\ndef test_60():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_60\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','foo') == output\ntest_60()\n\ndef test_65():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_65\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'foo',\n    ) == output\ntest_65()\n\ndef test_69():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_69\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'bar', 'foo', 'foo') == output\ntest_69()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'foo', 'bar') == output\ntest_70()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n        [1,2,3], '__len__', '__getitem__', '__setitem__', '__delitem__', 'append', 'pop', 'get') == output\ntest_81()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','foo','bar') == output\ntest_83()\n\ndef test_88():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_88\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys') == output\ntest_88()\n\ndef test_94():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_94\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'values', 'foo', 'bar', 'foo') == output\ntest_94()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','__dict__') == output\ntest_98()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo', 'bar') == output\ntest_101()\n\ndef test_102():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_102\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            dict(),\n            'get',\n            'keys',\n            'items',\n            'values',\n            'something',\n            '__setitem__',\n            '__delitem__',\n        ) == output\ntest_102()\n\ndef test_106():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_106\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'foo','bar','baz') == output\ntest_106()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__len__', '__iter__', '__next__') == output\ntest_107()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'foo') == output\ntest_108()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'get',\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_109()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'foo', 'values', 'bar') == output\ntest_123()\n\ndef test_133():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_133\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items') == output\ntest_133()\n\ndef test_138():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_138\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(\n            {'get': 1},\n            'keys',\n            'items',\n            'values',\n            'foo',\n    ) == output\ntest_138()\n\ndef test_139():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_139\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','values','foo') == output\ntest_139()\n\ndef test_144():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_144\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values') == output\ntest_144()\n\ndef test_145():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_145\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'keys','items','values','foo') == output\ntest_145()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), '__contains__', 'get') == output\ntest_148()\n\ndef test_152():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_152\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(),'get','keys','items','values','bar') == output\ntest_152()\n\ndef test_154():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_154\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'foo', 'values') == output\ntest_154()\n\ndef test_163():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_163\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(dict(), 'get', 'keys', 'items', 'values', 'bar') == output\ntest_163()\n\ndef test_168():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/has_any_callables/test_168\", \"rb\") as f:\n        output = pickle.load(f)\n    assert has_any_callables(deque(), '__contains__', 'index') == output\ntest_168()\n\n\n"]}
{"task_id": 144, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # The _LIST_LIKE tuple is already defined in the module's scope\n    # (as seen in the File Content). This tuple contains all the types\n    # that are considered \"list-like\" according to the docstring.\n    # We use isinstance() to check if the object is an instance of any\n    # of the types specified in the _LIST_LIKE tuple. This correctly\n    # covers both the inclusions and exclusions mentioned in the docstring.\n    return isinstance(obj, _LIST_LIKE)", "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    return isinstance(obj, _LIST_LIKE)", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n# _LIST_LIKE is defined in the module's scope as per the File Content.\n# It is directly accessible.\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n# is_subclass_of_any is a context function and assumed to be available\n# within the same module's scope.\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Leverage the _LIST_LIKE tuple which explicitly defines list-like types\n    # and the is_subclass_of_any function to perform the type check efficiently.\n    return is_subclass_of_any(obj, *_LIST_LIKE)", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\n# noinspection PyUnresolvedReferences\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Handle explicit exclusions first, as defined in the docstring.\n    # Order matters for bool and int/float, so bool is checked explicitly.\n    if obj is None or isinstance(obj, (bool, bytes, str, dict, int, float)):\n        return False\n\n    # If not explicitly excluded, check if its class is a subclass of any\n    # of the types defined in _LIST_LIKE using the helper function.\n    return is_subclass_of_any(obj, *_LIST_LIKE)", "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # According to the docstring, certain types are explicitly NOT list-like,\n    # even if they might be iterable (like strings or dictionaries).\n    # We check for these explicit exclusions first.\n    if isinstance(obj, (type(None), bool, bytes, dict, float, int, str)):\n        return False\n\n    # The file content already defines a tuple `_LIST_LIKE` which contains\n    # all the types considered to be 'list-like'. We can directly use\n    # isinstance with this tuple for efficient type checking.\n    # The types included in _LIST_LIKE are:\n    # list, set, frozenset, tuple, deque, Iterator, ValuesView, KeysView, UserList.\n    return isinstance(obj, _LIST_LIKE)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # The _LIST_LIKE tuple is already defined in the module's scope\n    # (as seen in the File Content). This tuple contains all the types\n    # that are considered \"list-like\" according to the docstring.\n    # We use isinstance() to check if the object is an instance of any\n    # of the types specified in the _LIST_LIKE tuple. This correctly\n    # covers both the inclusions and exclusions mentioned in the docstring.\n    return isinstance(obj, _LIST_LIKE)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    return isinstance(obj, _LIST_LIKE)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n# _LIST_LIKE is defined in the module's scope as per the File Content.\n# It is directly accessible.\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n# is_subclass_of_any is a context function and assumed to be available\n# within the same module's scope.\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Leverage the _LIST_LIKE tuple which explicitly defines list-like types\n    # and the is_subclass_of_any function to perform the type check efficiently.\n    return is_subclass_of_any(obj, *_LIST_LIKE)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\n# noinspection PyUnresolvedReferences\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # Handle explicit exclusions first, as defined in the docstring.\n    # Order matters for bool and int/float, so bool is checked explicitly.\n    if obj is None or isinstance(obj, (bool, bytes, str, dict, int, float)):\n        return False\n\n    # If not explicitly excluded, check if its class is a subclass of any\n    # of the types defined in _LIST_LIKE using the helper function.\n    return is_subclass_of_any(obj, *_LIST_LIKE)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n    # According to the docstring, certain types are explicitly NOT list-like,\n    # even if they might be iterable (like strings or dictionaries).\n    # We check for these explicit exclusions first.\n    if isinstance(obj, (type(None), bool, bytes, dict, float, int, str)):\n        return False\n\n    # The file content already defines a tuple `_LIST_LIKE` which contains\n    # all the types considered to be 'list-like'. We can directly use\n    # isinstance with this tuple for efficient type checking.\n    # The types included in _LIST_LIKE are:\n    # list, set, frozenset, tuple, deque, Iterator, ValuesView, KeysView, UserList.\n    return isinstance(obj, _LIST_LIKE)\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_0():\n    assert is_list_like(range(0)) == False\ntest_0()\n\ndef test_1():\n    assert not is_list_like( dict() )\ntest_1()\n\ndef test_2():\n    assert not is_list_like(dict([(1,2),(2,3),(3,4)]))\ntest_2()\n\ndef test_4():\n    assert is_list_like(range(10)) == False\ntest_4()\n\ndef test_5():\n    assert is_list_like([]) == True\ntest_5()\n\ndef test_6():\n    assert not is_list_like(memoryview(b'hello'))\ntest_6()\n\ndef test_7():\n    assert not is_list_like({'a': 1, 'b': 2, 'c': 3})\ntest_7()\n\ndef test_8():\n    assert not is_list_like(bytes())\ntest_8()\n\ndef test_9():\n    assert is_list_like(UserList())\ntest_9()\n\ndef test_13():\n    assert is_list_like( ValuesView(dict(a=1, b=2, c=3)) ) is True\ntest_13()\n\ndef test_14():\n    assert is_list_like(b''.join([b'hello', b'world'])) == False\ntest_14()\n\ndef test_16():\n    assert is_list_like(iter({1, 2, 3}))\ntest_16()\n\ndef test_17():\n    assert not is_list_like(int())\ntest_17()\n\ndef test_18():\n    assert is_list_like(KeysView(dict(a=1,b=2)))\ntest_18()\n\ndef test_19():\n    assert is_list_like(set({1, 2, 3}))\ntest_19()\n\ndef test_21():\n    assert is_list_like(  deque([1, 2, 3])    )\ntest_21()\n\ndef test_22():\n    assert is_list_like(deque('hello'))\ntest_22()\n\ndef test_23():\n    assert not is_list_like({1: 1, 2: 2})\ntest_23()\n\ndef test_24():\n    assert is_list_like(KeysView({}))\ntest_24()\n\ndef test_25():\n    assert is_list_like( deque([1, 2, 3]) ) is True\ntest_25()\n\ndef test_26():\n    assert is_list_like(list()) is True\ntest_26()\n\ndef test_28():\n    assert is_list_like(deque(range(5))) is True\ntest_28()\n\ndef test_30():\n    assert is_list_like( set([1, 2, 3]) ) is True\ntest_30()\n\ndef test_31():\n    assert is_list_like(set()) is True\ntest_31()\n\ndef test_33():\n    assert is_list_like(KeysView(dict(a=1, b=2, c=3)))\ntest_33()\n\ndef test_34():\n    assert is_list_like(float()) == False\ntest_34()\n\ndef test_35():\n    assert is_list_like(  [1, 2, 3]           )\ntest_35()\n\ndef test_38():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.values())\ntest_38()\n\ndef test_39():\n    assert is_list_like(  reversed([1, 2, 4]) )\ntest_39()\n\ndef test_40():\n    assert not is_list_like(dict(a=1, b=2, c=3).keys)\ntest_40()\n\ndef test_41():\n    assert is_list_like(['a', 'b', 'c']) is True\ntest_41()\n\ndef test_43():\n    assert is_list_like(bytes()) is False\ntest_43()\n\ndef test_45():\n    assert not is_list_like(1+0j)\ntest_45()\n\ndef test_46():\n    assert is_list_like(KeysView(dict())) is True\ntest_46()\n\ndef test_48():\n    assert not is_list_like(  None              )\ntest_48()\n\ndef test_49():\n    assert is_list_like(('hello', 'world'))\ntest_49()\n\ndef test_50():\n    assert not is_list_like( 1.0 )\ntest_50()\n\ndef test_52():\n    assert not is_list_like( True )\ntest_52()\n\ndef test_54():\n    assert is_list_like(bytes) is False\ntest_54()\n\ndef test_55():\n    assert is_list_like(reversed([])) == True\ntest_55()\n\ndef test_56():\n    assert is_list_like(list([1, 2]))\ntest_56()\n\ndef test_58():\n    assert is_list_like(reversed([1, 2, 3]))\ntest_58()\n\ndef test_59():\n    assert is_list_like(ValuesView([1, 2]))\ntest_59()\n\ndef test_60():\n    assert is_list_like(ValuesView(dict(a=1, b=2, c=3)))\ntest_60()\n\ndef test_62():\n    assert is_list_like(  sorted('hello')     )\ntest_62()\n\ndef test_63():\n    assert is_list_like(str('hello')) is False\ntest_63()\n\ndef test_65():\n    assert is_list_like(deque([1, 2, 4]))\ntest_65()\n\ndef test_66():\n    assert is_list_like( iter([1, 2, 3]) ) is True\ntest_66()\n\ndef test_67():\n    assert is_list_like(1) == False\ntest_67()\n\ndef test_69():\n    assert is_list_like(iter([1,2,3,4]))\ntest_69()\n\ndef test_70():\n    assert is_list_like(deque(['a', 'b', 'c'])) is True\ntest_70()\n\ndef test_71():\n    assert not is_list_like(str('hello'))\ntest_71()\n\ndef test_74():\n    assert not is_list_like(b'hello')\ntest_74()\n\ndef test_75():\n    assert is_list_like(iter(dict().values()))\ntest_75()\n\ndef test_76():\n    assert not is_list_like(int(123))\ntest_76()\n\ndef test_77():\n    assert is_list_like({1: 1, 2: 2, 3: 3}.keys())\ntest_77()\n\ndef test_78():\n    assert is_list_like(frozenset([1, 2]))\ntest_78()\n\ndef test_81():\n    assert is_list_like(sorted('hello')) is True\ntest_81()\n\ndef test_82():\n    assert is_list_like(tuple([1,2,3]))\ntest_82()\n\ndef test_87():\n    assert is_list_like([1, 2, 3]) is True\ntest_87()\n\ndef test_88():\n    assert not is_list_like('')\ntest_88()\n\ndef test_89():\n    assert not is_list_like( {} )\ntest_89()\n\ndef test_90():\n    assert not is_list_like(  True              )\ntest_90()\n\ndef test_91():\n    assert not is_list_like(  1.0              )\ntest_91()\n\ndef test_92():\n    assert is_list_like(dict(a=1, b=2, c=3).keys())\ntest_92()\n\ndef test_93():\n    assert is_list_like(sorted('hello'))\ntest_93()\n\ndef test_94():\n    assert not is_list_like(str())\ntest_94()\n\ndef test_97():\n    assert not is_list_like(False)\ntest_97()\n\ndef test_99():\n    assert is_list_like(range(0, 10)) == False\ntest_99()\n\ndef test_100():\n    assert is_list_like(dict(a=1, b=2, c=3).values())\ntest_100()\n\ndef test_101():\n    assert is_list_like(tuple(['a', 'b', 'c'])) is True\ntest_101()\n\ndef test_102():\n    assert not is_list_like( {1: 1} )\ntest_102()\n\ndef test_103():\n    assert is_list_like(tuple(['a', 'b']))\ntest_103()\n\ndef test_104():\n    assert is_list_like(frozenset(range(5))) is True\ntest_104()\n\ndef test_105():\n    assert not is_list_like(float(2.3))\ntest_105()\n\ndef test_106():\n    assert is_list_like( None ) is False\ntest_106()\n\ndef test_107():\n    assert is_list_like(frozenset([1,2,3]))\ntest_107()\n\ndef test_109():\n    assert not is_list_like('abc')\ntest_109()\n\ndef test_110():\n    assert is_list_like(list([1, 2, 3]))\ntest_110()\n\ndef test_111():\n    assert is_list_like( 42 ) is False\ntest_111()\n\ndef test_112():\n    assert is_list_like(set(range(5))) is True\ntest_112()\n\ndef test_114():\n    assert is_list_like( True ) is False\ntest_114()\n\ndef test_115():\n    assert not is_list_like(  False             )\ntest_115()\n\ndef test_117():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.items()\n    )\ntest_117()\n\ndef test_118():\n    assert not is_list_like(dict(a=1, b=2))\ntest_118()\n\ndef test_120():\n    assert is_list_like( sorted('hello'))\ntest_120()\n\ndef test_121():\n    assert is_list_like(UserList()) == True\ntest_121()\n\ndef test_122():\n    assert not is_list_like({key: key for key in range(10)}.items())\ntest_122()\n\ndef test_123():\n    assert is_list_like(set(['a', 'b', 'c'])) is True\ntest_123()\n\ndef test_124():\n    assert is_list_like(UserList((1,2,3)))\ntest_124()\n\ndef test_125():\n    assert is_list_like(reversed([1,2,4])) == True\ntest_125()\n\ndef test_129():\n    assert is_list_like(deque(['a', 'b']))\ntest_129()\n\ndef test_130():\n    assert is_list_like(reversed(['hello', 'world']))\ntest_130()\n\ndef test_131():\n    assert is_list_like(UserList()) is True\ntest_131()\n\ndef test_133():\n    assert is_list_like(str) is False\ntest_133()\n\ndef test_134():\n    assert is_list_like( list([1, 2, 3]) ) is True\ntest_134()\n\ndef test_138():\n    assert is_list_like(UserList([1,2,3]))\ntest_138()\n\ndef test_140():\n    assert is_list_like(list(range(5))) is True\ntest_140()\n\ndef test_141():\n    assert is_list_like({1,2,3})\ntest_141()\n\ndef test_143():\n    assert is_list_like( bytearray(b'hello') ) is False\ntest_143()\n\ndef test_145():\n    assert is_list_like(KeysView(dict(a=1, b=2)))\ntest_145()\n\ndef test_146():\n    assert is_list_like(deque([1,2,3]))\ntest_146()\n\ndef test_147():\n    assert not is_list_like(bool())\ntest_147()\n\ndef test_149():\n    assert not is_list_like(123)\ntest_149()\n\ndef test_151():\n    assert is_list_like(KeysView(dict([(1,2),(2,3),(3,4)])))\ntest_151()\n\ndef test_152():\n    assert not is_list_like(  float(1)          )\ntest_152()\n\ndef test_153():\n    assert is_list_like(set()) == True\ntest_153()\n\ndef test_154():\n    assert is_list_like(int()) == False\ntest_154()\n\ndef test_155():\n    assert is_list_like( reversed( [1, 2, 3] ) ) is True\ntest_155()\n\ndef test_156():\n    assert is_list_like(ValuesView(dict(a=1, b=2)))\ntest_156()\n\ndef test_157():\n    assert is_list_like(str()) == False\ntest_157()\n\ndef test_159():\n    assert ~is_list_like(   'hello')\ntest_159()\n\ndef test_160():\n    assert is_list_like(set())\ntest_160()\n\ndef test_161():\n    assert not is_list_like(1j)\ntest_161()\n\ndef test_163():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.keys())\ntest_163()\n\ndef test_164():\n    assert not is_list_like(1.0)\ntest_164()\n\ndef test_165():\n    assert not is_list_like(None)\ntest_165()\n\ndef test_166():\n    assert is_list_like(frozenset()) is True\ntest_166()\n\ndef test_167():\n    assert is_list_like(dict(a=1, b=2)) is False\ntest_167()\n\ndef test_168():\n    assert is_list_like(tuple(range(5))) is True\ntest_168()\n\ndef test_169():\n    assert not is_list_like(dict(a=1, b=2, c=3))\ntest_169()\n\ndef test_170():\n    assert is_list_like(deque([1, 2, 3]))\ntest_170()\n\ndef test_171():\n    assert is_list_like(tuple((1,2,3)))\ntest_171()\n\ndef test_172():\n    assert is_list_like(ValuesView(dict([(1,2),(2,3),(3,4)])))\ntest_172()\n\ndef test_173():\n    assert is_list_like([])\ntest_173()\n\ndef test_174():\n    assert is_list_like(dict().keys())\ntest_174()\n\ndef test_175():\n    assert is_list_like(tuple()) is True\ntest_175()\n\ndef test_176():\n    assert not is_list_like(dict(a=1, b=2, c=3).items)\ntest_176()\n\ndef test_177():\n    assert is_list_like([]) is True\ntest_177()\n\ndef test_178():\n    assert is_list_like([1,2,3]) == True\ntest_178()\n\ndef test_179():\n    assert is_list_like(UserList([1, 2, 3]))\ntest_179()\n\ndef test_180():\n    assert is_list_like(deque()) == True\ntest_180()\n\ndef test_181():\n    assert is_list_like(tuple([1, 2]))\ntest_181()\n\ndef test_182():\n    assert not is_list_like(bytes('hello', 'utf-8'))\ntest_182()\n\ndef test_183():\n    assert is_list_like(sorted([])) == True\ntest_183()\n\ndef test_186():\n    assert not is_list_like(1+1j)\ntest_186()\n\ndef test_187():\n    assert not is_list_like({'a':1, 'b':2, 'c':3}.items())\ntest_187()\n\ndef test_188():\n    assert is_list_like(deque())\ntest_188()\n\ndef test_190():\n    assert is_list_like(reversed([1, 2, 4])) is True\ntest_190()\n\ndef test_191():\n    assert is_list_like([1, 2, 3]) == True\ntest_191()\n\ndef test_193():\n    assert is_list_like( sorted('hello') )\ntest_193()\n\ndef test_194():\n    assert not is_list_like(dict(a=1,b=2))\ntest_194()\n\ndef test_195():\n    assert is_list_like(iter(dict().keys()))\ntest_195()\n\ndef test_196():\n    assert is_list_like(set(['a', 'b']))\ntest_196()\n\ndef test_197():\n    assert is_list_like( KeysView(dict(a=1, b=2, c=3)) ) is True\ntest_197()\n\ndef test_198():\n    assert is_list_like((1, 2, 3)) is True\ntest_198()\n\ndef test_200():\n    assert is_list_like(frozenset([1, 2, 4]))\ntest_200()\n\ndef test_201():\n    assert is_list_like(frozenset([1, 2, 3]))\ntest_201()\n\ndef test_202():\n    assert not is_list_like( False )\ntest_202()\n\ndef test_203():\n    assert is_list_like(frozenset()) == True\ntest_203()\n\ndef test_204():\n    assert is_list_like( UserList( [1, 2, 3] ) ) is True\ntest_204()\n\ndef test_205():\n    assert is_list_like(deque([1, 2, 3, 4, 5]))\ntest_205()\n\ndef test_208():\n    assert not is_list_like(complex(123.0))\ntest_208()\n\ndef test_209():\n    assert is_list_like(100) is False\ntest_209()\n\ndef test_211():\n    assert not is_list_like( 'hello' )\ntest_211()\n\ndef test_212():\n    assert is_list_like(  (1, 2, 3)           )\ntest_212()\n\ndef test_213():\n    assert is_list_like(dict(a=1, b=2)) == False\ntest_213()\n\ndef test_214():\n    assert is_list_like(iter('abcd')) is True\ntest_214()\n\ndef test_215():\n    assert is_list_like(deque((1,2,3)))\ntest_215()\n\ndef test_216():\n    assert is_list_like(KeysView({'a':1}))\ntest_216()\n\ndef test_217():\n    assert is_list_like(set(range(10)))\ntest_217()\n\ndef test_218():\n    assert is_list_like(tuple())\ntest_218()\n\ndef test_219():\n    assert not is_list_like(memoryview(b''))\ntest_219()\n\ndef test_221():\n    assert is_list_like('') == False\ntest_221()\n\ndef test_224():\n    assert is_list_like(reversed([1, 2, 4])) == True\ntest_224()\n\ndef test_225():\n    assert is_list_like(Iterator) is False\ntest_225()\n\ndef test_226():\n    assert not is_list_like(  dict(a=1, b=2)    )\ntest_226()\n\ndef test_227():\n    assert not is_list_like(1)\ntest_227()\n\ndef test_229():\n    assert is_list_like( [1, 2, 3] )\ntest_229()\n\ndef test_230():\n    assert not is_list_like(dict(a=1,b=2,c=3))\ntest_230()\n\ndef test_231():\n    assert not is_list_like('hello'.encode())\ntest_231()\n\ndef test_233():\n    assert is_list_like(set('aabbcc')) == True\ntest_233()\n\ndef test_234():\n    assert not is_list_like({})\ntest_234()\n\ndef test_236():\n    assert is_list_like( frozenset([1, 2, 3]) ) is True\ntest_236()\n\ndef test_237():\n    assert not is_list_like( 1 )\ntest_237()\n\ndef test_238():\n    assert is_list_like( [1, 2, 3])\ntest_238()\n\ndef test_241():\n    assert is_list_like(reversed('abcd')) is True\ntest_241()\n\ndef test_243():\n    assert is_list_like(  set([1, 2, 3])      )\ntest_243()\n\ndef test_245():\n    assert is_list_like(dict()) == False\ntest_245()\n\ndef test_247():\n    assert is_list_like(set((1,2,3)))\ntest_247()\n\ndef test_249():\n    assert is_list_like(KeysView(dict(a=1, b=2))) == True\ntest_249()\n\ndef test_250():\n    assert is_list_like(deque([]))\ntest_250()\n\ndef test_251():\n    assert is_list_like(  frozenset([1, 2, 3]))\ntest_251()\n\ndef test_252():\n    assert is_list_like(ValuesView({}))\ntest_252()\n\ndef test_255():\n    assert not is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}\n    )\ntest_255()\n\ndef test_256():\n    assert is_list_like(tuple()) == True\ntest_256()\n\ndef test_258():\n    assert not is_list_like(b'')\ntest_258()\n\ndef test_261():\n    assert is_list_like([1,2,3])\ntest_261()\n\ndef test_264():\n    assert is_list_like(frozenset())\ntest_264()\n\ndef test_265():\n    assert is_list_like(sorted('abcd')) is True\ntest_265()\n\ndef test_268():\n    assert is_list_like(list(set([1, 2, 3, 4, 5])))\ntest_268()\n\ndef test_269():\n    assert is_list_like(dict(a=1, b=2, c=3).values()) is True\ntest_269()\n\ndef test_270():\n    assert is_list_like(ValuesView({1: 'one', 2: 'two', 3: 'three'}))\ntest_270()\n\ndef test_271():\n    assert not is_list_like(bytes(b'hello'))\ntest_271()\n\ndef test_273():\n    assert is_list_like(tuple(reversed([1, 2, 4])))\ntest_273()\n\ndef test_276():\n    assert not is_list_like(456.789)\ntest_276()\n\ndef test_277():\n    assert is_list_like( [1, 2, 3]  ) is True\ntest_277()\n\ndef test_278():\n    assert is_list_like(list(reversed([1, 2, 4])))\ntest_278()\n\ndef test_279():\n    assert is_list_like(1.0) == False\ntest_279()\n\ndef test_280():\n    assert is_list_like(bytearray()) is False\ntest_280()\n\ndef test_282():\n    assert is_list_like(iter((1,2,3)))\ntest_282()\n\ndef test_283():\n    assert is_list_like(KeysView(dict(a=1,b=2,c=3)))\ntest_283()\n\ndef test_284():\n    assert not is_list_like(float(123.0))\ntest_284()\n\ndef test_285():\n    assert is_list_like(dict(a=1, b=2).keys())\ntest_285()\n\ndef test_289():\n    assert not is_list_like({'a':1, 'b':2, 'c':3})\ntest_289()\n\ndef test_293():\n    assert is_list_like(set([1,2,3]))\ntest_293()\n\ndef test_296():\n    assert is_list_like('abcd') is False\ntest_296()\n\ndef test_297():\n    assert not is_list_like( dict(a=1, b=2) )\ntest_297()\n\ndef test_298():\n    assert is_list_like(list(dict(a=1, b=2).keys()))\ntest_298()\n\ndef test_299():\n    assert not is_list_like(dict())\ntest_299()\n\ndef test_300():\n    assert is_list_like(list('hello'))\ntest_300()\n\ndef test_301():\n    assert not is_list_like(range(10))\ntest_301()\n\ndef test_302():\n    assert not is_list_like(dict(a=1,b=2,c=3).items())\ntest_302()\n\ndef test_303():\n    assert is_list_like(frozenset(range(10)))\ntest_303()\n\ndef test_304():\n    assert is_list_like({}) is False\ntest_304()\n\ndef test_305():\n    assert is_list_like( 'hello' ) is False\ntest_305()\n\ndef test_307():\n    assert not is_list_like('Hello, World!')\ntest_307()\n\ndef test_308():\n    assert is_list_like( sorted([1, 2, 3]) ) is True\ntest_308()\n\ndef test_310():\n    assert is_list_like(b'') == False\ntest_310()\n\ndef test_311():\n    assert is_list_like(sorted('hello')) == True\ntest_311()\n\ndef test_313():\n    assert is_list_like(tuple([1, 2, 3]))\ntest_313()\n\ndef test_314():\n    assert is_list_like('hello') is False\ntest_314()\n\ndef test_316():\n    assert is_list_like(frozenset(['a', 'b', 'c'])) is True\ntest_316()\n\ndef test_318():\n    assert is_list_like(list(range(10)))\ntest_318()\n\ndef test_319():\n    assert not is_list_like('hello')\ntest_319()\n\ndef test_321():\n    assert is_list_like( 42.0 ) is False\ntest_321()\n\ndef test_322():\n    assert not is_list_like(True)\ntest_322()\n\ndef test_323():\n    assert is_list_like(list(dict(a=1, b=2).items()))\ntest_323()\n\ndef test_324():\n    assert is_list_like(reversed([1, 2, 4]))\ntest_324()\n\ndef test_325():\n    assert not is_list_like(int(2))\ntest_325()\n\ndef test_326():\n    assert is_list_like(frozenset({1, 2, 3}))\ntest_326()\n\ndef test_328():\n    assert is_list_like({1, 2, 3})\ntest_328()\n\ndef test_330():\n    assert is_list_like(set([1, 2]))\ntest_330()\n\ndef test_331():\n    assert not is_list_like({'a': 1, 'b': 2})\ntest_331()\n\ndef test_337():\n    assert not is_list_like(1.1)\ntest_337()\n\ndef test_338():\n    assert is_list_like({'a', 'b', 'c'}) is True\ntest_338()\n\ndef test_340():\n    assert is_list_like(set([1, 2, 3, 4, 5]))\ntest_340()\n\ndef test_341():\n    assert is_list_like(dict(a=1, b=2).values())\ntest_341()\n\ndef test_342():\n    assert is_list_like(None) == False\ntest_342()\n\ndef test_343():\n    assert is_list_like(bytearray) is False\ntest_343()\n\ndef test_347():\n    assert is_list_like(frozenset(['a', 'b']))\ntest_347()\n\ndef test_348():\n    assert is_list_like(bytes(b'hello')) is False\ntest_348()\n\ndef test_349():\n    assert is_list_like([1])\ntest_349()\n\ndef test_351():\n    assert is_list_like(set([1, 2, 4]))\ntest_351()\n\ndef test_352():\n    assert is_list_like(list((1,2,3)))\ntest_352()\n\ndef test_353():\n    assert not is_list_like(  1                )\ntest_353()\n\ndef test_354():\n    assert not is_list_like(  'hello'           )\ntest_354()\n\ndef test_355():\n    assert not is_list_like(  str('hello')      )\ntest_355()\n\ndef test_358():\n    assert is_list_like(set([1, 2, 3]))\ntest_358()\n\ndef test_360():\n    assert is_list_like( reversed([1, 2, 4]) )\ntest_360()\n\ndef test_361():\n    assert is_list_like(list([1,2,3]))\ntest_361()\n\ndef test_362():\n    assert is_list_like(()) == True\ntest_362()\n\ndef test_363():\n    assert is_list_like(frozenset([1, 2, 3, 4, 5]))\ntest_363()\n\ndef test_365():\n    assert not is_list_like( None )\ntest_365()\n\ndef test_367():\n    assert is_list_like(list(dict(a=1, b=2).values()))\ntest_367()\n\ndef test_368():\n    assert is_list_like(dict().values())\ntest_368()\n\ndef test_371():\n    assert is_list_like(deque()) is True\ntest_371()\n\ndef test_372():\n    assert is_list_like(UserList([1, 2, 4]))\ntest_372()\n\ndef test_373():\n    assert is_list_like(dict()) is False\ntest_373()\n\ndef test_374():\n    assert is_list_like(list())\ntest_374()\n\ndef test_375():\n    assert is_list_like({1: 'a', 2: 'b', 3: 'c'}.values())\ntest_375()\n\ndef test_380():\n    assert is_list_like(list(['a', 'b', 'c'])) is True\ntest_380()\n\ndef test_382():\n    assert not is_list_like(dict(a=1, b=2, c=3).values)\ntest_382()\n\ndef test_384():\n    assert is_list_like(iter(dict().items()))\ntest_384()\n\ndef test_386():\n    assert is_list_like({}) == False\ntest_386()\n\ndef test_387():\n    assert is_list_like(('a', 'b', 'c')) is True\ntest_387()\n\ndef test_388():\n    assert not is_list_like(  int(1)            )\ntest_388()\n\ndef test_389():\n    assert is_list_like([1, 2, 3])\ntest_389()\n\ndef test_392():\n    assert is_list_like(dict(a=1, b=2, c=3).keys()) is True\ntest_392()\n\ndef test_393():\n    assert not is_list_like(int(10))\ntest_393()\n\ndef test_395():\n    assert is_list_like( tuple([1, 2, 3]) ) is True\ntest_395()\n\ndef test_396():\n    assert is_list_like('hello') == False\ntest_396()\n\ndef test_3():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2)) == output\ntest_3()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello')) == output\ntest_11()\n\ndef test_15():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_15\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(zip([1,2,3], [1,2,3])) == output\ntest_15()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1, 2, 3])) == output\ntest_20()\n\ndef test_32():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_32\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict([(1, 'a'), (2, 'b'), (3, 'c')]) ) == output\ntest_32()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.keys()) == output\ntest_36()\n\ndef test_37():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_37\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1, 2, 3})) == output\ntest_37()\n\ndef test_42():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_42\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(range(10)) == output\ntest_42()\n\ndef test_44():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_44\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1, 2, 3])) == output\ntest_44()\n\ndef test_47():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_47\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( frozenset([1,2,3]) ) == output\ntest_47()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed(range(0, 10))) == output\ntest_51()\n\ndef test_57():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_57\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList([1, 2, 3])) == output\ntest_57()\n\ndef test_61():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_61\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( (1,2) ) == output\ntest_61()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set()) == output\ntest_73()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset('hello')) == output\ntest_83()\n\ndef test_84():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_84\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset([1,2,3])) == output\ntest_84()\n\ndef test_95():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_95\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like([1, 2, 3]) == output\ntest_95()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(frozenset({1, 2, 3})) == output\ntest_96()\n\ndef test_108():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_108\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({1, 2, 3}) == output\ntest_108()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(Iterator) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).keys()) == output\ntest_119()\n\ndef test_127():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_127\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.values()) == output\ntest_127()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({key: key for key in range(10)}.keys()) == output\ntest_128()\n\ndef test_132():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_132\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.keys()\n    ) == output\ntest_132()\n\ndef test_135():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_135\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(UserList()) == output\ntest_135()\n\ndef test_136():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_136\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate(['a', 'b', 'c'])) == output\ntest_136()\n\ndef test_137():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_137\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple('hello')) == output\ntest_137()\n\ndef test_142():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_142\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([], maxlen=2)) == output\ntest_142()\n\ndef test_148():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_148\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set([1,2,3])) == output\ntest_148()\n\ndef test_162():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_162\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello')) == output\ntest_162()\n\ndef test_185():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_185\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1,b=2,c=3).values()) == output\ntest_185()\n\ndef test_199():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_199\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(reversed([1,2,3])) == output\ntest_199()\n\ndef test_220():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_220\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list('hello')) == output\ntest_220()\n\ndef test_222():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_222\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_222()\n\ndef test_232():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_232\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(\n        {1: 'one', 2: 'two', 3: 'three'}.values()\n    ) == output\ntest_232()\n\ndef test_235():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_235\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2, c=3) ) == output\ntest_235()\n\ndef test_240():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_240\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(deque([1,2,3])) == output\ntest_240()\n\ndef test_246():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_246\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set('hello')) == output\ntest_246()\n\ndef test_248():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_248\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(list) == output\ntest_248()\n\ndef test_253():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_253\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(KeysView({})) == output\ntest_253()\n\ndef test_254():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_254\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(set('hello'))) == output\ntest_254()\n\ndef test_257():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_257\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(set) == output\ntest_257()\n\ndef test_259():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_259\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).keys() ) == output\ntest_259()\n\ndef test_267():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_267\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(enumerate([])) == output\ntest_267()\n\ndef test_275():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_275\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('hello'.encode())) == output\ntest_275()\n\ndef test_287():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_287\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like('hello') == output\ntest_287()\n\ndef test_288():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_288\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(tuple([1,2,3])) == output\ntest_288()\n\ndef test_294():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_294\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({})) == output\ntest_294()\n\ndef test_295():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_295\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted('hello')) == output\ntest_295()\n\ndef test_309():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_309\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(b'hello'.decode())) == output\ntest_309()\n\ndef test_312():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_312\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({}) == output\ntest_312()\n\ndef test_315():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_315\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).values()) == output\ntest_315()\n\ndef test_317():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_317\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({key: key for key in range(10)})) == output\ntest_317()\n\ndef test_320():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_320\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( dict(a=1, b=2).values() ) == output\ntest_320()\n\ndef test_329():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_329\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_329()\n\ndef test_334():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_334\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2).items()) == output\ntest_334()\n\ndef test_339():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_339\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict().items()) == output\ntest_339()\n\ndef test_344():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_344\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter(dict(a=1, b=2))) == output\ntest_344()\n\ndef test_346():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_346\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like((1, 2, 3)) == output\ntest_346()\n\ndef test_350():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_350\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like({'a':1, 'b':2, 'c':3}.values()) == output\ntest_350()\n\ndef test_356():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_356\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3)) == output\ntest_356()\n\ndef test_370():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_370\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter('')) == output\ntest_370()\n\ndef test_378():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_378\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like( set([1,2,3]) ) == output\ntest_378()\n\ndef test_383():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_383\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(iter({1: 1, 2: 2})) == output\ntest_383()\n\ndef test_385():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_385\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(dict(a=1, b=2, c=3).items()) == output\ntest_385()\n\ndef test_394():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_list_like/test_394\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_list_like(sorted([1, 2, 3])) == output\ntest_394()\n\n\n"]}
{"task_id": 145, "project": "test-apps/flutils", "module": "flutils.objutils", "predictions": ["from typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is an instance of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    for cls in classes:\n        if isinstance(obj, cls):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # The docstring indicates checking if 'obj' is an 'instance of ANY given *classes*'.\n    # Python's built-in isinstance() function is designed for this purpose.\n    # It can accept a single class or a tuple of classes as its second argument.\n    # Since *classes collects all additional arguments into a tuple,\n    # we can directly pass this tuple to isinstance().\n    return isinstance(obj, classes)", "from collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.obj)`: The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # The docstring's primary description \"is a subclass of any\" might suggest `issubclass`.\n    # However, the \"rtype\" description \"if the given `obj` is an instance of ANY given `*classes`\"\n    # and the provided example `is_subclass_of_any(obj.keys(),...)` (where `obj.keys()` is an instance)\n    # strongly indicate that the function should check if `obj` is an instance of any of the `classes`.\n    # This interpretation is further supported by the usage of this function within `is_list_like`,\n    # where `obj` is typically an instance.\n    for cls in classes:\n        if isinstance(obj, cls):\n            return True\n    return False", "from typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    for cls in classes:\n        # The docstring explicitly states \"True if the given ``obj`` is an instance of ANY given *classes*\".\n        # This implies using isinstance, not issubclass.\n        # Python's isinstance function can handle types, tuples of types, and abstract base classes\n        # (like those in collections.abc). It correctly identifies if an object is an instance of a\n        # class or a virtual subclass of an abstract base class.\n        try:\n            if isinstance(obj, cls):\n                return True\n        except TypeError:\n            # If 'cls' is not a type or a tuple of types (e.g., an int or string),\n            # isinstance will raise a TypeError. In such cases, 'obj' cannot logically\n            # be an instance of 'cls' as intended by the function's purpose.\n            # We catch this and simply continue to the next 'cls' in the sequence,\n            # effectively ignoring non-class arguments.\n            pass\n    return False", "from typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # If no classes are provided in *classes, obj cannot be an instance of any of them.\n    # Additionally, isinstance() raises a TypeError if its second argument (the type tuple) is empty.\n    if not classes:\n        return False\n\n    # The isinstance() function can accept a tuple of types as its second argument.\n    # It returns True if the object is an instance of any of the types in the tuple.\n    return isinstance(obj, classes)"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is an instance of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    for cls in classes:\n        if isinstance(obj, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # The docstring indicates checking if 'obj' is an 'instance of ANY given *classes*'.\n    # Python's built-in isinstance() function is designed for this purpose.\n    # It can accept a single class or a tuple of classes as its second argument.\n    # Since *classes collects all additional arguments into a tuple,\n    # we can directly pass this tuple to isinstance().\n    return isinstance(obj, classes)\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.obj)`: The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # The docstring's primary description \"is a subclass of any\" might suggest `issubclass`.\n    # However, the \"rtype\" description \"if the given `obj` is an instance of ANY given `*classes`\"\n    # and the provided example `is_subclass_of_any(obj.keys(),...)` (where `obj.keys()` is an instance)\n    # strongly indicate that the function should check if `obj` is an instance of any of the `classes`.\n    # This interpretation is further supported by the usage of this function within `is_list_like`,\n    # where `obj` is typically an instance.\n    for cls in classes:\n        if isinstance(obj, cls):\n            return True\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    for cls in classes:\n        # The docstring explicitly states \"True if the given ``obj`` is an instance of ANY given *classes*\".\n        # This implies using isinstance, not issubclass.\n        # Python's isinstance function can handle types, tuples of types, and abstract base classes\n        # (like those in collections.abc). It correctly identifies if an object is an instance of a\n        # class or a virtual subclass of an abstract base class.\n        try:\n            if isinstance(obj, cls):\n                return True\n        except TypeError:\n            # If 'cls' is not a type or a tuple of types (e.g., an int or string),\n            # isinstance will raise a TypeError. In such cases, 'obj' cannot logically\n            # be an instance of 'cls' as intended by the function's purpose.\n            # We catch this and simply continue to the next 'cls' in the sequence,\n            # effectively ignoring non-class arguments.\n            pass\n    return False\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/flutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom collections import (\n    UserList,\n    deque,\n)\nfrom collections.abc import (\n    Iterator,\n    KeysView,\n    ValuesView,\n)\nfrom typing import Any as _Any\n\n\n__all__ = [\n    'has_any_attrs',\n    'has_any_callables',\n    'has_attrs',\n    'has_callables',\n    'is_list_like',\n    'is_subclass_of_any',\n]\n\n\n_LIST_LIKE = (\n    list,\n    set,\n    frozenset,\n    tuple,\n    deque,\n    Iterator,\n    ValuesView,\n    KeysView,\n    UserList\n)\n\n\ndef has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False\n\n\ndef has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False\n\n\ndef has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True\n\n\ndef has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False\n\n\ndef is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False\n\n\nfrom typing import Any as _Any\n\n\ndef is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is an instance of ANY given\n    ``*classes``;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import is_subclass_of_any\n    >>> from collections import ValuesView, KeysView, UserList\n    >>> obj = dict(a=1, b=2)\n    >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n    True\n    \"\"\"\n    # If no classes are provided in *classes, obj cannot be an instance of any of them.\n    # Additionally, isinstance() raises a TypeError if its second argument (the type tuple) is empty.\n    if not classes:\n        return False\n\n    # The isinstance() function can accept a tuple of types as its second argument.\n    # It returns True if the object is an instance of any of the types in the tuple.\n    return isinstance(obj, classes)\n\n\nimport pickle\ndef test_2():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView, KeysView, UserList) is True\ntest_2()\n\ndef test_3():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),\n                               ValuesView,\n                               KeysView,\n                               UserList)\ntest_3()\n\ndef test_4():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict, list) is True\ntest_4()\n\ndef test_7():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_7()\n\ndef test_8():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,UserList)\ntest_8()\n\ndef test_9():\n    assert not is_subclass_of_any(\n        set(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_9()\n\ndef test_12():\n    assert not is_subclass_of_any(dict(a=1), ValuesView, KeysView)\ntest_12()\n\ndef test_14():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),dict,list)\ntest_14()\n\ndef test_15():\n    assert is_subclass_of_any(dict(a=1).keys(), ValuesView, KeysView)\ntest_15()\n\ndef test_17():\n    assert is_subclass_of_any(dict(a=1, b=2).items(), ValuesView, KeysView, UserList) is False\ntest_17()\n\ndef test_18():\n    assert not is_subclass_of_any(\n        [1, 2, 3],\n        ValuesView, KeysView, UserList\n    )\ntest_18()\n\ndef test_22():\n    assert not is_subclass_of_any(\n        deque(maxlen=5),\n        ValuesView, KeysView, UserList\n    )\ntest_22()\n\ndef test_24():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict)\ntest_24()\n\ndef test_26():\n    assert is_subclass_of_any(\n            {}.keys(),  # type: ignore[arg-type]\n            ValuesView, KeysView, UserList,\n    )\ntest_26()\n\ndef test_27():\n    assert not is_subclass_of_any(dict(a=1, b=2), bool, int)\ntest_27()\n\ndef test_28():\n    assert is_subclass_of_any(UserList(), KeysView, ValuesView, UserList)\ntest_28()\n\ndef test_29():\n    assert not is_subclass_of_any(deque().__class__, KeysView, ValuesView, dict)\ntest_29()\n\ndef test_30():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),\n                                   dict,\n                                   list,\n                                   deque)\ntest_30()\n\ndef test_31():\n    assert not is_subclass_of_any(\n        tuple(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_31()\n\ndef test_32():\n    assert is_subclass_of_any(tuple(), tuple, set)\ntest_32()\n\ndef test_37():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    )\ntest_37()\n\ndef test_38():\n    assert is_subclass_of_any(\n            dict(a=1, b=2).keys(),\n            ValuesView,\n            KeysView,\n            UserList,\n        ) is True\ntest_38()\n\ndef test_39():\n    assert not is_subclass_of_any(dict().values(), KeysView, UserList)\ntest_39()\n\ndef test_40():\n    assert is_subclass_of_any(dict(a=1, b=2), dict, list, UserList)\ntest_40()\n\ndef test_42():\n    assert not is_subclass_of_any(deque(), Iterator, KeysView)\ntest_42()\n\ndef test_43():\n    assert not is_subclass_of_any(dict().values(), UserList, KeysView)\ntest_43()\n\ndef test_45():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList\n    )\ntest_45()\n\ndef test_46():\n    assert not is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n    )\ntest_46()\n\ndef test_47():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),int,float)\ntest_47()\n\ndef test_50():\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) is False\ntest_50()\n\ndef test_52():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList\n    )\ntest_52()\n\ndef test_54():\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list, dict)\ntest_54()\n\ndef test_55():\n    assert not is_subclass_of_any(\n        tuple,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_55()\n\ndef test_57():\n    assert is_subclass_of_any(10, Iterator, dict, list) is False\ntest_57()\n\ndef test_58():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is False\ntest_58()\n\ndef test_59():\n    assert not is_subclass_of_any(deque(), ValuesView, KeysView)\ntest_59()\n\ndef test_60():\n    assert not is_subclass_of_any(deque(), list)\ntest_60()\n\ndef test_61():\n    assert not is_subclass_of_any(1234, ValuesView, KeysView, UserList)\ntest_61()\n\ndef test_64():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_64()\n\ndef test_65():\n    assert is_subclass_of_any(dict().values(), ValuesView, KeysView, UserList)\ntest_65()\n\ndef test_66():\n    assert is_subclass_of_any(deque(), deque, list)\ntest_66()\n\ndef test_67():\n    assert not is_subclass_of_any(\n        list(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_67()\n\ndef test_68():\n    assert is_subclass_of_any(deque(), deque)\ntest_68()\n\ndef test_69():\n    assert is_subclass_of_any(dict(a=1).values(), ValuesView, KeysView)\ntest_69()\n\ndef test_72():\n    assert is_subclass_of_any(dict(a=1,b=2), Iterator, dict) is True\ntest_72()\n\ndef test_75():\n    assert not is_subclass_of_any(\n        set,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_75()\n\ndef test_77():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).values(),\n        ValuesView,\n        UserList,\n    ) is True\ntest_77()\n\ndef test_79():\n    assert is_subclass_of_any(dict(a=1, b=2).values(), ValuesView, KeysView, UserList) is True\ntest_79()\n\ndef test_84():\n    assert not is_subclass_of_any(dict(a=1, b=2), str, int, float)\ntest_84()\n\ndef test_85():\n    assert not is_subclass_of_any(\n        dict(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_85()\n\ndef test_86():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),str,UserList)\ntest_86()\n\ndef test_87():\n    assert is_subclass_of_any(\n            UserList(range(0, 10)),\n            Iterator,\n            UserList,\n            ValuesView,\n            KeysView,\n        )\ntest_87()\n\ndef test_88():\n    assert not is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n    )\ntest_88()\n\ndef test_89():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).items(),\n        ValuesView,\n        UserList,\n    ) is False\ntest_89()\n\ndef test_90():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_90()\n\ndef test_94():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n        Iterator,\n        object,\n        Exception,\n        str,\n        int,\n        bool,\n    )\ntest_94()\n\ndef test_95():\n    assert is_subclass_of_any(\n            object(),\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) is False\ntest_95()\n\ndef test_97():\n    assert not is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n    )\ntest_97()\n\ndef test_102():\n    assert not is_subclass_of_any(set(), ValuesView, KeysView)\ntest_102()\n\ndef test_103():\n    assert not is_subclass_of_any(\n        dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_103()\n\ndef test_104():\n    assert is_subclass_of_any(dict(a=1, b=2), UserList, dict, list, dict)\ntest_104()\n\ndef test_106():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_106()\n\ndef test_108():\n    assert not is_subclass_of_any(\n        dict,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_108()\n\ndef test_111():\n    assert is_subclass_of_any(dict(a=1, b=2), dict)\ntest_111()\n\ndef test_114():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        KeysView,\n        UserList,\n    ) is True\ntest_114()\n\ndef test_115():\n    assert is_subclass_of_any(dict(), UserList, dict)\ntest_115()\n\ndef test_116():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,Iterator)\ntest_116()\n\ndef test_117():\n    assert not is_subclass_of_any(dict(a=1, b=2), list)\ntest_117()\n\ndef test_118():\n    assert not is_subclass_of_any(\n        deque(),\n        ValuesView, KeysView, UserList, Iterator\n    )\ntest_118()\n\ndef test_120():\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView, UserList) is True\ntest_120()\n\ndef test_121():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),UserList,int,float)\ntest_121()\n\ndef test_124():\n    assert not is_subclass_of_any(dict(), ValuesView, KeysView, UserList)\ntest_124()\n\ndef test_125():\n    assert not is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList)\ntest_125()\n\ndef test_126():\n    assert not is_subclass_of_any(\n        list,\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_126()\n\ndef test_127():\n    assert not is_subclass_of_any(dict(a=1, b=2).keys(),bool,tuple)\ntest_127()\n\ndef test_129():\n    assert is_subclass_of_any(\n        UserList(),\n        ValuesView,\n        KeysView,\n        UserList\n    )\ntest_129()\n\ndef test_130():\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList)\ntest_130()\n\ndef test_0():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), deque, dict) == output\ntest_0()\n\ndef test_1():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), KeysView, ValuesView, UserList) == output\ntest_1()\n\ndef test_5():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), ValuesView, KeysView, UserList) == output\ntest_5()\n\ndef test_6():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView, UserList) == output\ntest_6()\n\ndef test_10():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_10\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1,b=2), UserList, dict, list) == output\ntest_10()\n\ndef test_11():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, list, tuple) == output\ntest_11()\n\ndef test_13():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_13\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            deque(['a', 'b']),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_13()\n\ndef test_19():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_19\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2), ValuesView, KeysView, UserList\n        ) == output\ntest_19()\n\ndef test_20():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView) == output\ntest_20()\n\ndef test_21():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_21\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_21()\n\ndef test_23():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_23\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, KeysView, ValuesView) == output\ntest_23()\n\ndef test_25():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_25\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), UserList, KeysView, ValuesView) == output\ntest_25()\n\ndef test_33():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_33\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), list, dict, KeysView) == output\ntest_33()\n\ndef test_34():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_34\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),ValuesView,KeysView,deque) == output\ntest_34()\n\ndef test_35():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_35\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            dict(a=1, b=2),\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_35()\n\ndef test_36():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_36\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView, KeysView, UserList, Iterator\n    ) == output\ntest_36()\n\ndef test_41():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_41\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(set(), KeysView, ValuesView, UserList) == output\ntest_41()\n\ndef test_48():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_48\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), deque, KeysView, ValuesView) == output\ntest_48()\n\ndef test_49():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_49\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), UserList, dict) == output\ntest_49()\n\ndef test_51():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_51\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(),\n        ValuesView,\n        UserList,\n    ) == output\ntest_51()\n\ndef test_53():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_53\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).values(),\n                                  ValuesView,\n                                  KeysView,\n                                  UserList) == output\ntest_53()\n\ndef test_56():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_56\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, list, dict) == output\ntest_56()\n\ndef test_63():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_63\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().values(), KeysView, ValuesView, UserList) == output\ntest_63()\n\ndef test_70():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_70\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList) == output\ntest_70()\n\ndef test_71():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_71\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(list(), KeysView, ValuesView, UserList) == output\ntest_71()\n\ndef test_73():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_73\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, UserList) == output\ntest_73()\n\ndef test_74():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_74\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), dict, UserList) == output\ntest_74()\n\ndef test_76():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_76\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(tuple(), tuple, set) == output\ntest_76()\n\ndef test_80():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_80\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, ValuesView) == output\ntest_80()\n\ndef test_81():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_81\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque([]), Iterator, dict, list) == output\ntest_81()\n\ndef test_82():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_82\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        UserList,\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_82()\n\ndef test_83():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_83\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), ValuesView, KeysView) == output\ntest_83()\n\ndef test_91():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_91\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, KeysView, UserList) == output\ntest_91()\n\ndef test_92():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_92\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(maxlen=5), Iterator, ValuesView, KeysView, UserList) == output\ntest_92()\n\ndef test_93():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_93\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(UserList([]), Iterator, dict, list) == output\ntest_93()\n\ndef test_96():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_96\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2).keys(), ValuesView, KeysView, UserList, dict) == output\ntest_96()\n\ndef test_98():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_98\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1), ValuesView, KeysView, UserList, list) == output\ntest_98()\n\ndef test_99():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_99\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque(), Iterator, dict, KeysView) == output\ntest_99()\n\ndef test_100():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_100\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(),UserList,KeysView,ValuesView) == output\ntest_100()\n\ndef test_101():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_101\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        deque(),\n        ValuesView,\n        KeysView,\n        UserList\n    ) == output\ntest_101()\n\ndef test_105():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_105\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), KeysView, ValuesView, UserList) == output\ntest_105()\n\ndef test_107():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_107\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            object(),\n            ValuesView,\n            KeysView,\n            UserList,\n            dict,\n            list,\n            set,\n            deque,\n        ) == output\ntest_107()\n\ndef test_109():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_109\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(deque().__class__, UserList, Iterator) == output\ntest_109()\n\ndef test_110():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_110\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n        dict(a=1, b=2),\n        ValuesView, KeysView, UserList\n    ) == output\ntest_110()\n\ndef test_112():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_112\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2), KeysView, ValuesView, UserList) == output\ntest_112()\n\ndef test_113():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_113\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(a=1, b=2).keys(), ValuesView, KeysView) == output\ntest_113()\n\ndef test_119():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_119\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(\n            ['a', 'b'],\n            ValuesView,\n            KeysView,\n            UserList,\n    ) == output\ntest_119()\n\ndef test_122():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_122\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict().keys(), KeysView, ValuesView, UserList) == output\ntest_122()\n\ndef test_123():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_123\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), deque, dict) == output\ntest_123()\n\ndef test_128():\n    with open(\"/output/test-apps+flutils/test_output/flutils+objutils/is_subclass_of_any/test_128\", \"rb\") as f:\n        output = pickle.load(f)\n    assert is_subclass_of_any(dict(), ValuesView, KeysView) == output\ntest_128()\n\n\n"]}
